<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Specification - TappsCodingAgents</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <h1>ğŸ¤– TappsCodingAgents</h1>
                <span class="version">v2.0.1</span>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="user-guide-index.html">User Guide</a></li>
                <li><a href="technical-spec.html" class="active">Technical Spec</a></li>
                <li><a href="examples.html">Examples</a></li>
                <li><a href="api-reference.html">API Reference</a></li>
            </ul>
        </div>
    </nav>

    <main class="main-content">
        <div class="page-content">
            <h1>Technical Specification</h1>
            <p class="lead">Comprehensive technical documentation covering architecture, algorithms, and implementation details</p>

            <section id="architecture">
                <h2>System Architecture</h2>
                
                <h3>Overview</h3>
                <p>TappsCodingAgents follows a layered architecture with clear separation of concerns:</p>
                <ul>
                    <li><strong>Agent Layer</strong> - 13 specialized workflow agents</li>
                    <li><strong>Core Framework</strong> - Base classes, configuration, and utilities</li>
                    <li><strong>Model Abstraction Layer (MAL)</strong> - Unified interface for LLM providers</li>
                    <li><strong>Context System</strong> - Tiered context injection with caching</li>
                    <li><strong>Expert Framework</strong> - Industry experts with weighted decision-making</li>
                    <li><strong>Workflow Engine</strong> - YAML-based workflow orchestration</li>
                </ul>

                <h3>Component Diagram</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>Architecture Layers</span>
                    </div>
                    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           User Interface (CLI/Skills)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Agent Layer (13 Agents)            â”‚
â”‚  Analyst â”‚ Planner â”‚ Architect â”‚ Designer â”‚ ... â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Core Framework                      â”‚
â”‚  â€¢ BaseAgent                                    â”‚
â”‚  â€¢ Configuration System                         â”‚
â”‚  â€¢ Error Handling                               â”‚
â”‚  â€¢ Context Manager                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Model Abstraction Layer (MAL)           â”‚
â”‚  â€¢ Ollama (Local)                               â”‚
â”‚  â€¢ Anthropic (Cloud)                           â”‚
â”‚  â€¢ OpenAI (Cloud)                               â”‚
â”‚  â€¢ Automatic Fallback                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Tiered Context System                   â”‚
â”‚  â€¢ Tier 1: Core Context (~500 tokens)          â”‚
â”‚  â€¢ Tier 2: Extended Context (~2K tokens)       â”‚
â”‚  â€¢ Tier 3: Full Context (~10K tokens)          â”‚
â”‚  â€¢ Intelligent Caching                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
                </div>
            </section>

            <section id="model-abstraction-layer">
                <h2>Model Abstraction Layer (MAL)</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Model Abstraction Layer provides a unified interface for multiple LLM providers, enabling seamless switching between local (Ollama) and cloud (Anthropic, OpenAI) models. This abstraction is critical for:</p>
                <ul>
                    <li><strong>Cost Optimization</strong> - Use local models for routine tasks, cloud for complex ones</li>
                    <li><strong>Reliability</strong> - Automatic fallback when primary provider fails</li>
                    <li><strong>Flexibility</strong> - Easy integration of new providers</li>
                    <li><strong>Performance</strong> - Route tasks to appropriate models based on complexity</li>
                </ul>

                <h3>Routing Algorithm</h3>
                <p>The MAL routing algorithm follows this decision tree:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>MAL Routing Logic</span>
                    </div>
                    <pre><code>function routeRequest(task, config):
    // Check runtime mode (Cursor vs headless)
    if runtimeMode == CURSOR:
        raise MALDisabledInCursorModeError()
    
    // Determine provider
    provider = config.default_provider or "ollama"
    model = task.model or config.default_model
    
    // Try primary provider
    try:
        result = generate(provider, model, task.prompt)
        return result
    except Exception as e:
        // Fallback logic
        if config.enable_fallback and provider == "ollama":
            for fallback in config.fallback_providers:
                try:
                    result = generate(fallback, model, task.prompt)
                    return result
                except:
                    continue
        raise ConnectionError("All providers failed")</code></pre>
                </div>

                <h3>Streaming Support</h3>
                <p>MAL supports streaming for large responses to prevent timeouts and improve UX. The streaming algorithm:</p>
                <ol>
                    <li>Detects if streaming should be used based on prompt size and config</li>
                    <li>Uses newline-delimited JSON (ndjson) for Ollama streaming</li>
                    <li>Accumulates tokens in real-time with progress callbacks</li>
                    <li>Handles errors gracefully during streaming</li>
                </ol>

                <h3>Provider-Specific Implementations</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Provider</th>
                            <th>Endpoint</th>
                            <th>Authentication</th>
                            <th>Streaming</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Ollama</td>
                            <td><code>http://localhost:11434/api/generate</code></td>
                            <td>None (local)</td>
                            <td>ndjson</td>
                        </tr>
                        <tr>
                            <td>Anthropic</td>
                            <td><code>https://api.anthropic.com/v1/messages</code></td>
                            <td>API Key</td>
                            <td>SSE</td>
                        </tr>
                        <tr>
                            <td>OpenAI</td>
                            <td><code>https://api.openai.com/v1/chat/completions</code></td>
                            <td>API Key</td>
                            <td>SSE</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="tiered-context">
                <h2>Tiered Context System</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Tiered Context System achieves <strong>90%+ token savings</strong> by intelligently loading only the context needed for each task. This is critical because:</p>
                <ul>
                    <li><strong>Cost Reduction</strong> - Fewer tokens = lower API costs</li>
                    <li><strong>Performance</strong> - Smaller contexts = faster processing</li>
                    <li><strong>Quality</strong> - Focused context = better agent decisions</li>
                    <li><strong>Scalability</strong> - Enables handling of large codebases</li>
                </ul>

                <h3>Context Tier Definitions</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tier</th>
                            <th>Content</th>
                            <th>Token Cost</th>
                            <th>Cache TTL</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Tier 1</strong></td>
                            <td>File structure, type definitions, function signatures, imports</td>
                            <td>~500 tokens</td>
                            <td>5 minutes</td>
                            <td>Most agent tasks (90% of cases)</td>
                        </tr>
                        <tr>
                            <td><strong>Tier 2</strong></td>
                            <td>Tier 1 + function bodies, local dependencies, test files</td>
                            <td>~2,000 tokens</td>
                            <td>2 minutes</td>
                            <td>Implementation tasks</td>
                        </tr>
                        <tr>
                            <td><strong>Tier 3</strong></td>
                            <td>Tier 2 + git history, documentation, cross-references</td>
                            <td>~10,000 tokens</td>
                            <td>1 minute</td>
                            <td>Complex analysis</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Context Building Algorithm</h3>
                <p>The context builder uses AST parsing to extract structured information:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Context Building Process</span>
                    </div>
                    <pre><code>function buildContext(filePath, tier, includeRelated):
    // Parse file structure using AST
    moduleInfo = parseAST(filePath)
    
    context = {
        tier: tier,
        file: filePath,
        content: {}
    }
    
    // Tier 1: Core structure
    if tier >= TIER1:
        context.content.structure = extractStructure(moduleInfo)
        context.content.functions = extractFunctionSignatures(moduleInfo)
        context.content.classes = extractClassSignatures(moduleInfo)
        context.content.imports = moduleInfo.imports
    
    // Tier 2: Extended context
    if tier >= TIER2:
        context.content.functionBodies = extractFunctionBodies(filePath, moduleInfo)
        if includeRelated:
            context.content.dependencies = findLocalDependencies(filePath, moduleInfo)
        context.content.testFiles = findTestFiles(filePath)
    
    // Tier 3: Full context
    if tier >= TIER3:
        context.content.fullFile = readFile(filePath)
        context.content.gitHistory = getGitHistory(filePath)
        context.content.documentation = findDocumentation(filePath)
        context.content.crossReferences = findCrossReferences(filePath)
    
    // Calculate token estimate
    context.tokenEstimate = estimateTokens(context)
    
    // Check cache
    cached = cache.get(context.key)
    if cached and not expired(cached):
        return cached
    
    // Store in cache
    cache.put(context.key, context, ttl=tier.cacheTTL)
    
    return context</code></pre>
                </div>

                <h3>Caching Strategy</h3>
                <p>The caching system uses a multi-tier cache with TTL-based expiration:</p>
                <ul>
                    <li><strong>In-Memory Cache</strong> - Fast access for recent contexts</li>
                    <li><strong>File-Based Cache</strong> - Persistent cache across sessions</li>
                    <li><strong>TTL-Based Expiration</strong> - Automatic invalidation based on tier</li>
                    <li><strong>Cache Key Generation</strong> - Based on file path, tier, and content hash</li>
                </ul>

                <h3>Token Estimation</h3>
                <p>Token estimation uses a simple heuristic: approximately 4 characters per token. The system tracks token usage per tier to optimize context selection.</p>
            </section>

            <section id="code-scoring">
                <h2>Code Scoring System</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Code Scoring System provides objective, quantitative metrics for code quality assessment. This is important because:</p>
                <ul>
                    <li><strong>Objective Assessment</strong> - Removes subjectivity from code reviews</li>
                    <li><strong>Quality Gates</strong> - Enables automated quality thresholds</li>
                    <li><strong>Trend Tracking</strong> - Monitor code quality over time</li>
                    <li><strong>Actionable Feedback</strong> - Identifies specific areas for improvement</li>
                </ul>

                <h3>Scoring Metrics</h3>
                <p>The system calculates 5 primary metrics plus 3 additional quality metrics:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>Range</th>
                            <th>Calculation Method</th>
                            <th>Threshold</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Complexity</strong></td>
                            <td>0-10</td>
                            <td>Cyclomatic complexity (Radon), nesting depth, function length</td>
                            <td>Max 8.0</td>
                        </tr>
                        <tr>
                            <td><strong>Security</strong></td>
                            <td>0-10</td>
                            <td>Bandit vulnerability detection + heuristics</td>
                            <td>Min 7.0</td>
                        </tr>
                        <tr>
                            <td><strong>Maintainability</strong></td>
                            <td>0-10</td>
                            <td>Radon Maintainability Index</td>
                            <td>Min 7.0</td>
                        </tr>
                        <tr>
                            <td><strong>Test Coverage</strong></td>
                            <td>0-10</td>
                            <td>Coverage data parsing + heuristic analysis</td>
                            <td>Min 8.0</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>0-10</td>
                            <td>Static analysis (function size, nesting, patterns)</td>
                            <td>Min 6.0</td>
                        </tr>
                        <tr>
                            <td><strong>Linting</strong></td>
                            <td>0-10</td>
                            <td>Ruff linting score</td>
                            <td>Min 7.0</td>
                        </tr>
                        <tr>
                            <td><strong>Type Checking</strong></td>
                            <td>0-10</td>
                            <td>mypy type checking score</td>
                            <td>Min 7.0</td>
                        </tr>
                        <tr>
                            <td><strong>Duplication</strong></td>
                            <td>0-10</td>
                            <td>jscpd duplication detection</td>
                            <td>Max 3.0</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Scoring Algorithm</h3>
                <p>The overall score is calculated using weighted averages:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Overall Score Calculation</span>
                    </div>
                    <pre><code>function calculateOverallScore(scores, weights):
    // Default weights
    defaultWeights = {
        complexity: 0.20,
        security: 0.30,
        maintainability: 0.25,
        test_coverage: 0.15,
        performance: 0.10
    }
    
    weights = merge(defaultWeights, weights)
    
    // Invert complexity (lower is better)
    normalizedComplexity = 10 - scores.complexity
    
    // Calculate weighted average
    overallScore = (
        normalizedComplexity * weights.complexity +
        scores.security * weights.security +
        scores.maintainability * weights.maintainability +
        scores.test_coverage * weights.test_coverage +
        scores.performance * weights.performance
    ) * 10  // Scale to 0-100
    
    return overallScore</code></pre>
                </div>

                <h3>Complexity Calculation</h3>
                <p>Complexity score uses Radon's cyclomatic complexity analysis:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Complexity Algorithm</span>
                    </div>
                    <pre><code>function calculateComplexity(code):
    // Parse code with Radon
    complexityResults = radon.analyze(code)
    
    // Calculate average complexity
    totalComplexity = sum(func.complexity for func in complexityResults)
    avgComplexity = totalComplexity / len(complexityResults)
    
    // Normalize to 0-10 scale
    // Complexity > 10 = score 0
    // Complexity 0 = score 10
    if avgComplexity >= 10:
        return 0.0
    else:
        return 10 - avgComplexity</code></pre>
                </div>

                <h3>Security Calculation</h3>
                <p>Security score combines Bandit vulnerability detection with heuristic analysis:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Security Algorithm</span>
                    </div>
                    <pre><code>function calculateSecurity(filePath, code):
    // Run Bandit security scan
    banditResults = bandit.scan(filePath)
    
    // Count vulnerabilities by severity
    highSeverity = count(banditResults, severity="HIGH")
    mediumSeverity = count(banditResults, severity="MEDIUM")
    lowSeverity = count(banditResults, severity="LOW")
    
    // Heuristic checks
    hasInputValidation = checkInputValidation(code)
    hasErrorHandling = checkErrorHandling(code)
    usesSecureDefaults = checkSecureDefaults(code)
    
    // Calculate base score
    baseScore = 10.0
    baseScore -= highSeverity * 3.0
    baseScore -= mediumSeverity * 1.5
    baseScore -= lowSeverity * 0.5
    
    // Bonus for good practices
    if hasInputValidation:
        baseScore += 1.0
    if hasErrorHandling:
        baseScore += 0.5
    if usesSecureDefaults:
        baseScore += 0.5
    
    return clamp(baseScore, 0.0, 10.0)</code></pre>
                </div>
            </section>

            <section id="expert-system">
                <h2>Expert System and Weighted Decision-Making</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Expert System enables domain-specific knowledge integration with weighted decision-making. This is critical for:</p>
                <ul>
                    <li><strong>Domain Expertise</strong> - Incorporate business domain knowledge</li>
                    <li><strong>Balanced Decisions</strong> - Primary expert has authority, others provide context</li>
                    <li><strong>Consistency</strong> - Standardized expert consultation across agents</li>
                    <li><strong>Extensibility</strong> - Easy addition of new experts</li>
                </ul>

                <h3>Weight Distribution Algorithm</h3>
                <p>The system uses a 51% primary authority model:</p>
                <ul>
                    <li><strong>Primary Expert</strong> - 51% weight (decision authority)</li>
                    <li><strong>Secondary Experts</strong> - 49% / (N-1) weight each (contextual input)</li>
                    <li><strong>Total Weight</strong> - Always sums to 100%</li>
                </ul>

                <h3>Expert Consultation Algorithm</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>Expert Consultation Process</span>
                    </div>
                    <pre><code>async function consultExperts(query, domain):
    // Load expert registry
    registry = ExpertRegistry.load()
    
    // Get relevant experts for domain
    experts = registry.getExpertsForDomain(domain)
    
    // Determine primary expert (51% weight)
    primaryExpert = experts.find(e => e.weight == 0.51)
    secondaryExperts = experts.filter(e => e != primaryExpert)
    
    // Consult all experts in parallel
    responses = await Promise.all(
        experts.map(expert => 
            expert.consult(query, domain)
        )
    )
    
    // Aggregate responses with weighted decision-making
    aggregated = aggregateResponses(
        responses,
        primaryExpert,
        secondaryExperts
    )
    
    return aggregated

function aggregateResponses(responses, primaryExpert, secondaryExperts):
    // Start with primary expert answer (51% influence)
    primaryAnswer = responses.find(r => r.expertId == primaryExpert.id).answer
    aggregated = f"[Primary - {primaryExpert.name}] {primaryAnswer}"
    
    // Add contextual input from secondary experts
    for expert in secondaryExperts:
        expertResponse = responses.find(r => r.expertId == expert.id)
        if expertResponse:
            aggregated += f"\n\n[{expert.name}] {expertResponse.answer}"
    
    return aggregated</code></pre>
                </div>

                <h3>Built-in Experts</h3>
                <p>The framework includes 16 built-in technical experts:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Expert</th>
                            <th>Domain</th>
                            <th>Knowledge Base</th>
                            <th>Consulted By</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Security</td>
                            <td>Security</td>
                            <td>83 knowledge files</td>
                            <td>Architect, Implementer, Reviewer, Ops</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>Performance</td>
                            <td>Performance patterns</td>
                            <td>Architect, Implementer, Reviewer</td>
                        </tr>
                        <tr>
                            <td>Testing</td>
                            <td>Testing</td>
                            <td>Testing strategies</td>
                            <td>Tester, Reviewer</td>
                        </tr>
                        <tr>
                            <td>Data Privacy</td>
                            <td>Privacy</td>
                            <td>Compliance standards</td>
                            <td>Architect, Designer, Ops</td>
                        </tr>
                        <tr>
                            <td>Accessibility</td>
                            <td>Accessibility</td>
                            <td>WCAG guidelines</td>
                            <td>Designer, Implementer</td>
                        </tr>
                        <tr>
                            <td>UX</td>
                            <td>User Experience</td>
                            <td>UX principles</td>
                            <td>Designer</td>
                        </tr>
                        <tr>
                            <td>Code Quality</td>
                            <td>Quality</td>
                            <td>Quality standards</td>
                            <td>Reviewer, Improver</td>
                        </tr>
                        <tr>
                            <td>Software Architecture</td>
                            <td>Architecture</td>
                            <td>Architectural patterns</td>
                            <td>Architect</td>
                        </tr>
                        <tr>
                            <td>DevOps</td>
                            <td>DevOps</td>
                            <td>CI/CD practices</td>
                            <td>Ops</td>
                        </tr>
                        <tr>
                            <td>Documentation</td>
                            <td>Documentation</td>
                            <td>Documentation standards</td>
                            <td>Documenter</td>
                        </tr>
                        <tr>
                            <td>AI Frameworks</td>
                            <td>AI/ML</td>
                            <td>AI framework guidance</td>
                            <td>Architect, Implementer</td>
                        </tr>
                        <tr>
                            <td>Observability</td>
                            <td>Monitoring</td>
                            <td>Observability patterns</td>
                            <td>Architect, Ops</td>
                        </tr>
                        <tr>
                            <td>API Design</td>
                            <td>API</td>
                            <td>API design patterns</td>
                            <td>Designer, Architect</td>
                        </tr>
                        <tr>
                            <td>Cloud Infrastructure</td>
                            <td>Cloud</td>
                            <td>Cloud architecture</td>
                            <td>Architect, Ops</td>
                        </tr>
                        <tr>
                            <td>Database</td>
                            <td>Database</td>
                            <td>Database design</td>
                            <td>Architect, Designer</td>
                        </tr>
                        <tr>
                            <td>Agent Learning</td>
                            <td>Learning</td>
                            <td>Agent improvement</td>
                            <td>All agents</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="workflow-engine">
                <h2>Workflow Engine</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Workflow Engine orchestrates multi-step processes with conditional execution and quality gates. This is important because:</p>
                <ul>
                    <li><strong>Automation</strong> - Automate complex multi-agent processes</li>
                    <li><strong>Consistency</strong> - Standardized processes across projects</li>
                    <li><strong>Quality Gates</strong> - Enforce quality thresholds</li>
                    <li><strong>Artifact Tracking</strong> - Track outputs from each step</li>
                </ul>

                <h3>Workflow Execution Algorithm</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>Workflow Execution</span>
                    </div>
                    <pre><code>async function executeWorkflow(workflowYaml, inputs):
    // Parse workflow definition
    workflow = parseYAML(workflowYaml)
    
    // Initialize state
    state = {
        artifacts: {},
        stepResults: {},
        currentStep: null
    }
    
    // Execute steps in dependency order
    executionOrder = topologicalSort(workflow.steps)
    
    for step in executionOrder:
        // Check dependencies
        if not allDependenciesMet(step, state.stepResults):
            throw DependencyError()
        
        // Check conditions
        if step.condition and not evaluateCondition(step.condition, state):
            skipStep(step)
            continue
        
        // Execute step
        state.currentStep = step
        agent = getAgent(step.agent)
        result = await agent.run(step.command, step.args)
        
        // Store result
        state.stepResults[step.name] = result
        state.artifacts[step.name] = extractArtifacts(result)
        
        // Check quality gates
        if step.gate:
            if not evaluateGate(step.gate, result):
                throw GateFailedError()
    
    return state</code></pre>
                </div>

                <h3>Dependency Resolution</h3>
                <p>The workflow engine uses topological sorting to determine execution order:</p>
                <ol>
                    <li>Build dependency graph from step dependencies</li>
                    <li>Perform topological sort to get execution order</li>
                    <li>Execute steps in order, checking dependencies before each step</li>
                    <li>Handle circular dependencies with error reporting</li>
                </ol>

                <h3>Quality Gates</h3>
                <p>Quality gates enforce thresholds before proceeding:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Gate Evaluation</span>
                    </div>
                    <pre><code>function evaluateGate(gateCondition, stepResult):
    // Parse gate condition
    // Example: "review.overall_score >= 70"
    
    condition = parseCondition(gateCondition)
    
    // Extract value from result
    value = extractValue(condition.path, stepResult)
    
    // Evaluate condition
    if condition.operator == ">=":
        return value >= condition.threshold
    elif condition.operator == "<=":
        return value <= condition.threshold
    elif condition.operator == "==":
        return value == condition.threshold
    else:
        throw UnsupportedOperatorError()</code></pre>
                </div>
            </section>

            <section id="base-agent">
                <h2>Base Agent Architecture</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The BaseAgent class provides common functionality for all agents, ensuring consistency and reducing code duplication. This is critical for:</p>
                <ul>
                    <li><strong>Consistency</strong> - Standardized agent behavior</li>
                    <li><strong>Maintainability</strong> - Common code in one place</li>
                    <li><strong>Extensibility</strong> - Easy creation of new agents</li>
                    <li><strong>BMAD-METHOD Compliance</strong> - Follows activation instruction patterns</li>
                </ul>

                <h3>BMAD-METHOD Pattern</h3>
                <p>All agents follow the BMAD-METHOD activation sequence:</p>
                <ol>
                    <li><strong>Read</strong> agent definition</li>
                    <li><strong>Load</strong> project configuration</li>
                    <li><strong>Load</strong> domain configuration</li>
                    <li><strong>Load</strong> customizations</li>
                    <li><strong>Greet</strong> user</li>
                    <li><strong>Run</strong> *help command</li>
                    <li><strong>Wait</strong> for commands</li>
                </ol>

                <h3>Command Parsing</h3>
                <p>The BaseAgent command parser supports multiple input formats:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Command Parsing</span>
                    </div>
                    <pre><code>function parseCommand(userInput):
    input = userInput.strip()
    
    // Handle empty input
    if not input:
        return ("help", {})
    
    // Handle numbered commands (1, 2, 3...)
    if input.isdigit():
        commandIndex = int(input) - 1
        commands = getCommands()
        if 0 <= commandIndex < len(commands):
            return (commands[commandIndex].command, {})
    
    // Handle star commands (*review, *score)
    if input.startswith("*"):
        parts = input[1:].split(" ", 1)
        command = parts[0]
        args = parts[1] if len(parts) > 1 else ""
    else:
        // Handle regular commands (review, score)
        parts = input.split(" ", 1)
        command = parts[0]
        args = parts[1] if len(parts) > 1 else ""
    
    // Parse arguments for file commands
    parsedArgs = {}
    fileCommands = ["review", "score", "plan", "implement", "test"]
    if command in fileCommands and args:
        parsedArgs["file"] = args.strip()
    
    return (command, parsedArgs)</code></pre>
                </div>
            </section>

            <section id="hardware-profiling">
                <h2>Hardware Profiling and Optimization</h2>
                
                <h3>Purpose and Importance</h3>
                <p>Hardware profiling optimizes performance based on available resources. This is important for:</p>
                <ul>
                    <li><strong>Resource Awareness</strong> - Adapt to available hardware</li>
                    <li><strong>Performance Optimization</strong> - Optimize for low-power devices (NUC)</li>
                    <li><strong>Automatic Configuration</strong> - Auto-detect optimal settings</li>
                    <li><strong>Background Agent Routing</strong> - Route heavy tasks to cloud when needed</li>
                </ul>

                <h3>Profile Detection Algorithm</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>Hardware Profile Detection</span>
                    </div>
                    <pre><code>function detectHardwareProfile():
    metrics = getHardwareMetrics()
    
    // NUC: Low resources
    if metrics.cpuCores <= 6 and metrics.ramGB <= 16:
        return Profile.NUC
    
    // Development: Medium resources
    if metrics.cpuCores <= 12 and metrics.ramGB <= 32:
        return Profile.DEVELOPMENT
    
    // Workstation: High resources
    if metrics.cpuCores > 12 or metrics.ramGB > 32:
        return Profile.WORKSTATION
    
    // Server: Variable (usually custom)
    return Profile.SERVER</code></pre>
                </div>

                <h3>Resource Monitoring</h3>
                <p>The system monitors CPU, memory, and disk usage to make routing decisions:</p>
                <ul>
                    <li><strong>CPU Usage</strong> - Track percentage and alert if > 80%</li>
                    <li><strong>Memory Usage</strong> - Track percentage and available GB</li>
                    <li><strong>Disk Usage</strong> - Track percentage and free space</li>
                    <li><strong>Background Agent Fallback</strong> - Route to cloud if resources constrained</li>
                </ul>
            </section>

            <section id="context7-integration">
                <h2>Context7 Integration</h2>
                
                <h3>Purpose and Importance</h3>
                <p>Context7 provides knowledge base-first caching for library documentation. This is critical for:</p>
                <ul>
                    <li><strong>Documentation Access</strong> - Fast access to library docs</li>
                    <li><strong>Token Savings</strong> - Cache library documentation</li>
                    <li><strong>Analytics</strong> - Track KB usage and performance</li>
                    <li><strong>Cross-Reference Resolution</strong> - Automatic linking of related docs</li>
                </ul>

                <h3>KB-First Caching Strategy</h3>
                <p>The system uses a knowledge base-first approach:</p>
                <ol>
                    <li>Check Context7 KB cache for library documentation</li>
                    <li>If cache hit, use cached documentation</li>
                    <li>If cache miss, fetch from Context7 API</li>
                    <li>Store in cache for future use</li>
                    <li>Track cache hit rates and performance</li>
                </ol>

                <h3>Cache Pre-population</h3>
                <p>The system pre-populates cache with common dependencies:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Cache Pre-population</span>
                    </div>
                    <pre><code>async function prepopulateCache(projectRoot):
    // Read dependencies
    dependencies = readDependencies(projectRoot)
    
    // Pre-populate common libraries
    commonLibraries = [
        "pydantic", "httpx", "pytest", "ruff", "mypy"
    ]
    
    for lib in commonLibraries:
        if lib in dependencies:
            await fetchAndCache(lib)
    
    // Pre-populate project-specific dependencies
    for dep in dependencies:
        if dep not in commonLibraries:
            await fetchAndCache(dep)</code></pre>
                </div>
            </section>

            <section id="multi-agent-orchestration">
                <h2>Multi-Agent Orchestration</h2>
                
                <h3>Purpose and Importance</h3>
                <p>Multi-agent orchestration enables parallel execution of multiple agents with conflict resolution. This is important for:</p>
                <ul>
                    <li><strong>Parallelization</strong> - Execute multiple agents simultaneously</li>
                    <li><strong>Efficiency</strong> - Reduce total execution time</li>
                    <li><strong>Conflict Resolution</strong> - Handle conflicting agent outputs</li>
                    <li><strong>Result Aggregation</strong> - Combine multi-agent results</li>
                </ul>

                <h3>Git Worktree Isolation</h3>
                <p>Each agent operates in an isolated Git worktree to prevent conflicts:</p>
                <div class="code-block">
                    <div class="code-header">
                        <span>Worktree Management</span>
                    </div>
                    <pre><code>async function executeParallelAgents(agents, task):
    // Create worktrees for each agent
    worktrees = []
    for agent in agents:
        worktree = createWorktree(agent.id, task.id)
        worktrees.append(worktree)
    
    // Execute agents in parallel
    results = await Promise.all(
        agents.map(agent => 
            executeInWorktree(agent, worktree, task)
        )
    )
    
    // Aggregate results
    aggregated = aggregateResults(results)
    
    // Resolve conflicts if any
    if hasConflicts(results):
        resolved = resolveConflicts(results)
        aggregated = mergeResults(resolved)
    
    // Cleanup worktrees
    for worktree in worktrees:
        cleanupWorktree(worktree)
    
    return aggregated</code></pre>
                </div>
            </section>

            <section id="mcp-gateway">
                <h2>MCP Gateway</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The MCP (Model Context Protocol) Gateway provides unified tool access across multiple MCP servers. This is critical for:</p>
                <ul>
                    <li><strong>Tool Unification</strong> - Single interface for filesystem, Git, and analysis tools</li>
                    <li><strong>Protocol Compliance</strong> - Standard MCP protocol implementation</li>
                    <li><strong>Server Management</strong> - Manage multiple MCP servers</li>
                    <li><strong>Tool Registry</strong> - Centralized tool discovery and registration</li>
                </ul>

                <h3>MCP Server Support</h3>
                <p>The gateway supports multiple MCP server types:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Server Type</th>
                            <th>Purpose</th>
                            <th>Tools Provided</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Filesystem</td>
                            <td>File operations</td>
                            <td>read_file, write_file, list_directory, search_files</td>
                        </tr>
                        <tr>
                            <td>Git</td>
                            <td>Version control</td>
                            <td>git_status, git_diff, git_commit, git_branch</td>
                        </tr>
                        <tr>
                            <td>Analysis</td>
                            <td>Code analysis</td>
                            <td>analyze_code, find_patterns, detect_issues</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Gateway Architecture</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>MCP Gateway Flow</span>
                    </div>
                    <pre><code>Agent Request
    â†“
MCP Gateway
    â†“
Tool Registry (lookup tool)
    â†“
Route to MCP Server
    â†“
Execute Tool
    â†“
Return Result</code></pre>
                </div>
            </section>

            <section id="enhancer-pipeline">
                <h2>Enhancer Agent 7-Stage Pipeline</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Enhancer Agent transforms simple prompts into comprehensive, context-aware prompts through a 7-stage pipeline. This is important because:</p>
                <ul>
                    <li><strong>Prompt Quality</strong> - Better prompts = better agent outputs</li>
                    <li><strong>Context Enrichment</strong> - Automatically adds relevant context</li>
                    <li><strong>Expert Integration</strong> - Incorporates domain expertise</li>
                    <li><strong>Workflow Optimization</strong> - Prepares prompts for optimal execution</li>
                </ul>

                <h3>7-Stage Pipeline</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Stage</th>
                            <th>Purpose</th>
                            <th>Output</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>1. Analysis</strong></td>
                            <td>Detect prompt intent, scope, domains, workflow type</td>
                            <td>Intent analysis, domain detection, scope definition</td>
                        </tr>
                        <tr>
                            <td><strong>2. Requirements</strong></td>
                            <td>Gather functional/non-functional requirements with expert consultation</td>
                            <td>Requirements document, expert advice</td>
                        </tr>
                        <tr>
                            <td><strong>3. Architecture</strong></td>
                            <td>Provide system design guidance and patterns</td>
                            <td>Architecture recommendations, design patterns</td>
                        </tr>
                        <tr>
                            <td><strong>4. Codebase Context</strong></td>
                            <td>Inject relevant codebase context and related files</td>
                            <td>File references, code structure, dependencies</td>
                        </tr>
                        <tr>
                            <td><strong>5. Quality Standards</strong></td>
                            <td>Define security, testing, and quality thresholds</td>
                            <td>Quality gates, security requirements, test coverage</td>
                        </tr>
                        <tr>
                            <td><strong>6. Implementation Strategy</strong></td>
                            <td>Create task breakdown and implementation order</td>
                            <td>Task list, implementation plan, dependencies</td>
                        </tr>
                        <tr>
                            <td><strong>7. Synthesis</strong></td>
                            <td>Combine all stages into final enhanced prompt</td>
                            <td>Enhanced prompt (Markdown/JSON/YAML)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Pipeline Execution</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>Enhancement Process</span>
                    </div>
                    <pre><code>async function enhancePrompt(prompt, mode="full"):
    session = createSession(prompt)
    
    if mode == "full":
        // All 7 stages
        session.stages.analysis = await stageAnalysis(prompt)
        session.stages.requirements = await stageRequirements(prompt, session.stages.analysis)
        session.stages.architecture = await stageArchitecture(prompt, session.stages.requirements)
        session.stages.codebase = await stageCodebaseContext(prompt, session.stages.architecture)
        session.stages.quality = await stageQualityStandards(prompt, session.stages.codebase)
        session.stages.implementation = await stageImplementationStrategy(prompt, session.stages.quality)
        session.stages.synthesis = await stageSynthesis(session)
    elif mode == "quick":
        // Stages 1-3 only
        session.stages.analysis = await stageAnalysis(prompt)
        session.stages.requirements = await stageRequirements(prompt, session.stages.analysis)
        session.stages.architecture = await stageArchitecture(prompt, session.stages.requirements)
        session.stages.synthesis = await quickSynthesis(session)
    
    return session.stages.synthesis</code></pre>
                </div>
            </section>

            <section id="project-profiling">
                <h2>Project Profiling System</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Project Profiling System automatically detects project characteristics for context-aware expert guidance. This is important because:</p>
                <ul>
                    <li><strong>Context-Aware Advice</strong> - Experts provide advice based on project type</li>
                    <li><strong>Compliance Detection</strong> - Automatically identifies compliance requirements</li>
                    <li><strong>Security Level</strong> - Adjusts security recommendations based on project criticality</li>
                    <li><strong>Scale Awareness</strong> - Provides advice appropriate for project scale</li>
                </ul>

                <h3>Detected Characteristics</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Characteristic</th>
                            <th>Values</th>
                            <th>Detection Method</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Deployment Type</strong></td>
                            <td>local, cloud, enterprise</td>
                            <td>Infrastructure configs, deployment files</td>
                        </tr>
                        <tr>
                            <td><strong>Tenancy</strong></td>
                            <td>single-tenant, multi-tenant</td>
                            <td>Code patterns, database schema</td>
                        </tr>
                        <tr>
                            <td><strong>User Scale</strong></td>
                            <td>single-user, small-team, department, enterprise</td>
                            <td>Configuration, infrastructure setup</td>
                        </tr>
                        <tr>
                            <td><strong>Compliance</strong></td>
                            <td>GDPR, HIPAA, PCI, SOC2</td>
                            <td>Documentation, config files, code patterns</td>
                        </tr>
                        <tr>
                            <td><strong>Security Level</strong></td>
                            <td>basic, standard, high, critical</td>
                            <td>Security configs, authentication patterns</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Profile Detection Algorithm</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>Profile Detection</span>
                    </div>
                    <pre><code>function detectProjectProfile(projectRoot):
    profile = ProjectProfile()
    
    // Detect deployment type
    if exists(projectRoot / "docker-compose.yml"):
        profile.deployment_type = "cloud"
        profile.deployment_type_confidence = 0.8
    elif exists(projectRoot / "kubernetes"):
        profile.deployment_type = "enterprise"
        profile.deployment_type_confidence = 0.9
    
    // Detect compliance requirements
    if contains(projectRoot, "GDPR"):
        profile.compliance_requirements.append(
            ComplianceRequirement("GDPR", 0.9)
        )
    
    // Detect security level
    if hasAuth(projectRoot) and hasEncryption(projectRoot):
        profile.security_level = "high"
        profile.security_level_confidence = 0.85
    
    return profile</code></pre>
                </div>
            </section>

            <section id="unified-cache">
                <h2>Unified Cache Architecture</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The Unified Cache provides a single interface for all caching systems with hardware auto-detection. This is critical for:</p>
                <ul>
                    <li><strong>Simplified API</strong> - One interface for all cache types</li>
                    <li><strong>Hardware Optimization</strong> - Auto-adjusts based on available resources</li>
                    <li><strong>Performance</strong> - Optimal cache sizing for each hardware profile</li>
                    <li><strong>Adaptive Configuration</strong> - Dynamically adjusts cache settings</li>
                </ul>

                <h3>Cache Types</h3>
                <p>The unified cache manages three cache types:</p>
                <ul>
                    <li><strong>Tiered Context Cache</strong> - File context caching (Tier 1/2/3)</li>
                    <li><strong>Context7 KB Cache</strong> - Library documentation caching</li>
                    <li><strong>RAG Knowledge Base</strong> - Expert knowledge base caching</li>
                </ul>

                <h3>Hardware-Adaptive Sizing</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Hardware Profile</th>
                            <th>Max In-Memory Entries</th>
                            <th>Cache Strategy</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>NUC</td>
                            <td>50</td>
                            <td>Conservative, disk-heavy</td>
                        </tr>
                        <tr>
                            <td>Development</td>
                            <td>200</td>
                            <td>Balanced</td>
                        </tr>
                        <tr>
                            <td>Workstation</td>
                            <td>500</td>
                            <td>Aggressive, memory-heavy</td>
                        </tr>
                        <tr>
                            <td>Server</td>
                            <td>1000+</td>
                            <td>Maximum performance</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="rag-system">
                <h2>RAG System</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The RAG (Retrieval-Augmented Generation) system provides knowledge retrieval for experts. This is important for:</p>
                <ul>
                    <li><strong>Knowledge Retrieval</strong> - Fast access to expert knowledge bases</li>
                    <li><strong>Context Enrichment</strong> - Adds relevant knowledge to prompts</li>
                    <li><strong>Domain Expertise</strong> - Enables domain-specific expert responses</li>
                    <li><strong>Scalability</strong> - Handles large knowledge bases efficiently</li>
                </ul>

                <h3>RAG Types</h3>
                <p>The system supports two RAG implementations:</p>
                <ul>
                    <li><strong>Simple RAG</strong> - File-based knowledge retrieval with markdown-aware chunking</li>
                    <li><strong>Vector RAG</strong> - FAISS-based vector search with embeddings</li>
                </ul>

                <h3>RAG Chunking Strategy</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>Chunking Algorithm</span>
                    </div>
                    <pre><code>function chunkKnowledgeBase(filePath):
    content = readFile(filePath)
    
    // Markdown-aware chunking
    chunks = []
    currentChunk = ""
    
    for line in content:
        if isMarkdownHeader(line):
            // Save current chunk
            if currentChunk:
                chunks.append(currentChunk)
            currentChunk = line
        else:
            currentChunk += line
        
        // Size limit per chunk
        if len(currentChunk) > MAX_CHUNK_SIZE:
            chunks.append(currentChunk)
            currentChunk = ""
    
    return chunks</code></pre>
                </div>
            </section>

            <section id="quality-tools">
                <h2>Quality Tools Integration</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The framework integrates modern 2025 quality tools for comprehensive code analysis. This is critical for:</p>
                <ul>
                    <li><strong>Code Quality</strong> - Objective quality metrics</li>
                    <li><strong>Type Safety</strong> - Static type checking</li>
                    <li><strong>Code Duplication</strong> - Detect and reduce duplication</li>
                    <li><strong>Security</strong> - Vulnerability detection</li>
                </ul>

                <h3>Integrated Tools</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tool</th>
                            <th>Purpose</th>
                            <th>Integration</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Ruff</strong></td>
                            <td>Linting (10-100x faster than pylint)</td>
                            <td>Linting score calculation</td>
                        </tr>
                        <tr>
                            <td><strong>mypy</strong></td>
                            <td>Static type checking</td>
                            <td>Type checking score</td>
                        </tr>
                        <tr>
                            <td><strong>jscpd</strong></td>
                            <td>Code duplication detection</td>
                            <td>Duplication score</td>
                        </tr>
                        <tr>
                            <td><strong>Bandit</strong></td>
                            <td>Security vulnerability detection</td>
                            <td>Security score</td>
                        </tr>
                        <tr>
                            <td><strong>Radon</strong></td>
                            <td>Complexity and maintainability</td>
                            <td>Complexity and maintainability scores</td>
                        </tr>
                        <tr>
                            <td><strong>Coverage</strong></td>
                            <td>Test coverage analysis</td>
                            <td>Test coverage score</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="typescript-support">
                <h2>TypeScript/JavaScript Support</h2>
                
                <h3>Purpose and Importance</h3>
                <p>The framework includes TypeScript/JavaScript support for full-stack development. This is important for:</p>
                <ul>
                    <li><strong>Full-Stack Coverage</strong> - Support for both Python and TypeScript projects</li>
                    <li><strong>Type Safety</strong> - TypeScript compiler integration</li>
                    <li><strong>Linting</strong> - ESLint integration</li>
                    <li><strong>Consistency</strong> - Same quality metrics across languages</li>
                </ul>

                <h3>TypeScript Scoring</h3>
                <p>The TypeScriptScorer provides language-specific metrics:</p>
                <ul>
                    <li><strong>Complexity Score</strong> - Code complexity analysis</li>
                    <li><strong>Linting Score</strong> - ESLint results</li>
                    <li><strong>Type Checking Score</strong> - TypeScript compiler errors</li>
                    <li><strong>Maintainability Score</strong> - Code quality metrics</li>
                    <li><strong>Test Coverage Score</strong> - Test coverage analysis</li>
                </ul>
            </section>

            <section id="performance-optimization">
                <h2>Performance Optimization</h2>
                
                <h3>Key Optimizations</h3>
                <ul>
                    <li><strong>Tiered Context</strong> - 90%+ token savings</li>
                    <li><strong>Intelligent Caching</strong> - Multi-tier cache with TTL</li>
                    <li><strong>Parallel Execution</strong> - Multi-agent workflows</li>
                    <li><strong>Streaming</strong> - Real-time response streaming</li>
                    <li><strong>Hardware Profiling</strong> - Resource-aware execution</li>
                    <li><strong>Background Agent Routing</strong> - Offload heavy tasks</li>
                    <li><strong>Unified Cache</strong> - Hardware-adaptive cache sizing</li>
                </ul>

                <h3>Performance Benchmarks</h3>
                <p>Typical performance improvements:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Optimization</th>
                            <th>Improvement</th>
                            <th>Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Tiered Context</td>
                            <td>90%+ token reduction</td>
                            <td>Cost savings, faster processing</td>
                        </tr>
                        <tr>
                            <td>Context7 Caching</td>
                            <td>80%+ cache hit rate</td>
                            <td>Faster documentation access</td>
                        </tr>
                        <tr>
                            <td>Parallel Execution</td>
                            <td>3-5x speedup</td>
                            <td>Faster multi-agent workflows</td>
                        </tr>
                        <tr>
                            <td>Streaming</td>
                            <td>50%+ faster perceived response</td>
                            <td>Better UX</td>
                        </tr>
                        <tr>
                            <td>Unified Cache</td>
                            <td>30%+ cache efficiency</td>
                            <td>Better resource utilization</td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 TappsCodingAgents. MIT License.</p>
            <p>Version 2.0.1 | Last Updated: January 2026</p>
        </div>
    </footer>
</body>
</html>

