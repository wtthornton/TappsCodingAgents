# Story 10.1: Scenario Templates (Small + Medium Projects)

<!-- Source: implementation/cursor/EPIC_10_E2E_Scenario_Tests.md -->
<!-- Context: Define canonical small and medium project templates with deterministic initial state and expected outputs for scenario tests -->

## Status

Draft

## Story

**As a** QA engineer and developer,
**I want** canonical small and medium project templates with deterministic initial state and expected outputs defined for scenario tests,
**so that** scenario E2E tests have reproducible starting conditions and can validate expected outcomes consistently.

## Acceptance Criteria

1. Scenario-specific project templates are defined that extend the base templates from Story 8.1:
   - **Small scenario template**: Suitable for feature implementation and bug fix scenarios
   - **Medium scenario template**: Suitable for refactor and quality gate scenarios
   - Templates include language/tooling appropriate to this repo (Python, pytest, etc.)
2. Each scenario template provides deterministic initial state:
   - Fixed file structure and content
   - Fixed test files (with known pass/fail states)
   - Fixed configuration files (pyproject.toml, requirements.txt, etc.)
   - Seeded randomness where needed (consistent across runs)
   - No external dependencies that could vary
3. Expected outputs are defined for each scenario template:
   - Expected file changes (new files, modified files, deleted files)
   - Expected artifacts (planning, design, code, review, test artifacts)
   - Expected test outcomes (tests passing, coverage thresholds)
   - Expected quality signals (quality scores, gate states)
   - Expected report summaries (workflow completion, step summaries)
4. Scenario templates support scenario-specific customization:
   - Template can be initialized with specific "starting state" (e.g., bug present, feature missing, refactor needed)
   - Template can be configured for different scenario types (feature, bug fix, refactor)
   - Template provides hooks for scenario-specific setup
5. Expected outputs are defined as "contracts" (stable, non-brittle):
   - JSON shape validation for artifacts
   - File existence and minimal content checks
   - Test outcome validation (pass/fail counts, exit codes)
   - Quality gate state validation (gate ID, outcome)
   - Avoid free-form text matching
6. Scenario templates integrate with E2E foundation:
   - Use E2E harness project templates as base
   - Use E2E artifact capture utilities
   - Use E2E correlation IDs
   - Follow E2E conventions (isolation, cleanup)
7. Scenario templates are documented with:
   - Template structure and contents
   - How to create a scenario template instance
   - How to customize for specific scenarios
   - Expected outputs reference
8. Unit tests exist for scenario template creation and expected output validation.

## Tasks / Subtasks

- [ ] Task 1: Design small scenario template (AC: 1, 2)
  - [ ] Define structure for feature implementation scenario:
    - [ ] Initial project state (existing code, tests)
    - [ ] Feature request/requirement definition
    - [ ] Expected new files/modifications
  - [ ] Define structure for bug fix scenario:
    - [ ] Initial project state with bug present
    - [ ] Bug description/reproduction steps
    - [ ] Expected fix files/modifications
  - [ ] Create template creation utilities in `tests/e2e/fixtures/scenario_templates.py`
  - [ ] Ensure templates are deterministic (fixed content, seeded randomness)

- [ ] Task 2: Design medium scenario template (AC: 1, 2)
  - [ ] Define structure for refactor scenario:
    - [ ] Initial project state (legacy code, multiple files)
    - [ ] Refactor requirements/scope
    - [ ] Expected refactored structure
  - [ ] Define structure for quality gate scenario:
    - [ ] Initial project state (code quality issues)
    - [ ] Quality requirements (coverage, linting, etc.)
    - [ ] Expected quality improvements
  - [ ] Extend template creation utilities
  - [ ] Ensure templates are deterministic

- [ ] Task 3: Define expected outputs for small scenarios (AC: 3, 5)
  - [ ] Define expected outputs for feature implementation:
    - [ ] Expected file changes (new feature files, modified tests)
    - [ ] Expected artifacts (planning, design, code artifacts)
    - [ ] Expected test outcomes (new tests passing)
    - [ ] Expected quality signals (quality scores)
  - [ ] Define expected outputs for bug fix:
    - [ ] Expected file changes (bug fix files, test updates)
    - [ ] Expected artifacts (bug analysis, fix artifacts)
    - [ ] Expected test outcomes (bug reproduction test, fix verification)
    - [ ] Expected quality signals (quality maintained/improved)
  - [ ] Define outputs as contracts (JSON shape, file existence, test outcomes)

- [ ] Task 4: Define expected outputs for medium scenarios (AC: 3, 5)
  - [ ] Define expected outputs for refactor:
    - [ ] Expected file changes (refactored files, structure changes)
    - [ ] Expected artifacts (refactor plan, refactored code)
    - [ ] Expected test outcomes (all tests still passing)
    - [ ] Expected quality signals (maintained/improved quality)
  - [ ] Define expected outputs for quality gate:
    - [ ] Expected file changes (quality improvements)
    - [ ] Expected artifacts (quality reports, improvement artifacts)
    - [ ] Expected test outcomes (coverage thresholds met)
    - [ ] Expected quality signals (gate states, quality scores)
  - [ ] Define outputs as contracts

- [ ] Task 5: Implement scenario template creation utilities (AC: 1, 2, 4)
  - [ ] Create `tests/e2e/fixtures/scenario_templates.py`
  - [ ] Implement `create_small_scenario_template(project_path, scenario_type, **kwargs)`
  - [ ] Implement `create_medium_scenario_template(project_path, scenario_type, **kwargs)`
  - [ ] Support scenario-specific customization (starting state, configuration)
  - [ ] Support hooks for scenario-specific setup
  - [ ] Integrate with base project templates from Story 8.1

- [ ] Task 6: Implement expected output validation utilities (AC: 3, 5)
  - [ ] Create `tests/e2e/fixtures/scenario_validators.py`
  - [ ] Implement `validate_scenario_outputs(project_path, expected_outputs)`
  - [ ] Implement file change validation (existence, content checks)
  - [ ] Implement artifact validation (JSON shape, required keys)
  - [ ] Implement test outcome validation (pass/fail counts, exit codes)
  - [ ] Implement quality signal validation (gate states, scores)
  - [ ] Provide clear validation error messages

- [ ] Task 7: Integrate with E2E foundation (AC: 6)
  - [ ] Use E2E harness project templates as base
  - [ ] Use E2E artifact capture utilities
  - [ ] Use E2E correlation IDs
  - [ ] Follow E2E conventions (isolation, cleanup, timeouts)
  - [ ] Integrate with E2E fixtures in `tests/e2e/conftest.py`

- [ ] Task 8: Documentation and unit tests (AC: 7, 8)
  - [ ] Document scenario templates in `tests/e2e/scenarios/README.md`
  - [ ] Document template structure and contents
  - [ ] Document how to create and customize scenario templates
  - [ ] Document expected outputs reference
  - [ ] Create unit tests in `tests/unit/e2e/test_scenario_templates.py`
  - [ ] Test template creation (small and medium)
  - [ ] Test expected output validation
  - [ ] Test scenario-specific customization

## Dev Notes

### Existing System Context

- E2E foundation (from Epic 8):
  - `tests/e2e/fixtures/project_templates.py` - base project templates (minimal, small, medium)
  - `tests/e2e/fixtures/e2e_harness.py` - E2E harness utilities
  - `tests/e2e/conftest.py` - E2E fixtures
- Workflow system:
  - `tapps_agents/workflow/executor.py` - workflow execution
  - `tapps_agents/workflow/models.py` - artifact models
- Quality gates:
  - `tapps_agents/quality/quality_gates.py` - quality gate evaluation
  - Quality scoring and gate decisions
- Artifact system:
  - Artifacts created under `.tapps-agents/` and project root
  - Artifact types: planning, design, code, review, test, quality

### Integration Approach

- Extend base project templates from Story 8.1
- Build scenario-specific templates on top of base templates
- Reuse E2E harness utilities for project setup and artifact capture
- Integrate with workflow runner from Epic 9 for scenario execution
- Follow existing patterns for deterministic test setup

### Technology Research

- Use `pytest` fixtures for template creation
- Use `pathlib.Path` for filesystem operations
- Use `json` for expected output contracts
- Use `yaml` for scenario configuration (if needed)
- Use `pytest` assertions for output validation

### Risk Assessment

- **Primary risk**: Scenario templates become too complex or brittle
- **Mitigation**: Keep templates focused and well-documented; use contracts for validation
- **Rollback plan**: Scenario templates are additive; can be simplified or removed without affecting other tests

### Testing

- Test file location: `tests/unit/e2e/test_scenario_templates.py`
- Test standards: Use `pytest`, follow existing unit test patterns
- Testing frameworks: `pytest`
- Specific requirements:
  - Test template creation (small and medium, all scenario types)
  - Test expected output validation
  - Test scenario-specific customization
  - Test deterministic behavior (run twice, compare results)

## Change Log

| Date       | Version | Description                       | Author      |
| ---------- | ------- | --------------------------------- | ----------- |
| 2025-01-XX | 0.1     | Initial draft for Epic 10.1       | bmad-master |

## Dev Agent Record

### Agent Model Used

_TBD_

### Debug Log References

_TBD_

### Completion Notes List

_TBD_

### File List

_TBD_

## QA Results

_TBD_
