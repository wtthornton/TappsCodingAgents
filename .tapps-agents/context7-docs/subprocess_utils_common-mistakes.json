{
  "library": "subprocess_utils",
  "topic": "common-mistakes",
  "documentation": {
    "content": "## Format and Lint Code with Ruff\n\n```bash\nuv run ruff check . --fix\nuv run ruff format .\n```\n\n## Format and Lint Code with Ruff\n\n```bash\nuv run ruff check . --fix\nuv run ruff format .\n```\n\n## Main function for demonstrating batch reading (Python)\n\n```Python\ndef main():\n    temp_dir = tempfile.mkdtemp()\n    print(f\"Created temporary directory: {temp_dir}\")\n    try:\n        create_sample_data(temp_dir)\n        demonstrate_parquet_batch_reading(temp_dir)\n        demonstrate_csv_batch_reading(temp_dir)\n        demonstrate_json_batch_reading(temp_dir)\n    finally:\n        shutil.rmtree(temp_dir)\n        print(f\"\\nCleaned up temporary directory: {temp_dir}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Handle 404 Page Navigation\n\n```javascript\nvar target = document.getElementById(location.hash.slice(1));\ntarget && target.name && (target.checked = target.name.startsWith(\"__tabbed_\"));\n```\n\n## Process and Display Cross-References with Tippy.js\n\n```javascript\nconst xrefs = window.document.querySelectorAll('a.quarto-xref');\n\nconst processXRef = (id, note) => {\n  // Strip column container classes\n  const stripColumnClz = (el) => {\n    el.classList.remove(\"page-full\", \"page-columns\");\n    if (el.children) {\n      for (const child of el.children) {\n        stripColumnClz(child);\n      }\n    }\n  }\n  stripColumnClz(note)\n\n  if (id === null || id.startsWith('sec-')) {\n    // Special case sections, only their first couple elements\n    const container = document.createElement(\"div\");\n    if (note.children && note.children.length > 2) {\n      container.appendChild(note.children[0].cloneNode(true));\n      for (let i = 1; i < note.children.length; i++) {\n        const child = note.children[i];\n        if (child.tagName === \"P\" && child.innerText === \"\") {\n          continue;\n        } else {\n          container.appendChild(child.cloneNode(true));\n          break;\n        }\n      }\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(container);\n      }\n      return container.innerHTML\n    } else {\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(note);\n      }\n      return note.innerHTML;\n    }\n  } else {\n    // Remove any anchor links if they are present\n    const anchorLink = note.querySelector('a.anchorjs-link');\n    if (anchorLink) {\n      anchorLink.remove();\n    }\n    if (window.Quarto?.typesetMath) {\n      window.Quarto.typesetMath(note);\n    }\n    if (note.classList.contains(\"callout\")) {\n      return note.outerHTML;\n    } else {\n      return note.innerHTML;\n    }\n  }\n}\n\nfor (var i=0; i<xrefs.length; i++) {\n  const xref = xrefs[i];\n  tippyHover(xref, undefined, function(instance) {\n    instance.disable();\n    let url = xref.getAttribute('href');\n    let hash = undefined;\n    if (url.startsWith('#')) {\n      hash = url;\n    } else {\n      try {\n        hash = new URL(url).hash;\n      } catch {}\n    }\n\n    if (hash) {\n      const id = hash.replace(/^#\\/?/, \"\");\n      const note = window.document.getElementById(id);\n      if (note !== null) {\n        try {\n          const html = processXRef(id, note.cloneNode(true));\n          instance.setContent(html);\n        } finally {\n          instance.enable();\n          instance.show();\n        }\n      } else {\n        // See if we can fetch this\n        fetch(url.split('#')[0])\n          .then(res => res.text())\n          .then(html => {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.getElementById(id);\n            if (note !== null) {\n              const html = processXRef(id, note);\n              instance.setContent(html);\n            }\n          }).finally(() => {\n            instance.enable();\n            instance.show();\n          });\n      }\n    } else {\n      // See if we can fetch a full url (with no hash to target)\n      // This is a special case and we should probably do some content thinning / targeting\n      fetch(url)\n        .then(res => res.text())\n        .then(html => {\n          const parser = new DOMParser();\n          const htmlDoc = parser.parseFromString(html, \"text/html\");\n          const note = htmlDoc.querySelector('main.content');\n          if (note !== null) {\n            // This should only happen for chapter cross references\n            // (since there is no id in the URL)\n            // remove the first header if it exists\n            if (note.children.length > 0 && note.children[0].tagName === \"HEADER\") {\n              note.children[0].remove();\n            }\n            const html = processXRef(null, note);\n            instance.setContent(html);\n          }\n        }).finally(() => {\n          instance.enable();\n          instance.show();\n        });\n    }\n  }, function(instance) {\n    // onUntrigger\n  });\n}\n```\n\n## Main Execution with fsspec-utils\n\n```Python\ndef main():\n    temp_dir = tempfile.mkdtemp()\n    print(f\"Created temporary directory: {temp_dir}\")\n    try:\n        create_sample_data(temp_dir)\n        parquet_table = demonstrate_parquet_reading(temp_dir)\n        csv_table = demonstrate_csv_reading(temp_dir)\n        json_table = demonstrate_json_reading(temp_dir)\n\n        print(\"\\n=== Verification ===\")\n        print(f\"All tables have the same number of rows: {parquet_table.num_rows == csv_table.num_rows == json_table.num_rows}\")\n    finally:\n        shutil.rmtree(temp_dir)\n        print(f\"\\nCleaned up temporary directory: {temp_dir}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Format and Lint Code with Ruff\n\n```bash\nuv run ruff check . --fix\nuv run ruff format .\n```\n\n## External Link Handling\n\n```javascript\nvar localhostRegex = new RegExp(/^(?:http|https):\\/\\/localhost\\:?[0-9]*\\//);\nvar mailtoRegex = new RegExp(/^mailto:/);\nvar filterRegex = new RegExp('/' + window.location.host + '/');\n\nvar isInternal = (href) => {\n    return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);\n}\n\nvar links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');\nfor (var i=0; i<links.length; i++) {\n    const link = links[i];\n    if (!isInternal(link.href)) {\n        if (link.dataset.originalHref !== undefined) {\n            link.href = link.dataset.originalHref;\n        }\n    }\n}\n```\n\n## JavaScript: Cross-Reference Processing\n\n```JavaScript\nconst xrefs = window.document.querySelectorAll('a.quarto-xref');\nconst processXRef = (id, note) => {\n  // Strip column container classes\n  const stripColumnClz = (el) => {\n    el.classList.remove(\"page-full\", \"page-columns\");\n    if (el.children) {\n      for (const child of el.children) {\n        stripColumnClz(child);\n      }\n    }\n  }\n  stripColumnClz(note)\n  if (id === null || id.startsWith('sec-')) {\n    // Special case sections, only their first couple elements\n    const container = document.createElement(\"div\");\n    if (note.children && note.children.length > 2) {\n      container.appendChild(note.children[0]);\n      container.appendChild(note.children[1]);\n    }\n    return container.innerHTML;\n  }\n  return note.innerHTML;\n}\n```\n\n## Process and Display Cross-References with Tippy.js\n\n```javascript\nconst xrefs = window.document.querySelectorAll('a.quarto-xref');\nconst processXRef = (id, note) => {\n  // Strip column container classes\n  const stripColumnClz = (el) => {\n    el.classList.remove(\"page-full\", \"page-columns\");\n    if (el.children) {\n      for (const child of el.children) {\n        stripColumnClz(child);\n      }\n    }\n  }\n  stripColumnClz(note)\n  if (id === null || id.startsWith('sec-')) {\n    // Special case sections, only their first couple elements\n    const container = document.createElement(\"div\");\n    if (note.children && note.children.length > 2) {\n      container.appendChild(note.children[0].cloneNode(true));\n      for (let i = 1; i < note.children.length; i++) {\n        const child = note.children[i];\n        if (child.tagName === \"P\" && child.innerText === \"\") {\n          continue;\n        } else {\n          container.appendChild(child.cloneNode(true));\n          break;\n        }\n      }\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(container);\n      }\n      return container.innerHTML\n    } else {\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(note);\n      }\n      return note.innerHTML;\n    }\n  } else {\n    // Remove any anchor links if they are present\n    const anchorLink = note.querySelector('a.anchorjs-link');\n    if (anchorLink) {\n      anchorLink.remove();\n    }\n    if (window.Quarto?.typesetMath) {\n      window.Quarto.typesetMath(note);\n    }\n    if (note.classList.contains(\"callout\")) {\n      return note.outerHTML;\n    } else {\n      return note.innerHTML;\n    }\n  }\n}\n\nfor (var i=0; i<xrefs.length; i++) {\n  const xref = xrefs[i];\n  tippyHover(xref, undefined, function(instance) {\n    instance.disable();\n    let url = xref.getAttribute('href');\n    let hash = undefined;\n    if (url.startsWith('#')) {\n      hash = url;\n    } else {\n      try {\n        hash = new URL(url).hash;\n      } catch {}\n    }\n    if (hash) {\n      const id = hash.replace(/^#\\/?/, \"\");\n      const note = window.document.getElementById(id);\n      if (note !== null) {\n        try {\n          const html = processXRef(id, note.cloneNode(true));\n          instance.setContent(html);\n        } finally {\n          instance.enable();\n          instance.show();\n        }\n      } else {\n        // See if we can fetch this\n        fetch(url.split('#')[0])\n          .then(res => res.text())\n          .then(html => {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.getElementById(id);\n            if (note !== null) {\n              const html = processXRef(id, note);\n              instance.setContent(html);\n            }\n          }).finally(() => {\n            instance.enable();\n            instance.show();\n          });\n      }\n    } else {\n      // See if we can fetch a full url (with no hash to target)\n      // This is a special case and we should probably do some content thinning / targeting\n      fetch(url)\n        .then(res => res.text())\n        .then(html => {\n          const parser = new DOMParser();\n          const htmlDoc = parser.parseFromString(html, \"text/html\");\n          const note = htmlDoc.querySelector('main.content');\n          if (note !== null) {\n            // This should only happen for chapter cross references\n            // (since there is no id in the URL)\n            // remove the first header if (note.children.length > 0 && note.children[0].tagName === \"HEADER\") {\n            note.children[0].remove();\n            }\n            const html = processXRef(null, note);\n            instance.setContent(html);\n          }\n        }).finally(() => {\n          instance.enable();\n          instance.show();\n        });\n    }\n  }, function(instance) {\n  });\n}\n```",
    "library": "file_utils",
    "topic": "common-mistakes",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:27:39.302453"
}