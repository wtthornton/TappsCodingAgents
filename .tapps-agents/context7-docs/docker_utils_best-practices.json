{
  "library": "docker_utils",
  "topic": "best-practices",
  "documentation": {
    "content": "## Socket.IO Client Configuration Example\n\n```javascript\nconst socket = io({\n    reconnectionDelayMax: 10000,\n    auth: { token: \"123\" },\n    query: {\n        \"my-key\": \"my-value\"\n    }\n});\n```\n\n## Go Socket.IO Server with Gin and WebTransport\n\n```Go\npackage main\n\nimport (\n    \"net/http\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n\n    \"github.com/gin-gonic/gin\"\n    \"github.com/zishang520/engine.io/v2/engine\"\n    \"github.com/zishang520/engine.io/v2/log\"\n    \"github.com/zishang520/engine.io/v2/types\"\n    \"github.com/zishang520/engine.io/v2/webtransport\"\n    \"github.com/zishang520/socket.io/v2/socket\"\n)\n\nfunc main() {\n    log.DEBUG = true\n    c := socket.DefaultServerOptions()\n    c.SetServeClient(true)\n    c.SetPingInterval(300 * time.Millisecond)\n    c.SetPingTimeout(200 * time.Millisecond)\n    c.SetMaxHttpBufferSize(1000000)\n    c.SetConnectTimeout(1000 * time.Millisecond)\n    c.SetTransports(types.NewSet(\"polling\", \"webtransport\"))\n    c.SetCors(&types.Cors{\n        Origin:      \"*\",\n        Credentials: true,\n    })\n    socketio := socket.NewServer(nil, nil)\n    socketio.On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n\n        client.On(\"message\", func(args ...interface{}) {\n            client.Emit(\"message-back\", args...)\n        })\n        client.Emit(\"auth\", client.Handshake().Auth)\n\n        client.On(\"message-with-ack\", func(args ...interface{}) {\n            ack := args[len(args)-1].(socket.Ack)\n            ack(args[:len(args)-1], nil)\n        })\n    })\n\n    socketio.Of(\"/custom\", nil).On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n        client.Emit(\"auth\", client.Handshake().Auth)\n    })\n\n    app := gin.Default()\n\n    app.POST(\"/socket.io/*f\", gin.WrapH(socketio.ServeHandler(c)))\n    app.GET(\"/socket.io/*f\", gin.WrapH(socketio.ServeHandler(c)))\n    go app.Run(\":8080\")\n\n    // WebTransport start\n    customServer := types.NewWebServer(nil)\n    // A certificate is required and cannot be a self-signed certificate.\n    wts := customServer.ListenWebTransportTLS(\":443\", \"domain.cer\", \"domain.key\", nil, nil)\n\n    customServer.HandleFunc(socketio.Path()+\"/\", func(w http.ResponseWriter, r *http.Request) {\n        if webtransport.IsWebTransportUpgrade(r) {\n            socketio.Engine().(engine.Server).OnWebTransportSession(types.NewHttpContext(w, r), wts)\n        } else {\n            customServer.DefaultHandler.ServeHTTP(w, r)\n        }\n    })\n    // WebTransport end\n\n    exit := make(chan struct{})\n    SignalC := make(chan os.Signal)\n\n    signal.Notify(SignalC, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n    go func() {\n        for s := range SignalC {\n            switch s {\n            case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:\n                close(exit)\n                return\n            }\n        }\n    }()\n\n    <-exit\n    socketio.Close(nil)\n    os.Exit(0)\n}\n\n```\n\n## Use Socket.IO with Fiber\n\n```go\npackage main\n\nimport (\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n\n    \"github.com/gofiber/fiber/v2\"\n    \"github.com/gofiber/fiber/v2/middleware/adaptor\"\n    \"github.com/zishang520/engine.io/v2/log\"\n    \"github.com/zishang520/engine.io/v2/types\"\n    \"github.com/zishang520/socket.io/v2/socket\"\n)\n\nfunc main() {\n    log.DEBUG = true\n    c := socket.DefaultServerOptions()\n    c.SetServeClient(true)\n    // c.SetConnectionStateRecovery(&socket.ConnectionStateRecovery{})\n    // c.SetAllowEIO3(true)\n    c.SetPingInterval(300 * time.Millisecond)\n    c.SetPingTimeout(200 * time.Millisecond)\n    // The following options are not directly available in the provided snippet but are common for socket.io\n    // c.SetMaxHttpBufferSize(1000000)\n    // c.SetConnectTimeout(1000 * time.Millisecond)\n    // c.SetCors(&types.Cors{\n    //     Origin:      \"*\",\n    //     Credentials: true,\n    // })\n\n    socketio := socket.NewServer(nil, nil)\n    socketio.On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n\n        client.On(\"message\", func(args ...interface{}) {\n            client.Emit(\"message-back\", args...)\n        })\n        client.Emit(\"auth\", client.Handshake().Auth)\n\n        client.On(\"message-with-ack\", func(args ...interface{}) {\n            ack := args[len(args)-1].(socket.Ack)\n            ack(args[:len(args)-1], nil)\n        })\n    })\n\n    socketio.Of(\"/custom\", nil).On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n        client.Emit(\"auth\", client.Handshake().Auth)\n    })\n\n    app := fiber.New()\n    app.Use(adaptor.HTTPAdapter(socketio.ServeHandler(c)))\n\n    go func() {\n        if err := app.Listen(\":3000\"); err != nil {\n            panic(err)\n        }\n    }()\n\n    exit := make(chan struct{})\n    SignalC := make(chan os.Signal)\n\n    signal.Notify(SignalC, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n    go func() {\n        for s := range SignalC {\n            switch s {\n            case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:\n                close(exit)\n                return\n            }\n        }\n    }()\n\n    <-exit\n    socketio.Close(nil)\n    os.Exit(0)\n}\n```\n\n## Golang Socket.IO Connection and Event Handling\n\n```go\nimport (\n    \"github.com/zishang520/socket.io/v2/socket\"\n)\n\nio.On(\"connection\", func(clients ...any) {\n    client := clients[0].(*socket.Socket)\n    client.Emit(\"request\" /* \u2026 */)                       // emit an event to the socket\n    io.Emit(\"broadcast\" /* \u2026 */)                         // emit an event to all connected sockets\n    client.On(\"reply\", func(...any) { /* \u2026 */ }) // listen to the event\n})\n```\n\n## Use Socket.IO with net/http Handler\n\n```go\npackage main\n\nimport (\n    \"net/http\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n\n    \"github.com/zishang520/socket.io/v2/socket\"\n)\n\nfunc main() {\n    io := socket.NewServer(nil, nil)\n    http.Handle(\"/socket.io/\", io.ServeHandler(nil))\n    go http.ListenAndServe(\":3000\", nil)\n\n    io.On(\"connection\", func(clients ...any) {\n        client := clients[0].(*socket.Socket)\n        client.On(\"event\", func(datas ...any) {\n        })\n        client.On(\"disconnect\", func(...any) {\n        })\n    })\n\n    exit := make(chan struct{})\n    SignalC := make(chan os.Signal)\n\n    signal.Notify(SignalC, os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n    go func() {\n        for s := range SignalC {\n            switch s {\n            case os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:\n                close(exit)\n                return\n            }\n        }\n    }()\n\n    <-exit\n    io.Close(nil)\n    os.Exit(0)\n}\n```\n\n## Running Project Tests\n\n```shell\nmake test\n```\n\n## Go Socket.IO Server with Fiber\n\n```Go\npackage main\n\nimport (\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n\n    \"github.com/gofiber/fiber/v2\"\n    \"github.com/gofiber/fiber/v2/middleware/adaptor\"\n    \"github.com/zishang520/engine.io/v2/types\"\n    \"github.com/zishang520/socket.io/v2/socket\"\n)\n\nfunc main() {\n    c := socket.DefaultServerOptions()\n    c.SetMaxHttpBufferSize(1000000)\n    c.SetConnectTimeout(1000 * time.Millisecond)\n    c.SetCors(&types.Cors{\n        Origin:      \"*\",\n        Credentials: true,\n    })\n    socketio := socket.NewServer(nil, nil)\n    socketio.On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n\n        client.On(\"message\", func(args ...interface{}) {\n            client.Emit(\"message-back\", args...)\n        })\n        client.Emit(\"auth\", client.Handshake().Auth)\n\n        client.On(\"message-with-ack\", func(args ...interface{}) {\n            ack := args[len(args)-1].(socket.Ack)\n            ack(args[:len(args)-1], nil)\n        })\n    })\n\n    socketio.Of(\"/custom\", nil).On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n        client.Emit(\"auth\", client.Handshake().Auth)\n    })\n\n    app := fiber.New()\n\n    app.Get(\"/socket.io\", adaptor.HTTPHandler(socketio.ServeHandler(c)))\n    app.Post(\"/socket.io\", adaptor.HTTPHandler(socketio.ServeHandler(c)))\n\n    go app.Listen(\":3000\")\n\n    exit := make(chan struct{})\n    SignalC := make(chan os.Signal)\n\n    signal.Notify(SignalC, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n    go func() {\n        for s := range SignalC {\n            switch s {\n            case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:\n                close(exit)\n                return\n            }\n        }\n    }()\n\n    <-exit\n    socketio.Close(nil)\n    os.Exit(0)\n}\n\n```\n\n## Use Socket.IO with fasthttp\n\n```go\npackage main\n\nimport (\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n\n    \"github.com/valyala/fasthttp\"\n    \"github.com/valyala/fasthttp/fasthttpadaptor\"\n    \"github.com/zishang520/engine.io/v2/log\"\n    \"github.com/zishang520/engine.io/v2/types\"\n    \"github.com/zishang520/socket.io/v2/socket\"\n)\n\nfunc main() {\n    log.DEBUG = true\n    c := socket.DefaultServerOptions()\n    c.SetServeClient(true)\n    // c.SetConnectionStateRecovery(&socket.ConnectionStateRecovery{})\n    // c.SetAllowEIO3(true)\n    c.SetPingInterval(300 * time.Millisecond)\n    c.SetPingTimeout(200 * time.Millisecond)\n    c.SetMaxHttpBufferSize(1000000)\n    c.SetConnectTimeout(1000 * time.Millisecond)\n    c.SetCors(&types.Cors{\n        Origin:      \"*\",\n        Credentials: true,\n    })\n    socketio := socket.NewServer(nil, nil)\n    socketio.On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n\n        client.On(\"message\", func(args ...interface{}) {\n            client.Emit(\"message-back\", args...)\n        })\n        client.Emit(\"auth\", client.Handshake().Auth)\n\n        client.On(\"message-with-ack\", func(args ...interface{}) {\n            ack := args[len(args)-1].(socket.Ack)\n            ack(args[:len(args)-1], nil)\n        })\n    })\n\n    socketio.Of(\"/custom\", nil).On(\"connection\", func(clients ...interface{}) {\n        client := clients[0].(*socket.Socket)\n        client.Emit(\"auth\", client.Handshake().Auth)\n    })\n\n    go fasthttp.ListenAndServe(\":3000\", fasthttpadaptor.NewFastHTTPHandler(socketio.ServeHandler(c)))\n\n    exit := make(chan struct{})\n    SignalC := make(chan os.Signal)\n\n    signal.Notify(SignalC, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n    go func() {\n        for s := range SignalC {\n            switch s {\n            case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:\n                close(exit)\n                return\n            }\n        }\n    }()\n\n    <-exit\n    socketio.Close(nil)\n    os.Exit(0)\n}\n```\n\n## Attach Socket.IO to Engine.IO Server\n\n```go\npackage main\n\nimport (\n    \"github.com/zishang520/engine.io/v2/types\"\n    \"github.com/zishang520/socket.io/v2/socket\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n)\n\nfunc main() {\n    httpServer := types.CreateServer(nil)\n    io := socket.NewServer(httpServer, nil)\n    io.On(\"connection\", func(clients ...any) {\n        client := clients[0].(*socket.Socket)\n        client.On(\"event\", func(datas ...any) {\n        })\n        client.On(\"disconnect\", func(...any) {\n        })\n    })\n    httpServer.Listen(\"127.0.0.1:3000\", nil)\n\n    exit := make(chan struct{})\n    SignalC := make(chan os.Signal)\n\n    signal.Notify(SignalC, os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n    go func() {\n        for s := range SignalC {\n            switch s {\n            case os.Interrupt, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:\n                close(exit)\n                return\n            }\n        }\n    }()\n\n    <-exit\n    httpServer.Close(nil)\n    os.Exit(0)\n}\n```\n\n## JavaScript Socket.IO Client with WebTransport\n\n```JavaScript\nconst manager = new io.Manager(\"https://domain\", {\n    transports: ['webtransport'],\n});\n\nconst socket = manager.socket(\"/\", {\n});\n\n```",
    "library": "socket",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:32:01.549861"
}