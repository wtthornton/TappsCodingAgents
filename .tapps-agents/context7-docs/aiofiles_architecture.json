{
  "library": "aiofiles",
  "topic": "architecture",
  "documentation": {
    "content": "## Async Standard Streams with aiofiles (Python)\n\n```python\nimport asyncio\nimport aiofiles\n\nasync def console_operations():\n    # Writing to stdout asynchronously\n    await aiofiles.stdout.write(\"Enter your name: \")\n    await aiofiles.stdout.flush()\n\n    # Reading from stdin asynchronously\n    name = await aiofiles.stdin.readline()\n    await aiofiles.stdout.write(f\"Hello, {name}\")\n\n    # Writing to stderr\n    await aiofiles.stderr.write(\"This is an error message\\n\")\n\n    # Binary streams\n    await aiofiles.stdout_bytes.write(b\"Binary output\\n\")\n    binary_input = await aiofiles.stdin_bytes.read(10)\n\nasyncio.run(console_operations())\n```\n\n## Asynchronous Named Temporary File Operations with aiofiles\n\n```python\nimport aiofiles\nimport os\nimport asyncio\n\nasync def named_tempfile_example():\n    async with aiofiles.tempfile.NamedTemporaryFile('wb+') as f:\n        await f.write(b'Line1\\nLine2')\n        await f.seek(0)\n        async for line in f:\n            print(line.decode().strip())\n        # The file is automatically deleted when exiting the 'async with' block\n        print(f\"File path: {f.name}\")\n\n# asyncio.run(named_tempfile_example())\n\n```\n\n## Asynchronous Temporary File Creation and Writing with aiofiles\n\n```python\nimport aiofiles\n\nasync def write_to_tempfile():\n    async with aiofiles.tempfile.TemporaryFile('wb') as f:\n        await f.write(b'Hello, World!')\n        await f.seek(0) # Rewind to read\n        content = await f.read()\n        print(content)\n\n# Example usage:\n# import asyncio\n# asyncio.run(write_to_tempfile())\n```\n\n## Create and Use TemporaryDirectory with aiofiles\n\n```Python\nimport asyncio\nimport os\nimport aiofiles.tempfile\nimport aiofiles\n\nasync def temporary_directories():\n    # Create temporary directory\n    async with aiofiles.tempfile.TemporaryDirectory() as tmpdir:\n        print(f\"Temp directory created: {tmpdir}\")\n\n        # Use the directory\n        temp_file = os.path.join(tmpdir, 'data.txt')\n        async with aiofiles.open(temp_file, 'w') as f:\n            await f.write('Data in temporary directory\\n')\n\n        # Create subdirectories\n        subdir = os.path.join(tmpdir, 'subdir')\n        os.makedirs(subdir)\n\n        # Verify directory exists\n        assert os.path.exists(tmpdir)\n        assert os.path.isdir(tmpdir)\n\n    # Directory and all contents automatically deleted\n    print(f\"Directory exists after close: {os.path.exists(tmpdir)}\")\n\n    # Custom prefix, suffix, and location\n    async with aiofiles.tempfile.TemporaryDirectory(\n        prefix='myapp_', suffix='_tmp', dir='/tmp'\n    ) as tmpdir:\n        print(f\"Custom temp directory: {tmpdir}\")\n        # Use directory for temporary work\n        work_file = os.path.join(tmpdir, 'work.dat')\n        async with aiofiles.open(work_file, 'wb') as f:\n            await f.write(b'Temporary work data')\n\nasyncio.run(temporary_directories())\n```\n\n## Concurrent File Operations with aiofiles and asyncio\n\n```python\nimport asyncio\nimport aiofiles\n\nasync def read_file(filename):\n    async with aiofiles.open(filename, mode='r') as f:\n        content = await f.read()\n        return filename, len(content)\n\nasync def write_file(filename, content):\n    async with aiofiles.open(filename, mode='w') as f:\n        await f.write(content)\n        return filename\n\nasync def concurrent_operations():\n    # Read multiple files concurrently\n    files_to_read = ['file1.txt', 'file2.txt', 'file3.txt']\n    results = await asyncio.gather(\n        *[read_file(f) for f in files_to_read],\n        return_exceptions=True\n    )\n    for filename, size in results:\n        print(f\"{filename}: {size} bytes\")\n\n    # Write multiple files concurrently\n    write_tasks = [\n        write_file('output1.txt', 'Content 1\\n'),\n        write_file('output2.txt', 'Content 2\\n'),\n        write_file('output3.txt', 'Content 3\\n'),\n    ]\n    await asyncio.gather(*write_tasks)\n\n    # Mix different operations\n    mixed_operations = [\n        aiofiles.os.stat('file1.txt'),\n        aiofiles.os.path.exists('file2.txt'),\n        aiofiles.os.path.getsize('file3.txt'),\n    ]\n    stat_result, exists, size = await asyncio.gather(*mixed_operations)\n    print(f\"Stat: {stat_result.st_size}, Exists: {exists}, Size: {size}\")\n\nasyncio.run(concurrent_operations())\n\n```\n\n## Async File Server Example with aiofiles\n\n```python\nimport asyncio\nimport aiofiles\n\nasync def serve_file(reader, writer):\n    \"\"\"Serve a file to a client connection.\"\"\"\n    try:\n        # Read filename request from client\n        filename_bytes = await reader.readline()\n        filename = filename_bytes.decode().strip()\n\n        # Open and read file asynchronously\n        async with aiofiles.open(filename, mode='rb') as f:\n            while True:\n                chunk = await f.read(8192)\n                if not chunk:\n                    break\n                writer.write(chunk)\n                await writer.drain()\n\n        print(f\"Served file: {filename}\")\n    except FileNotFoundError:\n        writer.write(b\"ERROR: File not found\\n\")\n    except Exception as e:\n        writer.write(f\"ERROR: {str(e)}\\n\".encode())\n    finally:\n        writer.close()\n        await writer.wait_closed()\n\nasync def file_server(host='localhost', port=8888):\n    \"\"\"Start an async file server.\"\"\"\n    server = await asyncio.start_server(serve_file, host, port)\n    addr = server.sockets[0].getsockname()\n    print(f\"File server running on {addr}\")\n\n    async with server:\n        await server.serve_forever()\n\n# Run server\n# asyncio.run(file_server())\n\n# Client example\nasync def download_file(host, port, remote_file, local_file):\n    \"\"\"Download a file from the file server.\"\"\"\n    reader, writer = await asyncio.open_connection(host, port)\n\n    # Request file\n    writer.write(f\"{remote_file}\\n\".encode())\n    await writer.drain()\n\n    # Receive and save file\n    async with aiofiles.open(local_file, mode='wb') as f:\n        while True:\n            chunk = await reader.read(8192)\n            if not chunk:\n                break\n            await f.write(chunk)\n\n    writer.close()\n    await writer.wait_closed()\n    print(f\"Downloaded {remote_file} to {local_file}\")\n\n# asyncio.run(download_file('localhost', 8888, 'example.txt', 'downloaded.txt'))\n\n```\n\n## Asynchronous Temporary Directory Creation with aiofiles\n\n```python\nimport aiofiles.tempfile\nimport os\nimport asyncio\n\nasync def temporary_directory_example():\n    async with aiofiles.tempfile.TemporaryDirectory() as d:\n        print(f'Created temporary directory: {d}')\n        filename = os.path.join(d, \"file.ext\")\n        async with aiofiles.open(filename, 'w') as temp_f:\n            await temp_f.write('This is a test file.')\n        # Directory and its contents are automatically removed here\n\n# asyncio.run(temporary_directory_example())\n\n```\n\n## Create and Use SpooledTemporaryFile with aiofiles\n\n```Python\nimport asyncio\nimport aiofiles.tempfile\n\nasync def spooled_temporary_files():\n    # File stays in memory until it exceeds max_size\n    max_size = 1024  # 1 KB\n\n    async with aiofiles.tempfile.SpooledTemporaryFile(\n        max_size=max_size, mode='w+'\n    ) as f:\n        # Small data stays in memory\n        await f.write('Small data\\n')\n        await f.flush()\n        print(\"File is in memory\")\n\n        # Writing more data to exceed max_size\n        large_data = 'x' * 2000\n        await f.write(large_data)\n        await f.flush()\n        print(\"File rolled over to disk\")\n\n        # Read back data\n        await f.seek(0)\n        content = await f.read()\n        print(f\"Read {len(content)} characters\")\n\n    # Binary mode\n    async with aiofiles.tempfile.SpooledTemporaryFile(\n        max_size=512, mode='wb+'\n    ) as f:\n        await f.write(b'Binary data in memory')\n        await f.seek(0)\n        data = await f.read()\n        print(f\"Binary data: {data}\")\n\nasyncio.run(spooled_temporary_files())\n```\n\n## aiofiles.open() - File Seeking and Positioning (Python)\n\n```python\nimport asyncio\nimport aiofiles\n\nasync def file_positioning():\n    async with aiofiles.open('data.txt', mode='r+') as f:\n        # Read first 10 bytes\n        data = await f.read(10)\n        print(f\"First 10 bytes: {data}\")\n\n        # Get current position\n        position = await f.tell()\n        print(f\"Current position: {position}\")\n\n        # Seek to specific position\n        await f.seek(0)  # Go to beginning\n        first_line = await f.readline()\n        print(f\"First line: {first_line}\")\n\n        # Seek to end\n        await f.seek(0, 2)  # 2 = SEEK_END\n        end_position = await f.tell()\n        print(f\"File size: {end_position} bytes\")\n\n        # Truncate file\n        await f.seek(0)\n        await f.truncate(50)  # Truncate to 50 bytes\n\nasyncio.run(file_positioning())\n```\n\n## Create and Use TemporaryFile with aiofiles\n\n```Python\nimport asyncio\nimport aiofiles.tempfile\n\nasync def temporary_files():\n    # Create temporary file (no name in filesystem)\n    async with aiofiles.tempfile.TemporaryFile('w+') as f:\n        await f.write('Temporary data\\n')\n        await f.write('More data\\n')\n        await f.seek(0)\n        content = await f.read()\n        print(f\"Temp content: {content}\")\n    # File automatically deleted after context manager exits\n\n    # Binary temporary file\n    async with aioiofiles.tempfile.TemporaryFile('wb+') as f:\n        await f.write(b'Binary temporary data')\n        await f.seek(0)\n        data = await f.read()\n        print(f\"Read {len(data)} bytes\")\n\nasyncio.run(temporary_files())\n```",
    "library": "aiofiles",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-29T22:13:27.005140"
}