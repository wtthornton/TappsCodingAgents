{
  "library": "markdown",
  "topic": "examples",
  "documentation": {
    "content": "## Sanitize User Input and URLs with Simple Markdown\n\n```javascript\nvar SimpleMarkdown = require(\"simple-markdown\");\n\n// Built-in sanitization functions\nvar sanitizeUrl = SimpleMarkdown.sanitizeUrl;\nvar sanitizeText = SimpleMarkdown.sanitizeText;\n\n// Dangerous URL is neutralized\nvar safeUrl = sanitizeUrl('javascript:alert(\"XSS\")');\nconsole.log(safeUrl); // null\n\nvar safeUrl2 = sanitizeUrl('https://example.com');\nconsole.log(safeUrl2); // \"https://example.com\"\n\n// HTML entities are escaped\nvar safeText = sanitizeText('<script>alert(\"XSS\")</script>');\nconsole.log(safeText); // \"&lt;script&gt;alert(\\\"XSS\\\")&lt;/script&gt;\"\n\n// Default rules already use sanitization\nvar userMarkdown = '[Click me](javascript:alert(\"XSS\"))';\nvar tree = SimpleMarkdown.defaultBlockParse(userMarkdown);\nvar html = SimpleMarkdown.defaultHtmlOutput(tree);\nconsole.log(html);\n// Link href will be sanitized to null, preventing XSS\n\n// Custom rule with sanitization\nvar customLinkRule = Object.assign({}, SimpleMarkdown.defaultRules.link, {\n  html: function(node, output, state) {\n    var safeHref = sanitizeUrl(node.target) || '#';\n    var safeTitle = node.title ? sanitizeText(node.title) : null;\n\n    return SimpleMarkdown.htmlTag('a', output(node.content, state), {\n      href: safeHref,\n      title: safeTitle,\n      rel: 'nofollow noopener'\n    });\n  }\n});\n```\n\n## Inspect Syntax Tree Output\n\n```javascript\n// pretty-print this with 4-space indentation:\nconsole.log(JSON.stringify(syntaxTree, null, 4));\n\n```\n\n## Access Default Markdown Rules\n\n```javascript\nconst defaultRules = SimpleMarkdown.defaultRules;\nconsole.log(defaultRules.heading);\n```\n\n## Extend Default Rules with Underline Rule (JavaScript)\n\n```javascript\nvar rules = _.extend({}, SimpleMarkdown.defaultRules, {\n  underline: underlineRule,\n});\n\n```\n\n## Create Parsers for Multiple Output Formats in Simple Markdown\n\n```javascript\nvar SimpleMarkdown = require(\"simple-markdown\");\n\n// Define a rule with multiple output methods\nvar emphasisRule = {\n  order: SimpleMarkdown.defaultRules.em.order,\n  match: SimpleMarkdown.inlineRegex(/^\\*\\*([\\s\\S]+?)\\*\\*/),\n\n  parse: function(capture, parse, state) {\n    return { content: parse(capture[1], state) };\n  },\n\n  react: function(node, output, state) {\n    return SimpleMarkdown.reactElement('strong', state.key, {\n      children: output(node.content, state)\n    });\n  },\n\n  html: function(node, output, state) {\n    return SimpleMarkdown.htmlTag('strong', output(node.content, state));\n  },\n\n  // Custom plain text output\n  text: function(node, output, state) {\n    return output(node.content, state).toUpperCase();\n  }\n};\n\nvar rules = Object.assign({}, SimpleMarkdown.defaultRules, {\n  strong: emphasisRule\n});\n\n// Add Array handler for text output\nrules.Array = Object.assign({}, rules.Array, {\n  text: function(arr, output, state) {\n    return arr.map(function(node) {\n      return output(node, state);\n    }).join('');\n  }\n});\n\n// Add text handler for text nodes\nrules.text = Object.assign({}, rules.text, {\n  text: function(node, output, state) {\n    return node.content;\n  }\n});\n\nvar parser = SimpleMarkdown.parserFor(rules);\nvar textOutput = SimpleMarkdown.outputFor(rules, 'text');\n\nvar tree = parser(\"This is **important** text\", { inline: true });\nconsole.log(textOutput(tree));\n// \"This is IMPORTANT text\"\n```\n\n## Define and Parse Underline Rule (JavaScript)\n\n```javascript\nvar underlineRule = {\n  // Specify the order in which this rule is to be run\n  order: SimpleMarkdown.defaultRules.em.order - 0.5,\n\n  // First we check whether a string matches\n  match: function (source) {\n    return /^__([\\s\\S]+?)__(?!_)/.exec(source);\n  },\n\n  // Then parse this string into a syntax node\n  parse: function (capture, parse, state) {\n    return {\n      content: parse(capture[1], state),\n    };\n  },\n\n  // Finally transform this syntax node into a\n  // React element\n  react: function (node, output) {\n    return React.DOM.u(null, output(node.content));\n  },\n\n  // Or an html element:\n  // (Note: you may only need to make one of `react:` or\n  // `html:`, as long as you never ask for an outputter\n  // for the other type.)\n  html: function (node, output) {\n    return \"<u>\" + output(node.content) + \"</u>\";\n  },\n};\n\n```\n\n## Output Syntax Tree to React Elements\n\n```javascript\nmdOutput(syntaxTree)\n```\n\n## Build Custom Inline Rules for Mentions in Simple Markdown\n\n```javascript\nvar SimpleMarkdown = require(\"simple-markdown\");\n\n// Custom @mention rule\nvar mentionRule = {\n  order: SimpleMarkdown.defaultRules.text.order - 1,\n\n  match: SimpleMarkdown.inlineRegex(/^@([a-zA-Z0-9_]+)/),\n\n  parse: function(capture, parse, state) {\n    return {\n      username: capture[1]\n    };\n  },\n\n  react: function(node, output, state) {\n    return SimpleMarkdown.reactElement('a', state.key, {\n      href: '/users/' + node.username,\n      className: 'mention',\n      children: '@' + node.username\n    });\n  },\n\n  html: function(node, output, state) {\n    var attrs = {\n      href: '/users/' + node.username,\n      class: 'mention'\n    };\n    return SimpleMarkdown.htmlTag('a', '@' + node.username, attrs);\n  }\n};\n\nvar rules = Object.assign({}, SimpleMarkdown.defaultRules, {\n  mention: mentionRule\n});\n\nvar parser = SimpleMarkdown.parserFor(rules);\nvar reactOutput = SimpleMarkdown.outputFor(rules, 'react');\n\nvar parseInline = function(source) {\n  return parser(source, { inline: true });\n};\n\nvar tree = parseInline(\"Hello @john and @jane!\");\nconsole.log(reactOutput(tree));\n// [React elements with mention links]\n```\n\n## Create Parser and Renderers from Rules (JavaScript)\n\n```javascript\nvar rules = {\n    ...SimpleMarkdown.defaultRules,\n    paragraph: {\n        ...SimpleMarkdown.defaultRules.paragraph,\n        react: (node, output, state) => {\n            return <p key={state.key}>{output(node.content, state)}</p>;\n        }\n    }\n};\n\nvar parser = SimpleMarkdown.parserFor(rules);\nvar reactOutput = SimpleMarkdown.outputFor(rules, 'react'));\nvar htmlOutput = SimpleMarkdown.outputFor(rules, 'html'));\n\nvar blockParseAndOutput = function(source) {\n    // Many rules require content to end in \\n\\n to be interpreted\n    // as a block.\n    var blockSource = source + \"\\n\\n\";\n    var parseTree = parser(blockSource, {inline: false});\n    var outputResult = htmlOutput(parseTree);\n    // Or for react output, use:\n    // var outputResult = reactOutput(parseTree);\n    return outputResult;\n};\n```\n\n## Implement Stateful Parsing for List Nesting Depth in Simple Markdown\n\n```javascript\nvar SimpleMarkdown = require(\"simple-markdown\");\n\n// Create a rule that tracks nesting depth\nvar customListRule = Object.assign({}, SimpleMarkdown.defaultRules.list, {\n  parse: function(capture, parse, state) {\n    // Track list depth in state\n    state.listDepth = (state.listDepth || 0) + 1;\n\n    var result = SimpleMarkdown.defaultRules.list.parse(capture, parse, state);\n    result.depth = state.listDepth;\n\n    state.listDepth = state.listDepth - 1;\n    return result;\n  },\n\n  html: function(node, output, state) {\n    var listTag = node.ordered ? 'ol' : 'ul';\n    var items = node.items.map(function(item) {\n      return SimpleMarkdown.htmlTag('li', output(item, state));\n    }).join('');\n\n    var attrs = {\n      class: 'list-depth-' + node.depth,\n      start: node.start\n    };\n    return SimpleMarkdown.htmlTag(listTag, items, attrs);\n  }\n});\n\nvar rules = Object.assign({}, SimpleMarkdown.defaultRules, {\n  list: customListRule\n});\n\nvar parser = SimpleMarkdown.parserFor(rules, { listDepth: 0 });\nvar htmlOutput = SimpleMarkdown.outputFor(rules, 'html');\n\nvar markdown = \"* Level 1\\n  * Level 2\\n    * Level 3\\n\";\nvar tree = parser(markdown, { inline: false });\nconsole.log(htmlOutput(tree));\n// Lists with depth-specific classes\n```",
    "library": "markdown",
    "topic": "common-mistakes",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:27:50.610611"
}