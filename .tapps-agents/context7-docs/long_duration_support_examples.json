{
  "library": "long_duration_support",
  "topic": "examples",
  "documentation": {
    "content": "## Go Example Usage of Durable Streams Client\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    ds \"github.com/durable-streams/durable-streams/packages/client-go\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    // Create client (zero external dependencies)\n    client := ds.NewClient()\n\n    // Get stream handle\n    stream := client.Stream(\"https://example.com/streams/my-stream\")\n\n    // Create the stream (idempotent - succeeds if same config exists)\n    err := stream.Create(ctx,\n        ds.WithContentType(\"application/json\"),\n        ds.WithTTL(24*time.Hour),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Append data - returns NextOffset for checkpointing\n    result, err := stream.AppendJSON(ctx, map[string]any{\n        \"event\": \"user.created\",\n        \"user\":  \"alice\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Appended, next offset: %s\\n\", result.NextOffset)\n\n    // Read JSON batches (catch-up only)\n    it := stream.ReadJSON[map[string]any](ctx)\n    defer it.Close()\n\n    for {\n        batch, err := it.Next()\n        if errors.Is(err, ds.Done) {\n            break\n        }\n        if err != nil {\n            log.Fatal(err)\n        }\n        for _, item := range batch.Items {\n            fmt.Printf(\"Item: %v\\n\", item)\n        }\n        fmt.Printf(\"Batch offset: %s, up-to-date: %v\\n\", batch.NextOffset, batch.UpToDate)\n    }\n\n    // Live tailing with long-poll\n    it2 := stream.ReadJSON[Event](ctx, ds.WithLive(ds.LiveModeLongPoll))\n    defer it2.Close()\n\n    for {\n        batch, err := it2.Next()\n        if errors.Is(err, ds.Done) {\n            break\n        }\n        if err != nil {\n            log.Fatal(err)\n        }\n        for _, event := range batch.Items {\n            fmt.Printf(\"Event: %+v\\n\", event)\n        }\n    }\n}\n\ntype Event struct {\n    Type string `json:\"event\"`\n    User string `json:\"user\"`\n}\n```\n\n## Basic Producer Usage in Java\n\n```java\ntry (var producer = client.producer(url, \"my-producer\")) {\n    // Fire-and-forget - calls return immediately\n    producer.append(\"{\\\"event\\\":\\\"a\\\"}\");\n    producer.append(\"{\\\"event\\\":\\\"b\\\"}\");\n    producer.append(\"{\\\"event\\\":\\\"c\\\"}\");\n\n    // Wait for all pending batches to complete\n    producer.flush();\n}  // close() calls flush() automatically\n```\n\n## DurableStreams Client Usage Examples\n\n```ruby\n# Block form (recommended - auto-closes)\nDurableStreams::Client.open(\n  base_url: \"https://streams.example.com\",\n  headers: { \"Authorization\" => -> { \"Bearer #{refresh_token}\" } }\n) do |client|\n  chat_stream = client.stream(\"/chat/room-1\")\n  events_stream = client.stream(\"/events/user-123\")\n  # ...\nend # auto-closes\n\n# Manual form\nclient = DurableStreams::Client.new(\n  base_url: \"https://streams.example.com\",\n  headers: { \"Authorization\" => -> { \"Bearer #{refresh_token}\" } },\n  timeout: 60\n)\n\n# Get stream handles\nchat_stream = client.stream(\"/chat/room-1\")\nevents_stream = client.stream(\"/events/user-123\")\n\n# Always close when done\nclient.close\n```\n\n## Programmatic Usage\n\n```APIDOC\n## Programmatic Usage\n\n```typescript\nimport { runConformanceTests } from \"@durable-streams/client-conformance-tests\"\n\nconst summary = await runConformanceTests({\n  clientAdapter: \"ts\", // or path to your adapter\n  suites: [\"producer\", \"consumer\"],\n  verbose: true,\n})\n\nconsole.log(`Passed: ${summary.passed}/${summary.total}`)\n```\n```\n\n## Usage: Provider Lifecycle Management (Disconnect, Connect, Destroy)\n\n```typescript\n// Disconnect temporarily\nprovider.disconnect()\n\n// Reconnect\nprovider.connect()\n\n// Destroy permanently\nprovider.destroy()\n```\n\n## Usage: Event Handling for Sync, Status, and Errors\n\n```typescript\n// Sync state changes\nprovider.on(\"synced\", (synced: boolean) => {\n  if (synced) {\n    console.log(\"Document is synced with server\")\n  }\n})\n\n// Connection status changes\nprovider.on(\"status\", (status: ProviderStatus) => {\n  console.log(\"Status:\", status) // \"disconnected\" | \"connecting\" | \"connected\"\n})\n\n// Error handling\nprovider.on(\"error\", (error: Error) => {\n  console.error(\"Provider error:\", error)\n})\n```\n\n## Usage: Document Only Synchronization\n\n```typescript\nconst provider = new DurableStreamsProvider({\n  doc,\n  documentStream: {\n    url: \"https://your-server.com/v1/stream/rooms/my-room\",\n  },\n})\n```\n\n## DurableStreams::Producer: Usage Example (Manual Form) in Ruby\n\n```ruby\nproducer = DurableStreams::Producer.new(\n  url: \"https://streams.example.com/orders\",\n  producer_id: \"order-service-1\",\n  epoch: load_epoch_from_disk || 0\n)\n\n# Fire-and-forget (batched internally)\n1000.times do |i|\n  producer.append({ order_id: i, status: \"created\" })\nend\n\n# Ensure all data is written\nproducer.flush\nproducer.close\n```\n\n## DurableStreams::Producer: Usage Example (Block Form) in Ruby\n\n```ruby\nDurableStreams::Producer.open(\n  url: \"https://streams.example.com/orders\",\n  producer_id: \"order-service-1\",\n  epoch: load_epoch_from_disk || 0\n) do |producer|\n  # Shovel operator for append\n  producer << { order_id: 1, status: \"created\" }\nend\n```\n\n## Basic Idempotent Producer Usage\n\n```java\ntry (var producer = client.producer(url, \"my-producer\")) {\n    producer.append(data1);  // Fire-and-forget\n    producer.append(data2);\n    producer.append(data3);\n    producer.flush();        // Wait for all pending\n}  // close() calls flush() automatically\n```",
    "library": "long_duration_support",
    "topic": "usage",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:32:09.339740"
}