{
  "library": "scorer_registry",
  "topic": "examples",
  "documentation": {
    "content": "## Interacting with StableBTreeMap for Vecs and Strings (DFX)\n\n```bash\ndfx start --background\ndfx deploy\ndfx canister call vecs_and_strings insert '(\"alice\", blob \"12341234\")'\ndfx canister call vecs_and_strings insert '(\"bob\", blob \"789789789\")'\ndfx deploy --upgrade-unchanged vecs_and_strings\ndfx canister call vecs_and_strings get '(\"alice\")'\ndfx canister call vecs_and_strings get '(\"bob\")'\n```\n\n## Interacting with StableBTreeMap for Primitive Types (DFX)\n\n```bash\ndfx start --background\ndfx deploy\ndfx canister call basic_example insert '(1:nat, 2:nat)'\ndfx canister call basic_example insert '(3:nat, 4:nat)'\ndfx deploy --upgrade-unchanged basic_example\ndfx canister call basic_example get '(1:nat)'\ndfx canister call basic_example get '(3:nat)'\n```\n\n## Interacting with StableBTreeMap for Custom Structs (DFX)\n\n```bash\ndfx canister call custom_types_example insert '(1, record { age = 32; name = \"Some Name\"})'\ndfx canister call custom_types_example insert '(2, record { age = 48; name = \"Other Name\"})'\ndfx deploy --upgrade-unchanged custom_types_example\ndfx canister call custom_types_example get '(1)'\ndfx canister call custom_types_example get '(2)'\n```\n\n## Full Canister Example with StableBTreeMap - Rust\n\n```Rust\nuse ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};\nuse ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};\nuse std::cell::RefCell;\n\ntype Memory = VirtualMemory<DefaultMemoryImpl>;\n\nthread_local! {\n    // The memory manager is used for simulating multiple memories. Given a `MemoryId` it can\n    // return a memory that can be used by stable structures.\n    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =\n        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));\n\n    // Initialize a `StableBTreeMap` with `MemoryId(0)`.\n    static MAP: RefCell<StableBTreeMap<u128, u128, Memory>> = RefCell::new(\n        StableBTreeMap::init(\n            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(0))),\n        )\n    );\n}\n\n// Retrieves the value associated with the given key if it exists.\n#[ic_cdk_macros::query]\nfn get(key: u128) -> Option<u128> {\n    MAP.with(|p| p.borrow().get(&key))\n}\n\n// Inserts an entry into the map and returns the previous value of the key if it exists.\n#[ic_cdk_macros::update]\nfn insert(key: u128, value: u128) -> Option<u128> {\n    MAP.with(|p| p.borrow_mut().insert(key, value))\n}\n```\n\n## Demonstrating StableBTreeMap Persistence with dfx\n\n```Shell\ndfx start --background --clean\n\n# Insert some data into the quick_start canister.\ndfx canister call quick_start stable_insert '(1:nat, 2:nat)'\ndfx canister call quick_start stable_insert '(3:nat, 4:nat)'\ndfx canister call quick_start set_heap_data '(vec {1:nat8; 2:nat8; 3:nat8})'\n\n# Upgrade the canister, which clears all the data in the heap.\ndfx deploy --upgrade-unchanged quick_start\n\n# Even though the canister has been upgraded and its heap is cleared,\n# querying the canister should still return the data stored prior to\n# the upgrade.\ndfx canister call quick_start stable_get '(1:nat)'\n> (opt (2 : nat))\n\ndfx canister call quick_start stable_get '(3:nat)'\n> (opt (4 : nat))\n\ndfx canister call quick_start get_heap_data\n> (blob \"\\01\\02\\03\")\n```\n\n## Incorrect Memory Sharing with Stable Structures in Rust\n\n```Rust\nuse ic_stable_structures::{BTreeMap, DefaultMemoryImpl};\nlet mut map_1: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\nlet mut map_2: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\n\nmap_1.insert(1, 2);\nmap_2.insert(1, 3);\nassert_eq!(map_1.get(&1), Some(2)); // This assertion fails.\n```\n\n## Demonstrating Memory Sharing Failure with Multiple BTreeMaps in Rust\n\n```Rust\nuse ic_stable_structures::{BTreeMap, DefaultMemoryImpl};\nlet mut map_1: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\nlet mut map_2: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\n\nmap_1.insert(1, 2);\nmap_2.insert(1, 3);\nassert_eq!(map_1.get(&1), Some(2)); // This assertion fails.\n```\n\n## Initializing BTreeMap with DefaultMemoryImpl in Rust\n\n```Rust\nuse ic_stable_structures::{BTreeMap, DefaultMemoryImpl};\nlet mut map: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\n```\n\n## Initializing Memory Manager and Multiple BTreeMaps (Rust)\n\n```Rust\nuse ic_stable_structures::{\n   memory_manager::{MemoryId, MemoryManager},\n   BTreeMap, DefaultMemoryImpl,\n};\n\n// Initialize a MemoryManager with DefaultMemoryImpl as the underlying memory\nlet mem_mgr = MemoryManager::init(DefaultMemoryImpl::default());\n\n// Create two separate BTreeMaps, each with its own virtual memory\nlet mut map_1: BTreeMap<u64, u64, _> = BTreeMap::init(mem_mgr.get(MemoryId::new(0)));\nlet mut map_2: BTreeMap<u64, u64, _> = BTreeMap::init(mem_mgr.get(MemoryId::new(1)));\n\n// Demonstrate independent operation of the two maps\nmap_1.insert(1, 2);\nmap_2.insert(1, 3);\nassert_eq!(map_1.get(&1), Some(2)); // Succeeds as expected\n```\n\n## Initializing and Using BTreeSet in Rust\n\n```Rust\nuse ic_stable_structures::{BTreeSet, DefaultMemoryImpl};\nlet mut set: BTreeSet<u64, _> = BTreeSet::new(DefaultMemoryImpl::default());\n\nset.insert(42);\nassert!(set.contains(&42));\nassert_eq!(set.pop_first(), Some(42));\nassert!(set.is_empty());\n```",
    "library": "score_constants",
    "topic": "examples",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-03T09:49:37.975226"
}