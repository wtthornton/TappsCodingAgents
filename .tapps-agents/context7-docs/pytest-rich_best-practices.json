{
  "library": "pytest-rich",
  "topic": "best-practices",
  "documentation": {
    "content": "## pytest-mock mocker.patch Usage\n\n```python\nimport os\n\ndef test_patch_function(mocker):\n    # Mock os.remove function\n    mock_remove = mocker.patch('os.remove')\n\n    os.remove('/fake/path')\n\n    # Assert it was called with expected arguments\n    mock_remove.assert_called_once_with('/fake/path')\n    # File still exists - real function never executed\n\ndef test_patch_with_return_value(mocker):\n    # Mock with specific return value\n    mocker.patch('os.listdir', return_value=['file1.txt', 'file2.txt'])\n\n    result = os.listdir('/any/path')\n\n    assert result == ['file1.txt', 'file2.txt']\n\ndef test_patch_with_side_effect(mocker):\n    # Mock with exception\n    mocker.patch('os.remove', side_effect=PermissionError('Access denied'))\n\n    import pytest\n    with pytest.raises(PermissionError, match='Access denied'):\n        os.remove('/protected/file')\n\n```\n\n## Using contextlib.ExitStack with mock.patch in Python\n\n```python\nimport contextlib\nimport mock\n\ndef test_unix_fs():\n    with contextlib.ExitStack() as stack:\n        stack.enter_context(mock.patch('os.remove'))\n        UnixFS.rm('file')\n        os.remove.assert_called_once_with('file')\n\n        stack.enter_context(mock.patch('os.listdir'))\n        assert UnixFS.ls('dir') == expected\n        # ...\n\n        stack.enter_context(mock.patch('shutil.copy'))\n        UnixFS.cp('src', 'dst')\n        # ...\n\n```\n\n## Patching with mocker fixture in Python\n\n```python\ndef test_foo(mocker):\n    # all valid calls\n    mocker.patch('os.remove')\n    mocker.patch.object(os, 'listdir', autospec=True)\n    mocked_isfile = mocker.patch('os.path.isfile')\n```\n\n## pytest-mock mocker.patch.multiple Usage\n\n```python\nimport os\n\ndef test_patch_multiple(mocker):\n    # Mock multiple functions at once\n    mocks = mocker.patch.multiple('os',\n                                   remove=mocker.DEFAULT,\n                                   listdir=mocker.DEFAULT,\n                                   makedirs=mocker.DEFAULT)\n\n    # Set specific behaviors\n    mocks['listdir'].return_value = ['file.txt']\n\n    os.listdir('/tmp')\n    os.remove('/file')\n    os.makedirs('/newdir')\n\n    # All mocks are accessible\n    mocks['listdir'].assert_called_once_with('/tmp')\n    mocks['remove'].assert_called_once_with('/file')\n    mocks['makedirs'].assert_called_once_with('/newdir')\n\ndef test_patch_multiple_with_values(mocker):\n    # Provide explicit mock implementations\n    mocker.patch.multiple('os',\n                          remove=lambda x: None,\n                          listdir=lambda x: ['data.txt'])\n\n    result = os.listdir('/any')\n    assert result == ['data.txt']\n\n```\n\n## Mocking with mocker.patch.object in Python (Discouraged)\n\n```python\ndef test_context_manager(mocker):\n    a = A()\n    with mocker.patch.object(a, 'doIt', return_value=True, autospec=True):  # DO NOT DO THIS\n        assert a.doIt() == True\n```\n\n## pytest-mock Fixture Scopes\n\n```python\nimport pytest\n\ndef test_function_scope(mocker):\n    # Default function-scoped mocker\n    mocker.patch('os.remove')\n    # Automatically cleaned up after this test\n\nclass TestClass:\n    def test_class_scope(self, class_mocker):\n        # Mocks persist across all tests in this class\n        class_mocker.patch('os.listdir', return_value=['file.txt'])\n\ndef test_module_scope(module_mocker):\n    # Mocks persist across all tests in this module\n    module_mocker.patch('requests.get')\n\ndef test_package_scope(package_mocker):\n    # Mocks persist across package\n    package_mocker.patch('database.connect')\n\ndef test_session_scope(session_mocker):\n    # Mocks persist across entire test session\n    session_mocker.patch('app.initialize')\n\n```\n\n## Create and Use mocker.Mock and mocker.MagicMock Objects\n\n```python\ndef test_mock_object(mocker):\n    # Basic Mock\n    mock_obj = mocker.Mock()\n    mock_obj.method.return_value = 42\n\n    result = mock_obj.method('arg')\n\n    assert result == 42\n    mock_obj.method.assert_called_once_with('arg')\n\ndef test_magic_mock_special_methods(mocker):\n    # MagicMock supports magic methods\n    mock_obj = mocker.MagicMock()\n    mock_obj.__len__.return_value = 5\n    mock_obj.__getitem__.return_value = 'item'\n\n    assert len(mock_obj) == 5\n    assert mock_obj[0] == 'item'\n    mock_obj.__getitem__.assert_called_with(0)\n\ndef test_mock_spec(mocker):\n    class RealService:\n        def process(self, data):\n            pass\n\n    # Mock with spec enforces method signatures\n    mock_service = mocker.Mock(spec=RealService)\n    mock_service.process.return_value = 'result'\n\n    result = mock_service.process('data')\n    assert result == 'result'\n\n    # This raises AttributeError - method doesn't exist on RealService\n    try:\n        mock_service.nonexistent_method()\n    except AttributeError:\n        pass\n\n```\n\n## pytest-mock mocker.patch.object Usage\n\n```python\nimport os\n\ndef test_patch_object_method(mocker):\n    # Mock method on os module object\n    mock_listdir = mocker.patch.object(os, 'listdir', return_value=['data.txt'])\n\n    result = os.listdir('/tmp')\n\n    assert result == ['data.txt']\n    mock_listdir.assert_called_once_with('/tmp')\n\ndef test_patch_object_autospec(mocker):\n    # Autospec ensures mock has same signature as original\n    mocker.patch.object(os, 'remove', autospec=True)\n\n    os.remove('/file')  # Works\n\n    # This would raise TypeError due to autospec\n    try:\n        os.remove()  # Missing required argument\n    except TypeError:\n        pass\n\ndef test_patch_class_instance(mocker):\n    class FileManager:\n        def delete(self, path):\n            return f\"Deleted {path}\"\n\n    fm = FileManager()\n    mocker.patch.object(fm, 'delete', return_value='Mocked delete')\n\n    result = fm.delete('/file')\n    assert result == 'Mocked delete'\n\n```\n\n## Programmatic Configuration of pytest-mock\n\n```python\n# conftest.py\ndef pytest_configure(config):\n    # Programmatic configuration\n    config.addinivalue_line(\n        \"markers\", \"mock: mark test to use mocking\"\n    )\n```\n\n## Install pre-commit hooks\n\n```console\npre-commit install\n```",
    "library": "pytest-mock",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-29T22:13:25.667949"
}