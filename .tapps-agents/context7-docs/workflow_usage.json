{
  "library": "workflow",
  "topic": "usage",
  "documentation": {
    "content": "## Collect StateFlow - Compose Kotlin\n\n```kotlin\nclass MyWorkflow(\n  private val flow: StateFlow<String>\n) : ComposeWorkflow<\u2026>() {\n\n  @Composable\n  override fun produceRendering(props, emitOutput): Rendering {\n    val latest by flow.collectAsState()\n\n    TODO(\"Do something with $latest\")\n  }\n}\n```\n\n## Splitting Baseline Profiles with Java Tool\n\n```bash\njava -jar splitBaselineProfiles-all.jar --profilePath ~/path/to/profile.txt --checkoutPath ~/Development/workflow-kotlin/\n```\n\n## Define Saved/Restored Workflow State with Compose\n\n```kotlin\n@Parcelizable\ndata class State(\n  val someValue: String,\n  val valueWithDefault: Int = 0\n)\n\nclass MyWorkflow : StatefulWorkflow<Props, State, Output, Rendering>() {\n  override fun initialState(props, initialSnapshot: Snapshot?):\n State {\n    return initialSnapshot?.toParcelable<State>() ?: State(\n      someValue = \"initial some value\"\n    )\n  }\n\n  override fun snapshotState(state: State): Snapshot? {\n    return state.toSnapshot()\n  }\n}\n```\n\n## Define Saved/Restored Workflow State with Compose\n\n```kotlin\n@Composable\noverride fun produceRendering(props, emitOutput: (String) -> Unit): Rendering {\n  var someValue: String by rememberSaveable { mutableStateOf(\"initial some value\") }\n  var valueWithDefault: Int by rememberSaveable { mutableIntStateOf(0) }\n}\n```\n\n## Render Child Workflow - Compose Kotlin\n\n```kotlin\ninterface MyChild : Workflow<ChildProps, ChildOutput, ChildRendering>\n\ndata class Props(val propsForChild: ChildProps)\ndata class Output(val outputFromChild: ChildOutput)\ndata class Rendering(val renderingFromChild: ChildRendering)\n\nclass MyWorkflow @Inject constructor(\n  private val child: MyChild\n) : ComposeWorkflow<Props, Output, Rendering>() {\n  @Composable\n  override fun produceRendering(props, emitOutput): Rendering {\n    val childRendering = renderWorkflow(\n      props = props.propsForChild,\n      onOutput = { childOutput ->\n        emitOutput(Output(childOutput))\n      }\n    )\n\n    return Rendering(\n      renderingFromChild = childRendering\n    )\n  }\n}\n```\n\n## Render Child Workflow - Workflow Kotlin\n\n```kotlin\ninterface MyChild : Workflow<ChildProps, ChildOutput, ChildRendering>\n\ndata class Props(val propsForChild: ChildProps)\ndata class Output(val outputFromChild: ChildOutput)\ndata class Rendering(val renderingFromChild: ChildRendering)\n\nclass MyWorkflow @Inject constructor(\n  private val child: MyChild\n) : StatelessWorkflow<Props, Output, Rendering>() {\n  override fun render(props, context): Rendering {\n    val childRendering = context.renderChild(\n      child,\n      props = props.propsForChild,\n      handler = { childOutput ->\n        action { setOutput(Output(childOutput)) }\n      }\n    )\n\n    return Rendering(\n      renderingFromChild = childRendering\n    )\n  }\n}\n```\n\n## Observe Lifetime - Compose Kotlin\n\n```kotlin\nTK DisposableEffect, LaunchedEffect\n```\n\n## Define TodoListWorkflow Props, State, and Outputs (Kotlin)\n\n```kotlin\nobject TodoListWorkflow : StatefulWorkflow<ListProps, State, Output, TodoListScreen>() {\n\n  data class ListProps(\n    val username: String,\n    val todos: List<TodoModel>\n  )\n\n  object State\n\n  sealed interface Output {\n    object BackPressed : Output\n    data class TodoSelected(val index: Int) : Output\n  }\n\n  override fun initialState(\n    props: ListProps,\n    snapshot: Snapshot?\n  )\n\n  override fun render(\n    renderProps: ListProps,\n    renderState: State,\n    context: RenderContext\n  ): TodoListScreen {\n    // \u2026\n  }\n\n  override fun snapshotState(state: State): Snapshot? = null\n\n  // \u2026\n\n}\n```\n\n## Build and Publish Snapshot Artifacts with Gradle\n\n```bash\n./gradlew clean build && ./gradlew publish\n```\n\n## Realistic Sample: ComposeWorkflow with State and Effects in Kotlin\n\n```kotlin\nclass RootWorkflow @Inject constructor(\n  // MyWorkflow is defined below \u2013 it's a workflow, but compose.\n  private val child: SampleComposeWorkflow\n) : StatelessWorkflow {\n  override fun render(props, context): Rendering {\n    // Here from a traditional workflow, render a compose one:\n    context.renderChild(child, childProps, handler = { \u2026 })\n  }\n}\n\n// Just some shared service object, defined somewhere else in the codebase.\ninterface Service {\n  val values: StateFlow<String>\n}\n\ndata class SampleRendering(\n  val label: String,\n  val onClick: () -> Unit\n)\n\nclass SampleComposeWorkflow @Inject constructor(\n  private val injectedService: Service,\n  private val child: Workflow<String, String, String>\n) : ComposeWorkflow<\n  /* PropsT */ String,\n  /* OutputT */ String,\n  /* RenderingT */ SampleRendering\n>() {\n\n  @Composable\n  override fun produceRendering(\n    props: String,\n    emitOutput: (String) -> Unit\n  ): SampleRendering {\n    // ComposeWorkflows use native compose idioms to manage state, including\n    // saving state to be restored later. We don't need to implement the\n    // snapshotState method or make aggregate state holders Parcelizable.\n    var clickCount by rememberSaveable { mutableIntStateOf(0) }\n\n    // They also use native compose idioms to work with Flows and perform\n    // effects. To do this in a traditional workflow this is much more verbose:\n    // you'd need to read the flow in initialState and then drop(1) before\n    // collecting in the render method.\n    val serviceValue by injectedService.values.collectAsState()\n\n    // And they can render child workflows, just like traditional workflows.\n    // This child can be any type of Workflow: Stateless, Stateful, Compose, it\n    // doesn't matter.\n    // This is equivalent to calling BaseRenderContext.renderChild().\n    // Note that there's no explicit key: the child key is tied to where it's\n    // called in the composition, the same way other composable state is keyed.\n    val childRendering = renderWorkflow(\n      workflow = child,\n      props = \"child props\",\n      // This is equivalent to the handler parameter on renderChild().\n      onOutput = {\n        myState = ???\n        emitOutput(\"child emitted output: $it\")\n      }\n    )\n\n    return SampleRendering(\n      // Reading clickCount and serviceValue here mean that when those values are\n      // changed, it will trigger a render pass in the hosting workflow tree,\n      // which will recompose this method.\n      label = \"props=$props, \" +\n        \"clickCount=$clickCount, \" +\n        \"serviceValue=$serviceValue, \" +\n        \"childRendering=$childRendering\",\n      // Note the lack of rememberLamda: Compose automatically memoizes lambdas\n      // created inside a composable, so we get that for free.\n      onClick = {\n        // Instead of using WorkflowAction's state property, you can just update\n        // snapshot state objects directly.\n        clickCount++\n\n        // This is equivalent to calling setOutput from a WorkflowAction.\n        emitOutput(\"clicked!\")\n      }\n    )\n  }\n}\n```\n\n## Identity Workflow Implementation for Compose Integration\n\n```kotlin\nclass IdentityWorkflow(\n  private val child: Workflow<Props, Output, Rendering>\n) : StatelessWorkflow<Props, Output, Rendering> {\n  override fun render(props: Props, context: RenderContext): Rendering {\n    return context.renderComposable { \n      renderWorkflow(child, props, onOutput = { output ->\n        context.eventSink.send(action { setOutput(output) })\n      })\n    }\n  }\n}\n```",
    "library": "workflow",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-29T22:14:48.698019"
}