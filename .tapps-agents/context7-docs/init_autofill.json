{
  "library": "init_autofill",
  "topic": null,
  "documentation": {
    "content": "## Wrapping MaterialApp with Portal Widget\n\n```Dart\nPortal(\n  child: MaterialApp(\n    ...\n  )\n);\n```\n\n## Adding Multi Trigger Autocomplete Dependency\n\n```YAML\ndependencies:\n  multi_trigger_autocomplete: ^[version]\n```\n\n## Implementing MultiTriggerAutocomplete with Multiple Triggers\n\n```Dart\nMultiTriggerAutocomplete(\n  optionsAlignment: OptionsAlignment.topStart,\n  autocompleteTriggers: [\n    // Add the triggers you want to use for autocomplete\n    AutocompleteTrigger(\n      trigger: '@',\n      optionsViewBuilder: (context, autocompleteQuery, controller) {\n        return MentionAutocompleteOptions(\n          query: autocompleteQuery.query,\n          onMentionUserTap: (user) {\n            final autocomplete = MultiTriggerAutocomplete.of(context);\n            return autocomplete.acceptAutocompleteOption(user.id);\n          },\n        );\n      },\n    ),\n    AutocompleteTrigger(\n      trigger: '#',\n      optionsViewBuilder: (context, autocompleteQuery, controller) {\n        return HashtagAutocompleteOptions(\n          query: autocompleteQuery.query,\n          onHashtagTap: (hashtag) {\n            final autocomplete = MultiTriggerAutocomplete.of(context);\n            return autocomplete\n                .acceptAutocompleteOption(hashtag.name);\n          },\n        );\n      },\n    ),\n    AutocompleteTrigger(\n      trigger: ':',\n      optionsViewBuilder: (context, autocompleteQuery, controller) {\n        return EmojiAutocompleteOptions(\n          query: autocompleteQuery.query,\n          onEmojiTap: (emoji) {\n            final autocomplete = MultiTriggerAutocomplete.of(context);\n            return autocomplete.acceptAutocompleteOption(\n              emoji.char,\n              // Passing false as we don't want the trigger [:] to\n              // get prefixed to the option in case of emoji.\n              keepTrigger: false,\n            );\n          },\n        );\n      },\n    ),\n  ],\n  // Add the text field widget you want to use for autocomplete\n  fieldViewBuilder: (context, controller, focusNode) {\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: ChatMessageTextField(\n        focusNode: focusNode,\n        controller: controller,\n      ),\n    );\n  },\n),\n```\n\n## Importing Multi Trigger Autocomplete Package\n\n```Dart\nimport 'package:multi_trigger_autocomplete/multi_trigger_autocomplete.dart';\n```\n\n## Defining AutocompleteTrigger in Dart\n\n```Dart\nAutocompleteTrigger(\n  // The trigger string/character that will be used to trigger the\n  // autocomplete.\n  trigger: '@',\n  \n  // If true, the [trigger] should only be recognised at\n  // the start of the input text.\n  //\n  // valid example: \"@luke hello\"\n  // invalid example: \"Hello @luke\"\n  triggerOnlyAtStart: false,\n  \n  // If true, the [trigger] should only be recognised after\n  // a space.\n  //\n  // valid example: \"@luke\", \"Hello @luke\"\n  // invalid example: \"Hello@luke\"\n  triggerOnlyAfterSpace: true,\n  \n  // A minimum number of characters can be provided to only show\n  // suggestions after the user has input enough characters.\n  //\n  // example:\n  // \"Hello @l\" -> Shows zero suggestions.\n  // \"Hello @lu\" -> Shows suggestions for @lu.\n  minimumRequiredCharacters: 2,\n  \n  // The options view builder is used to build the options view\n  // that will be shown when the [trigger] is detected.\n  optionsViewBuilder: (context, autocompleteQuery, controller) {\n    return MentionAutocompleteOptions(\n      query: autocompleteQuery.query,\n      onMentionUserTap: (user) {\n        // Accept the autocomplete option.\n        final autocomplete = MultiTriggerAutocomplete.of(context);\n        return autocomplete.acceptAutocompleteOption(user.id);\n      },\n    );\n  },\n)\n```\n\n## Configuring MultiTriggerAutocomplete in Dart\n\n```Dart\nMultiTriggerAutocomplete(\n  // Defines the autocomplete trigger that will be used to match the\n  // text.\n  autocompleteTriggers: autocompleteTriggers,\n  \n  // Defines the alignment of the options view relative to the\n  // fieldView.\n  //\n  // By default, the options view is aligned to the bottom of the\n  // fieldView.\n  optionsAlignment: OptionsAlignment.topStart,\n  \n  // Defines the width to make the options as a multiple of the width\n  // of the fieldView.\n  //\n  // Setting this to 1 makes the options view width matches the width\n  // of the fieldView.\n  //\n  // Use null to remove this constraint.\n  optionsWidthFactor: 1.0,\n  \n  // Defines the duration of the debounce period for the\n  // [TextEditingController].\n  //\n  // This is the time between the last character typed and the matching\n  // is performed.\n  debounceDuration: const Duration(milliseconds: 350),\n  \n  // Defines the initial value to set in the internal\n  // [TextEditingController].\n  //\n  // This value will be ignored if [TextEditingController] is provided.\n  initialValue: const TextEditingValue(text: 'Hello'),\n  \n  // Defines the [TextEditingController] that will be used for the\n  // fieldView.\n  //\n  // If this parameter is provided, then [focusNode] must also be\n  // provided.\n  textEditingController: TextEditingController(text: 'Hello'),\n  \n  // Defines the [FocusNode] that will be used for the fieldView.\n  //\n  // If this parameter is provided, then [textEditingController] must\n  // also be provided.\n  focusNode: FocusNode(),\n  \n  // Defines the fieldView that will be used to input the text.\n  //\n  // By default, a [TextFormField] is used.\n  fieldViewBuilder: (context, controller, focusNode) {\n    return TextField(\n      controller: controller,\n      focusNode: focusNode,\n    );\n  },\n),\n```\n\n## Opening iOS Project in Xcode\n\n```Shell\nopen ios/Runner.xcworkspace\n```\n",
    "library": "init_autofill",
    "topic": "overview",
    "source": "api"
  },
  "source": "api",
  "saved_at": "2026-02-05T13:39:11.334872"
}