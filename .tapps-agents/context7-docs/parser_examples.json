{
  "library": "parser",
  "topic": "examples",
  "documentation": {
    "content": "## Detect V3 Pepega Maps with Overlapping Objects\n\n```csharp\nusing Parser.Utils;\nusing beatleader_parser;\n\nvar parser = new Parse();\nvar map = parser.TryLoadPath(\"/path/to/map\");\n\nif (map != null)\n{\n    foreach (var diff in map.Difficulties)\n    {\n        bool isPepega = diff.IsV3Pepega();\n        if (isPepega)\n        {\n            Console.WriteLine($\"{diff.Difficulty}: Contains overlapping V3 scoring objects\");\n            Console.WriteLine(\"  This map has notes that overlap with arc/chain heads or tails\");\n        }\n        else\n        {\n            Console.WriteLine($\"{diff.Difficulty}: Standard scoring\");\n        }\n    }\n}\n```\n\n## Mirror Beatmap for Left-Handed Play\n\n```csharp\nusing Parser.Utils;\nusing beatleader_parser;\n\nvar parser = new Parse();\nvar map = parser.TryLoadPath(\"/path/to/map\");\n\nif (map != null)\n{\n    // Mirror entire map (all difficulties)\n    map.Mirror();\n\n    Console.WriteLine(\"Mirrored entire map\");\n\n    // Verify mirroring by checking first note\n    var firstNote = map.Difficulties[0].Data.Notes[0];\n    Console.WriteLine($\"First note - Color: {firstNote.Color}, X: {firstNote.x}, Direction: {firstNote.CutDirection}\");\n}\n\n// Or mirror just one difficulty\nvar singleDiff = parser.TryLoadPath(\"/path/to/map\", \"Standard\", \"Expert\");\nif (singleDiff != null)\n{\n    singleDiff.Difficulty.Mirror();\n    Console.WriteLine(\"Mirrored single difficulty\");\n}\n```\n\n## Accessing Lighting Events in Beatleader Maps\n\n```csharp\nusing beatleader_parser;\nusing System.Linq;\n\nvar parser = new Parse();\nvar map = parser.TryLoadPath(\"/path/to/map\");\n\nif (map != null)\n{\n    var diff = map.Difficulties[0];\n\n    // Basic lights\n    Console.WriteLine($\"Basic Light Events: {diff.Data.Lights.Count}\");\n    foreach (var light in diff.Data.Lights.Take(10))\n    {\n        Console.WriteLine($\"Light event at {light.Seconds:F3}s\");\n        Console.WriteLine($\"  Type: {light.Type}, Value: {light.Value}\");\n        Console.WriteLine($\"  Float Value: {light.f}\");\n    }\n\n    // V3 Light Color Event Box Groups\n    Console.WriteLine($\"\\nLight Color Event Box Groups: {diff.Data.lightColorEventBoxGroups.Count}\");\n    foreach (var group in diff.Data.lightColorEventBoxGroups.Take(5))\n    {\n        Console.WriteLine($\"Color group at {group.Beats:F2} beats, Group ID: {group.Group}\");\n        Console.WriteLine($\"  Event Boxes: {group.EventBoxGroup.Count}\");\n    }\n\n    // Rotation events\n    Console.WriteLine($\"\\nRotation Events: {diff.Data.Rotations.Count}\");\n    foreach (var rotation in diff.Data.Rotations.Take(5))\n    {\n        Console.WriteLine($\"Rotation at {rotation.Seconds:F3}s: {rotation.Rotation}\u00b0\");\n    }\n}\n```\n\n## Access Beatmap Note Timing and Spatial Data\n\n```csharp\nusing beatleader_parser;\nusing Parser.Map.Difficulty.V3.Grid;\n\nvar parser = new Parse();\nvar map = parser.TryLoadPath(\"/path/to/map\");\n\nif (map != null)\n{\n    var expertPlus = map.Difficulties.Find(d => d.Difficulty == \"ExpertPlus\");\n    if (expertPlus != null)\n    {\n        foreach (var note in expertPlus.Data.Notes)\n        {\n            // Timing information\n            Console.WriteLine($\"Note at beat {note.Beats:F2} ({note.Seconds:F3}s)\");\n\n            // Spatial data\n            Console.WriteLine($\"  Position: ({note.x}, {note.y})\");\n            Console.WriteLine($\"  Color: {(note.Color == 0 ? \"Red\" : note.Color == 1 ? \"Blue\" : \"Other\")}\");\n            Console.WriteLine($\"  Cut Direction: {(Note.Direction)note.CutDirection}\");\n            Console.WriteLine($\"  Angle Offset: {note.AngleOffset}\u00b0\");\n\n            // Custom data if present\n            if (note.customData?.coordinates != null)\n            {\n                Console.WriteLine($\"  Custom Position: ({note.customData.coordinates[0]}, {note.customData.coordinates[1]})\");\n            }\n        }\n    }\n}\n```\n\n## Accessing BPM Events in Beatleader Maps\n\n```csharp\nusing beatleader_parser;\n\nvar parser = new Parse();\nvar map = parser.TryLoadPath(\"/path/to/map\");\n\nif (map != null)\n{\n    var diff = map.Difficulties[0];\n\n    if (diff.Data.bpmEvents.Count > 0)\n    {\n        Console.WriteLine($\"BPM Changes: {diff.Data.bpmEvents.Count}\");\n\n        foreach (var bpmEvent in diff.Data.bpmEvents)\n        {\n            Console.WriteLine($\"BPM change at {bpmEvent.Seconds:F3}s (beat {bpmEvent.Beats:F2})\");\n            Console.WriteLine($\"  New BPM: {bpmEvent.Bpm:F2}\");\n            Console.WriteLine($\"  Start Time: {bpmEvent.BpmChangeStartTime:F3}s\");\n        }\n    }\n    else\n    {\n        Console.WriteLine($\"Single BPM: {map.Info._beatsPerMinute}\");\n    }\n}\n```\n\n## C# Beat Saber Map Format Conversion (V2 to V3)\n\n```csharp\nusing beatleader_parser;\nusing Parser.Map.Difficulty.V3.Base;\nusing Parser.Map.Difficulty.V2.Base;\n\n// V2 to V3 conversion (happens automatically during load)\nvar parser = new Parse();\nvar map = parser.TryLoadZip(memoryStream);\n\n// All difficulties are now in V3 format regardless of source\nif (map != null && map.Count > 0)\n{\n    foreach (var diff in map[0].Difficulties)\n    {\n        // Always V3 format\n        Console.WriteLine($\"Version: {diff.Data.Version}\");\n        Console.WriteLine($\"Notes: {diff.Data.Notes.Count}\");\n        Console.WriteLine($\"Bombs: {diff.Data.Bombs.Count}\");\n        Console.WriteLine($\"Arcs: {diff.Data.Arcs.Count}\");\n        Console.WriteLine($\"Chains: {diff.Data.Chains.Count}\");\n\n        // V3 features available\n        if (diff.Data.bpmEvents.Count > 0)\n        {\n            Console.WriteLine(\"Contains variable BPM\");\n        }\n        if (diff.Data.njsEvents.Count > 0)\n        {\n            Console.WriteLine(\"Contains variable NJS\");\n        }\n    }\n}\n```\n\n## Accessing Walls (Obstacles) in Beatleader Maps\n\n```csharp\nusing beatleader_parser;\n\nvar parser = new Parse();\nvar map = parser.TryLoadPath(\"/path/to/map\");\n\nif (map != null)\n{\n    var diff = map.Difficulties[0];\n\n    Console.WriteLine($\"Walls: {diff.Data.Walls.Count}\");\n\n    foreach (var wall in diff.Data.Walls)\n    {\n        Console.WriteLine($\"Wall at {wall.Seconds:F3}s (beat {wall.Beats:F2})\");\n        Console.WriteLine($\"  Position: ({wall.x}, {wall.y})\");\n        Console.WriteLine($\"  Size: {wall.Width}x{wall.Height}\");\n        Console.WriteLine($\"  Duration: {wall.DurationInSeconds:F3}s ({wall.DurationInBeats:F2} beats)\");\n        Console.WriteLine($\"  NJS: {wall.Njs:F2}\");\n    }\n}\n```\n\n## Load Single Beat Saber Difficulty from Path (C#)\n\n```csharp\nusing beatleader_parser;\n\nvar parser = new Parse();\nvar singleDiff = parser.TryLoadPath(\n    \"/path/to/beatmap/folder\",\n    characteristic: \"Standard\",\n    difficulty: \"ExpertPlus\"\n);\n\nif (singleDiff != null)\n{\n    var diff = singleDiff.Difficulty;\n    Console.WriteLine($\"Loaded {diff.Difficulty} - {diff.Characteristic}\");\n    Console.WriteLine($\"Notes: {diff.Data.Notes.Count}\");\n    Console.WriteLine($\"Max NJS: {diff.BeatMap._noteJumpMovementSpeed}\");\n\n    // Access timing information\n    foreach (var note in diff.Data.Notes.Take(5))\n    {\n        Console.WriteLine($\"Note at {note.Seconds:F3}s, beat {note.Beats:F2}, position ({note.x}, {note.y})\");\n    }\n}\n```\n\n## Loading Single Difficulty from File Path\n\n```APIDOC\n## Loading Single Difficulty from File Path\n\nLoad only a specific difficulty and characteristic from a map folder.\n\n### Method\n\nThis is a conceptual representation of the loading process. The actual implementation uses the `Parse.TryLoadPath` method with optional `characteristic` and `difficulty` parameters from the `beatleader_parser` library.\n\n### Endpoint\n\nN/A (This is a library function, not a web endpoint.)\n\n### Parameters\n\nN/A\n\n### Request Example\n\n```csharp\nusing beatleader_parser;\n\nvar parser = new Parse();\nvar singleDiff = parser.TryLoadPath(\n    \"/path/to/beatmap/folder\",\n    characteristic: \"Standard\",\n    difficulty: \"ExpertPlus\"\n);\n\nif (singleDiff != null)\n{\n    var diff = singleDiff.Difficulty;\n    Console.WriteLine($\"Loaded {diff.Difficulty} - {diff.Characteristic}\");\n    Console.WriteLine($\"Notes: {diff.Data.Notes.Count}\");\n    Console.WriteLine($\"Max NJS: {diff.BeatMap._noteJumpMovementSpeed}\");\n\n    // Access timing information\n    foreach (var note in diff.Data.Notes.Take(5))\n    {\n        Console.WriteLine($\"Note at {note.Seconds:F3}s, beat {note.Beats:F2}, position ({note.x}, {note.y})\");\n    }\n}\n```\n\n### Response\n\n#### Success Response (Object)\n\nReturns a `Beatmap` object containing only the specified difficulty, or `null` if loading fails.\n\n- **singleDiff** (Beatmap) - The loaded `Beatmap` object with a single difficulty.\n\n#### Response Example\n\n```json\n{\n  \"Info\": {\n    \"_songName\": \"Song Name\",\n    \"_songAuthorName\": \"Song Author\",\n    \"_levelAuthorName\": \"Mapper Name\",\n    \"_beatsPerMinute\": 120,\n    \"_duration\": 180.5\n  },\n  \"SongLength\": 180.5,\n  \"Difficulties\": [\n    {\n      \"Characteristic\": \"Standard\",\n      \"Difficulty\": \"ExpertPlus\",\n      \"Data\": {\n        \"Notes\": [...],\n        \"Bombs\": [...],\n        \"Walls\": [...] \n      },\n      \"BeatMap\": {\n         \"_noteJumpMovementSpeed\": 15\n      }\n    }\n  ]\n}\n```\n\n#### Error Response (Null)\n\nReturns `null` if the specified path, characteristic, or difficulty is invalid, or if the beatmap files cannot be parsed.\n```\n\n## Calculate Maximum Score for a Difficulty\n\n```csharp\nusing Parser.Utils;\nusing beatleader_parser;\n\nvar parser = new Parse();\nvar map = parser.TryLoadPath(\"/path/to/map\");\n\nif (map != null)\n{\n    foreach (var diff in map.Difficulties)\n    {\n        int maxScore = diff.MaxScore();\n        Console.WriteLine($\"{diff.Difficulty}: Max Score = {maxScore:N0}\");\n\n        // Get score graph over time\n        var scoreGraph = diff.MaxScoreGraph();\n        Console.WriteLine($\"  Score progression points: {scoreGraph.Count}\");\n\n        // Show score at specific timestamps\n        foreach (var (time, score) in scoreGraph.Where((_, i) => i % 100 == 0))\n        {\n            Console.WriteLine($\"    At {time:F2}s: {score:N0}\");\n        }\n    }\n}\n```",
    "library": "parser",
    "topic": "common-mistakes",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T16:10:24.246846"
}