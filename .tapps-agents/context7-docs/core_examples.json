{
  "library": "core",
  "topic": "examples",
  "documentation": {
    "content": "## Development Tools and Linters\n\n```text\nmypy\npytest\npytest-cov\nblack\nflake8\nisort\nautoflake\ntyper\nmathy_pydoc\n```\n\n## Example Usage: Build and Initialize Model (Python)\n\n```python\ntext, X, Y = to_example(\"14x + 2y - 3x + 7x\")\nm = build_model(12)\nm.initialize([X], m.ops.asarray(Y, dtype=\"f\"))\nmY = m.predict([X])\nprint(mY.shape)\nassert mY.shape == (1, 1)\n```\n\n## Pinning mathy_core version for stability\n\n```bash\nmathy_core>=0.1.37,<0.2.0\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.add_class(\n    self,\n    classes: Union[List[str], str],\n) -> 'MathExpression'\n\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.all_changed(self) -> None\n\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.clear_classes(self) -> None\n\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.clone(self) -> 'MathExpression'\n\n```\n\n## BinaryExpression Methods\n\n```python\nBinaryExpression.get_priority(self) -> int\n\n```\n\n## BinaryExpression Methods\n\n```python\nBinaryExpression.to_math_ml_fragment(self) -> str\n\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.add_class(\n    self,\n    classes: Union[List[str], str],\n) -> 'MathExpression'\n\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.all_changed(self) -> None\n\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.clear_classes(self) -> None\n\n```\n\n## MathExpression Methods\n\n```python\nMathExpression.clone(self) -> 'MathExpression'\n\n```\n\n## BinaryExpression Methods\n\n```python\nBinaryExpression.get_priority(self) -> int\n\n```\n\n## BinaryExpression Methods\n\n```python\nBinaryExpression.to_math_ml_fragment(self) -> str\n\n```\n\n## TokenSet Class and Methods\n\n```python\nTokenSet(self, source: int)\n\nAdd tokens to self set and return a TokenSet representing\ntheir combination of flags. Value can be an integer or an instance\nof `TokenSet`\n\nTokenSet.add(self, addTokens: int) -> 'TokenSet'\n\nReturns true if the given type is part of this set\n\nTokenSet.contains(self, type: int) -> bool\n```\n\n## Development setup and testing\n\n```bash\nsh tools/setup.sh\n```\n\n## Development setup and testing\n\n```bash\nsh tools/test.sh\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode(\n    self: ~NodeType,\n    left: Optional[~NodeType] = None,\n    right: Optional[~NodeType] = None,\n    parent: Optional[~NodeType] = None,\n    id: Optional[str] = None,\n)\nThe binary tree node is the base node for all of our trees, and provides a\nrich set of methods for constructing, inspecting, and modifying them.\nThe node itself defines the structure of the binary tree, having left and right\nchildren, and a parent.\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.clone(self: ~NodeType) -> ~NodeType\nCreate a clone of this tree\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.get_children(self: ~NodeType) -> List[~NodeType]\nGet children as an array. If there are two children, the first object will\nalways represent the left child, and the second will represent the right.\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.get_root(self: ~NodeType) -> ~NodeType\nReturn the root element of this tree\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.get_root_side(self: ~NodeType) -> Literal['left', 'right']\nReturn the side of the tree that this node lives on\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.get_sibling(self: ~NodeType) -> Optional[~NodeType]\nGet the sibling node of this node. If there is no parent, or the node\nhas no sibling, the return value will be None.\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.get_side(\n    self,\n    child: Optional[~NodeType],\n) -> Literal['left', 'right']\nDetermine whether the given `child` is the left or right child of this\nnode\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.is_leaf(self) -> bool\nIs this node a leaf? A node is a leaf if it has no children.\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.rotate(self: ~NodeType) -> ~NodeType\nRotate a node, changing the structure of the tree, without modifying\nthe order of the nodes in the tree.\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.set_left(\n    self: ~NodeType,\n    child: Optional[~NodeType] = None,\n    clear_old_child_parent: bool = False,\n) -> ~NodeType\nSet the left node to the passed `child`\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.set_right(\n    self: ~NodeType,\n    child: Optional[~NodeType] = None,\n    clear_old_child_parent: bool = False,\n) -> ~NodeType\nSet the right node to the passed `child`\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.set_side(\n    self,\n    child: ~NodeType,\n    side: Literal['left', 'right'],\n) -> ~NodeType\nSet a new `child` on the given `side`\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.visit_inorder(\n    self,\n    visit_fn: Callable[[Any, int, Optional[Any]], Optional[Literal['stop']]],\n    depth: int = 0,\n    data: Optional[Any] = None,\n) -> Optional[Literal['stop']]\nVisit the tree inorder, which visits the left child, then the current node,\nand then its right child.\n\n_Left -> Visit -> Right_\n\nThis method accepts a function that will be invoked for each node in the\ntree. The callback function is passed three arguments: the node being\nvisited, the current depth in the tree, and a user specified data parameter.\n\n!!! info\n\n    Traversals may be canceled by returning `STOP` from any visit function.\n```\n\n## BinaryTreeNode Class and Methods\n\n```python\nBinaryTreeNode.visit_postorder(\n    self,\n    visit_fn: Callable[[Any, int, Optional[Any]], Optional[Literal['stop']]],\n    depth: int = 0,\n    data: Optional[Any] = None,\n) -> Optional[Literal['stop']]\nVisit the tree postorder, which visits its left child, then its right child,\nand finally the current node.\n\n_Left -> Right -> Visit_\n\nThis method accepts a function that will be invoked for each node in the\ntree. The callback function is passed three arguments: the node being\nvisited, the current depth in the tree, and a user specified data parameter.\n\n!!! info\n\n    Traversals may be canceled by returning `STOP` from any visit function.\n```",
    "library": "core",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-06T14:22:38.243999"
}