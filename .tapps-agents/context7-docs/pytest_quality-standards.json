{
  "library": "pytest",
  "topic": "quality-standards",
  "documentation": {
    "content": "## Enhanced Pytest Approx Readability\n\n```python\nimport pytest\n\n# Previous output example for pytest.approx(42, abs=1)\n# 42 \u00b1 1.0e+00\n\n# Current output example for pytest.approx(42, abs=1)\nprint(pytest.approx(42, abs=1)) # Output: 42 \u00b1 1\n```\n\n## Customizing Tolerances in approx\n\n```python\nfrom pytest import approx\n\n# Example 1: Default comparison fails\n1.0001 == approx(1)\n\n# Example 2: Using relative tolerance\n1.0001 == approx(1, rel=1e-3)\n\n# Example 3: Using absolute tolerance\n1.0001 == approx(1, abs=1e-3)\n\n# Example 4: Using both relative and absolute tolerances\n1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n```\n\n## approx with custom relative and absolute tolerances\n\n```python\nfrom pytest import approx\n\nassert 1.0001 == approx(1, rel=1e-3)\nassert 1.0001 == approx(1, abs=1e-3)\n```\n\n## approx with custom relative and absolute tolerances\n\n```python\nfrom pytest import approx\n\nassert 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n```\n\n## unittest.TestCase.assertAlmostEqual (Python)\n\n```python\nimport unittest\n\nclass MyTests(unittest.TestCase):\n    def test_almost_equal(self):\n        self.assertAlmostEqual(0.1 + 0.2, 0.3)\n        self.assertAlmostEqual(1000.0, 1000.00000001)\n\n# Note: This example requires a test runner to execute.\n```\n\n## Pytest: Improved Object Comparison on Assertion Failure\n\n```python\ndef test_list_comparison():\n    expected = [1, 2, 3]\n    actual = [1, 5, 3] # Difference at index 1\n    assert expected == actual # Pytest will show detailed diff\n```\n\n## Constants\n\n```APIDOC\n## Constants\n\n### Constant: HIDDEN_PARAM\n\n#### Description\nA sentinel value (`_HiddenParam.token`) that can be used as a parameter set ID to hide it from the test name.\n\n```\n\n## Validate Required Plugins\n\n```python\ndef _validate_plugins(self) -> None:\n        required_plugins = sorted(self.getini(\"required_plugins\"))\n        if not required_plugins:\n            return\n\n        # Imported lazily to improve start-up time.\n        from packaging.requirements import InvalidRequirement\n        from packaging.requirements import Requirement\n        from packaging.version import Version\n\n        plugin_info = self.pluginmanager.list_plugin_distinfo()\n        plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n\n        missing_plugins = []\n        for required_plugin in required_plugins:\n            try:\n                req = Requirement(required_plugin)\n            except InvalidRequirement:\n                missing_plugins.append(required_plugin)\n                continue\n\n            if req.name not in plugin_dist_info:\n                missing_plugins.append(required_plugin)\n            elif not req.specifier.contains(\n                Version(plugin_dist_info[req.name]), prereleases=True\n            ):\n                missing_plugins.append(required_plugin)\n\n        if missing_plugins:\n            raise UsageError(\n                \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),\n            )\n```\n\n## Nested Parametrize-Value Markers\n\n```python\nimport pytest\n\n@pytest.mark.parametrize(\"a\", [1, 2])\n@pytest.mark.parametrize(\"b\", [3, 4])\ndef test_nested_parametrize(a, b):\n    assert isinstance(a, int)\n    assert isinstance(b, int)\n\n# This allows combining multiple parametrize markers on a single test function,\n# creating a Cartesian product of the parameter values.\n```\n\n## ApproxDecimal Class Definition\n\n```python\nclass ApproxDecimal(ApproxScalar):\n    \"\"\"Perform approximate comparisons where the expected value is a Decimal.\"\"\"\n\n    DEFAULT_ABSOLUTE_TOLERANCE = Decimal(\"1e-12\")\n    DEFAULT_RELATIVE_TOLERANCE = Decimal(\"1e-6\")\n\n    def __repr__(self) -> str:\n        if isinstance(self.rel, float):\n            rel = Decimal.from_float(self.rel)\n        else:\n            rel = self.rel\n\n        if isinstance(self.abs, float):\n            abs_ = Decimal.from_float(self.abs)\n        else:\n            abs_ = self.abs\n\n        tol_str = \"???\"\n        if rel is not None and Decimal(\"1e-3\") <= rel <= Decimal(\"1e3\"):\n            tol_str = f\"{rel:.1e}\"\n        elif abs_ is not None:\n            tol_str = f\"{abs_:.1e}\"\n\n        return f\"{self.expected} \u00b1 {tol_str}\"\n\n```\n\n## Yielding Comparisons in Pytest Approx\n\n```python\n    def _yield_comparisons(self, actual):\n        return zip(actual, self.expected, strict=True)\n```\n",
    "library": "pytest",
    "topic": "quality-standards",
    "source": "api"
  },
  "source": "api",
  "saved_at": "2026-02-06T15:04:04.313037"
}