{
  "library": "pytest",
  "topic": "quality-standards",
  "documentation": {
    "content": "## Define a Simple Pytest Fixture and Test\n\n```python\nimport pytest\n\n\nclass Fruit:\n    def __init__(self, name):\n        self.name = name\n\n    def __eq__(self, other):\n        return self.name == other.name\n\n\n@pytest.pytest.fixture\ndef my_fruit():\n    return Fruit(\"apple\")\n\n\n@pytest.pytest.fixture\ndef fruit_basket(my_fruit):\n    return [Fruit(\"banana\"), my_fruit]\n\n\ndef test_my_fruit_in_basket(my_fruit, fruit_basket):\n    assert my_fruit in fruit_basket\n\n```\n\n## Pytest Fixture: Fixtures Requesting Other Fixtures\n\n```python\n# contents of test_append.py\nimport pytest\n\n\n# Arrange\n@pytest.fixture\ndef first_entry():\n    return \"a\"\n\n\n# Arrange\n@pytest.fixture\ndef order(first_entry):\n    return [first_entry]\n\n\ndef test_string(order):\n    # Act\n    order.append(\"b\")\n\n    # Assert\n    assert order == [\"a\", \"b\"]\n\n```\n\n## Pytest Fixture Modularity and Dependency (Python)\n\n```python\nimport pytest\n\n\nclass App:\n    def __init__(self, smtp_connection):\n        self.smtp_connection = smtp_connection\n\n\n@pytest.fixture(scope=\"module\")\ndef app(smtp_connection):\n    return App(smtp_connection)\n\ndef test_smtp_connection_exists(app):\n    assert app.smtp_connection\n\n```\n\n## SubRequest for Fixtures\n\n```python\n@final\nclass SubRequest(FixtureRequest):\n    \"\"\"The type of the ``request`` fixture in a fixture function requested\n    (transitively) by a test function.\"\"\"\n\n    def __init__(\n        self,\n        request: FixtureRequest,\n        scope: Scope,\n        param: Any,\n        param_index: int,\n        fixturedef: FixtureDef[object],\n        *,  # Keep for forward compatibility\n        _ispytest: bool = False,\n    ) -> None:\n        super().__init__(\n            pyfuncitem=request._pyfuncitem,\n            fixturename=fixturedef.argname,\n            fixture_defs=request._fixture_defs,\n            arg2fixturedefs=request._arg2fixturedefs,\n            _ispytest=_ispytest,\n        )\n        self._parent_request: Final[FixtureRequest] = request\n        self._scope_field: Final = scope\n        self._fixturedef: Final[FixtureDef[object]] = fixturedef\n        if param is not NOTSET:\n            self.param = param\n        self.param_index: Final = param_index\n\n    def __repr__(self) -> str:\n        return f\"<SubRequest {self.fixturename!r} for {self._pyfuncitem!r}>\"\n\n    @property\n    def _scope(self) -> Scope:\n        return self._scope_field\n\n    @property\n    def node:\n        scope = self._scope\n        if scope is Scope.Function:\n            # This might also be a non-function Item despite its attribute name.\n            node: nodes.Node | None = self._pyfuncitem\n        elif scope is Scope.Package:\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope is Scope.Class:\n            # Fallback to function item itself.\n            node = self._pyfuncitem\n        assert node, (\n            f'Could not obtain a node for scope \"{scope}\" for function {self._pyfuncitem!r}'\n        )\n        return node\n\n    def _check_scope(\n        self,\n        requested_fixturedef: FixtureDef[object] | PseudoFixtureDef[object],\n        requested_scope: Scope,\n    ) -> None:\n        if isinstance(requested_fixturedef, PseudoFixtureDef):\n            return\n        if self._scope > requested_scope:\n            # Try to report something helpful.\n            argname = requested_fixturedef.argname\n            fixture_stack = \"\\n\".join(\n                self._format_fixturedef_line(fixturedef)\n                for fixturedef in self._get_fixturestack()\n            )\n            requested_fixture = self._format_fixturedef_line(requested_fixturedef)\n            fail(\n                f\"ScopeMismatch: You tried to access the {requested_scope.value} scoped \"\n            )\n```\n\n## Pytest Fixture: Requesting Multiple Fixtures (Python)\n\n```python\n# contents of test_append.py\nimport pytest\n\n\n# Arrange\n@pytest.fixture\ndef first_entry():\n    return \"a\"\n\n\n# Arrange\n@pytest.fixture\ndef second_entry():\n    return 2\n\n\n# Arrange\n@pytest.fixture\ndef order(first_entry, second_entry):\n    return [first_entry, second_entry]\n\n\n# Arrange\n@pytest.fixture\ndef expected_list():\n    return [\"a\", 2, 3.0]\n\n\ndef test_string(order, expected_list):\n    # Act\n    order.append(3.0)\n\n    # Assert\n    assert order == expected_list\n\n```\n\n## Pytest Command-Line Options for Fixture Information\n\n```python\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.main import Config\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"usefixtures\",\n        type=\"args\",\n        default=[],\n        help=\"List of default fixtures to be used with this project\",\n    )\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--fixtures\",\n        \"--funcargs\",\n        action=\"store_true\",\n        dest=\"showfixtures\",\n        default=False,\n        help=\"Show available fixtures, sorted by plugin appearance \"\n        \"(fixtures with leading '_' are only shown with '-v')\",\n    )\n    group.addoption(\n        \"--fixtures-per-test\",\n        action=\"store_true\",\n        dest=\"show_fixtures_per_test\",\n        default=False,\n        help=\"Show fixtures per test\",\n    )\n\n```\n\n## Pytest Fixture Dependency Closure Calculation (Python)\n\n```python\ndef getfixtureclosure(\n    self,\n    parentnode: nodes.Node,\n    initialnames: tuple[str, ...],\n    ignore_args: AbstractSet[str],\n) -> tuple[list[str], dict[str, Sequence[FixtureDef[Any]]]]:\n    # Collect the closure of all fixtures, starting with the given\n    # fixturenames as the initial set.  As we have to visit all\n    # factory definitions anyway, we also return an arg2fixturedefs\n    # mapping so that the caller can reuse it and does not have\n    # to re-discover fixturedefs again for each fixturename\n    # (discovering matching fixtures for a given name/node is expensive).\n\n    fixturenames_closure = list(initialnames)\n\n    arg2fixturedefs: dict[str, Sequence[FixtureDef[Any]]] = {}\n    lastlen = -1\n    while lastlen != len(fixturenames_closure):\n        lastlen = len(fixturenames_closure)\n        for argname in fixturenames_closure:\n\n```\n\n## Pytest Fixture Declaration and Usage\n\n```python\nimport pytest\n\n# Example test function requesting a built-in fixture 'capsys'\ndef test_output_capture(capsys):\n    print(\"hello\")\n    out, err = capsys.readouterr()\n    assert out == \"hello\\n\"\n\n# Example of a fixture requiring another fixture 'tmp_path'\n@pytest.fixture\ndef db_session(tmp_path):\n    db_file = tmp_path / \"db.file\"\n    # Assume connect is a function that sets up a database connection\n    # connection = connect(db_file)\n    # return connection\n    print(f\"Database file created at: {db_file}\")\n    return \"mock_db_connection\"\n\n# Example test function requesting the custom fixture 'db_session'\ndef test_database_operation(db_session):\n    # Use the db_session fixture here\n    assert db_session == \"mock_db_connection\"\n\n```\n\n## Pytest: Multiple Fixtures and Module-Level usefixtures\n\n```python\nimport pytest\n\n# Example of applying multiple fixtures\n@pytest.mark.usefixtures(\"cleandir\", \"anotherfixture\")\ndef test_with_multiple_fixtures():\n    assert True\n\n# Example of module-level fixture application\npytestmark = pytest.mark.usefixtures(\"cleandir\")\ndef test_module_level_fixture():\n    assert True\n```\n\n## Pytest Fixture Type Definitions (Python)\n\n```python\n# The value of the fixture -- return/yield of the fixture function (type variable).\nFixtureValue = TypeVar(\"FixtureValue\")\n# The type of the fixture function (type variable).\nFixtureFunction = TypeVar(\"FixtureFunction\", bound=Callable[..., object])\n# The type of a fixture function (type alias generic in fixture value).\n_FixtureFunc = Union[\n    Callable[..., FixtureValue], Callable[..., Generator[FixtureValue]]\n]\n```",
    "library": "pytest",
    "topic": "fixtures",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-24T12:19:36.912927"
}