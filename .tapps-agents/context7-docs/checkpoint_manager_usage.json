{
  "library": "checkpoint_manager",
  "topic": "usage",
  "documentation": {
    "content": "## Rust: Injecting Raw JavaScript Expressions with `@{expr}`\n\n```rust\nuse viewpoint_js::js;\n\n// Inject a JavaScript expression as-is\nlet selector_expr = \"document.querySelectorAll('.item')\";\nlet code = js!{ Array.from(@{selector_expr}) };\n// Produces: \"Array.from(document.querySelectorAll('.item'))\"\n\n// Useful for building complex JS with dynamic parts\nlet frame_access = get_frame_access_code();\nlet code = js!{\n    (function() {\n        const doc = @{frame_access};\n        return doc.title;\n    })()\n};\n```\n\n## Rust: Convert to JavaScript Values and Escape Strings\n\n```rust\nuse viewpoint_js_core::{ToJsValue, escape_js_string};\n\n// Convert Rust values to JavaScript representation\nassert_eq!(42.to_js_value(), \"42\");\nassert_eq!(true.to_js_value(), \"true\");\nassert_eq!(\"hello\".to_js_value(), r#\"\"hello\"\"#);\n\n// Escape a string for JavaScript\nassert_eq!(escape_js_string(\"line1\\nline2\"), r#\"\"line1\\nline2\"\"#);\n```\n\n## Rust: Simple JavaScript Expressions with `js!` Macro\n\n```rust\nuse viewpoint_js::js;\n\n// Returns &'static str\nlet code = js!{ 1 + 2 };\nlet code = js!{ () => window.innerWidth };\nlet code = js!{\n    (() => {\n        const items = document.querySelectorAll('li');\n        return items.length;\n    })()\n};\n```\n\n## Rust: Launch Browser, Navigate, and Interact with Elements\n\n```rust\nuse viewpoint_core::{Browser, DocumentLoadState};\n\n// Launch browser\nlet browser = Browser::launch().headless(true).launch().await?;\nlet context = browser.new_context().await?;\nlet page = context.new_page().await?;\n\n// Navigate\npage.goto(\"https://example.com\")\n    .wait_until(DocumentLoadState::DomContentLoaded)\n    .goto()\n    .await?;\n\n// Locate and interact with elements\nlet button = page.locator(\"button.submit\");\nbutton.click().await?;\n```\n\n## Rust: Compile-time Validated JavaScript with `js!` Macro\n\n```rust\nuse viewpoint_js::js;\n\n// Simple expression (returns &'static str)\nlet code = js!{ document.title };\n\n// Single-quoted strings\nlet code = js!{ console.log('hello') };\n\n// Template literals with JS interpolation (${} is preserved)\nlet code = js!{ `Hello, ${userName}!` };\n\n// Template literals with Rust interpolation\nlet name = \"world\";\nlet code = js!{ `Hello, #{name}!` };\n\n// Regex literals\nlet code = js!{ /^test/.test(str) };\n\n// XPath with mixed quotes\nlet code = js!{ document.evaluate(\"//div[@class='item']\", doc) };\n\n// Value interpolation - Rust values are quoted/escaped\nlet selector = \".my-class\";\nlet code = js!{ document.querySelector(#{selector}) };\n\n// Raw interpolation - inject JS expression as-is\nlet selector_expr = \"document.body\";\nlet code = js!{ @{selector_expr}.getAttribute(\"id\") };\n\n// Multi-line with both interpolation types\nlet js_fn = some_js_function();\nlet attr = \"data-id\";\nlet code = js!{\n    (function() {\n        const fn = @{js_fn};\n        return fn(document).getAttribute(#{attr});\n    })()\n};\n\n```\n\n## Page Drag and Drop Helper\n\n```typescript\npage.drag_and_drop(\"#source\", \"#target\").await\n```\n\n## Save and Reuse Authentication State\n\n```rust\n# Save state\ncontext.storage_state().path(\"auth.json\").await;\n\n# Reuse state in a new test\nbrowser.new_context().storage_state(\"auth.json\").build().await;\n```\n\n## Basic Test with #[viewpoint_test::test]\n\n```rust\nuse viewpoint_test::{test, Page, expect};\n\n#[viewpoint_test::test]\nasync fn my_test(page: &Page) -> Result<(), Box<dyn std::error::Error>> {\n    page.goto(\"https://example.com\").goto().await?;\n    \n    let heading = page.locator(\"h1\");\n    expect(&heading).to_be_visible().await?;\n    \n    Ok(())\n}\n```\n\n## Manage Context Ownership and Disposal\n\n```Rust\nuse chromium::browser::Browser;\n\n// Assuming 'browser' is a connected Browser instance\nlet new_context = browser.new_context().await;\n// ... perform operations with new_context ...\n\n// Close and dispose the owned context\nnew_context.close().await;\n```\n\n## Basic TestHarness Setup and Usage (Rust)\n\n```rust\nuse viewpoint::TestHarness;\n\n#[tokio::test]\nasync fn basic_test() -> anyhow::Result<()> {\n    let harness = TestHarness::new().await?;\n    let page = harness.page();\n    // Interact with the page\n    assert!(page.get_by_text(\"Example Text\").is_some());\n    // Harness is automatically dropped here, cleaning up resources\n    Ok(())\n}\n```\n",
    "library": "checkpoint_manager",
    "topic": "usage",
    "source": "api"
  },
  "source": "api",
  "saved_at": "2026-01-30T16:09:44.241665"
}