{
  "library": "story",
  "topic": null,
  "documentation": {
    "content": "## Pure Function Example (Ruby)\n\n```ruby\nclass Calculator\n\tdef add(a, b)\n\t\ta + b  # No instance state, pure computation\n\tend\nend\n```\n\n## Stateful Iteration Example (Ruby)\n\n```ruby\nclass Reader\n\tASYNC_SAFE = false  # Enable tracking\n\t\n\tdef initialize(data)\n\t\t@data = data\n\t\t@index = 0\n\tend\n\t\n\tdef read\n\t\tvalue = @data[@index]\n\t\t@index += 1  # Mutates state\n\t\tvalue\n\tend\nend\n```\n\n## Handling ViolationError Exceptions in Ruby\n\n```ruby\nrequire 'async/safe'\nrequire 'async'\n\nclass UnsafeCounter\n  ASYNC_SAFE = false\n\n  def initialize\n    @count = 0\n  end\n\n  def slow_increment\n    @count += 1\n    sleep 0.1  # Simulate work\n    @count\n  end\nend\n\nAsync::Safe.enable!\n\ncounter = UnsafeCounter.new\n\nbegin\n  Async do |task|\n    # Start first fiber\n    task.async do\n      counter.slow_increment  # Takes 0.1 seconds\n    end\n\n    # Start second fiber while first is still running\n    task.async do\n      sleep 0.05  # Wait for first to start\n      counter.slow_increment  # Concurrent access detected!\n    end.wait\n  end\nrescue Async::Safe::ViolationError => e\n  puts \"Violation detected!\"\n  puts \"Message: #{e.message}\"\n  # => \"Thread safety violation detected!\"\n  # => \"Object: #<UnsafeCounter:0x...>#slow_increment\"\n  # => \"Owner: #<Fiber:0x...>\"\n  # => \"Accessed by: #<Fiber:0x...>\"\n\n  # Access error details\n  puts \"Method: #{e.method}\"\n  puts \"Owner fiber: #{e.owner.inspect}\"\n  puts \"Current fiber: #{e.current.inspect}\"\n\n  # Get JSON representation\n  error_data = e.as_json\n  # => {:object_class=>..., :method=>:slow_increment,\n  #     :owner=>{:name=>\"...\", :backtrace=>[...]},\n  #     :current=>{:name=>\"...\", :backtrace=>[...]}}\nend\n\nAsync::Safe.disable!\n```\n\n## Immutable Object Example (Ruby)\n\n```ruby\nclass ImmutableUser\n\tdef initialize(name, email)\n\t\t@name = name.freeze\n\t\t@email = email.freeze\n\t\tfreeze  # Entire object is frozen\n\tend\n\t\n\tattr_reader :name, :email\nend\n```\n\n## Sequential Access Allowed\n\n```ruby\nAsync::Safe.enable!\n\nrequest = Request.new(\"http://example.com\")\nrequest.process  # Main fiber\n\nFiber.new do\n\t# No problem - sequential access is allowed\n\trequest.process  # \u2705 OK\nend.resume\n\n```\n\n## Guard-Based Concurrency in Ruby with Async::Safe\n\n```ruby\nrequire 'async/safe'\nrequire 'async'\n\n# Stream with independent read/write operations\nclass Stream\n  def self.async_safe?(method)\n    case method\n    when :read then :readable   # Read guard\n    when :write then :writable  # Write guard\n    else false                   # Other methods tracked with single guard\n    end\n  end\n\n  def initialize\n    @read_buffer = []\n    @write_buffer = []\n  end\n\n  def read\n    # Can run concurrently with write (different guards)\n    @read_buffer.shift\n  end\n\n  def write(data)\n    # Can run concurrently with read (different guards)\n    @write_buffer.push(data)\n  end\n\n  def close\n    # Cannot run concurrently with anything (single-guard tracking)\n    @read_buffer.clear\n    @write_buffer.clear\n  end\nend\n\nAsync::Safe.enable!\n\nstream = Stream.new\n\nAsync do |task|\n  # These CAN run concurrently - different guards\n  reader = task.async do\n    sleep 0.05\n    stream.read  # :readable guard\n  end\n\n  writer = task.async do\n    stream.write(\"data\")  # :writable guard - OK, different guard\n  end\n\n  reader.wait\n  writer.wait\nend\n\n# These CANNOT run concurrently - same guard\nAsync do |task|\n  task.async { stream.read }  # :readable guard\n  task.async do\n    sleep 0.05\n    stream.read  # :readable guard - ViolationError if overlapping!\n  end.wait\nend\n\nAsync::Safe.disable!\n```\n\n## Mutable Instance State Example (Ruby)\n\n```ruby\nclass Counter\n\tASYNC_SAFE = false  # Enable tracking\n\t\n\tdef initialize\n\t\t@count = 0\n\tend\n\t\n\tdef increment\n\t\t@count += 1  # Reads and writes @count (race condition!)\n\tend\nend\n```\n\n## Sequential vs Concurrent Access in Ruby with Async::Safe\n\n```ruby\nrequire 'async/safe'\nrequire 'async'\n\nclass Document\n  ASYNC_SAFE = false\n\n  def initialize(content)\n    @content = content\n    @position = 0\n  end\n\n  def read_chunk\n    chunk = @content[@position, 10]\n    @position += 10\n    chunk\n  end\nend\n\nAsync::Safe.enable!\n\ndoc = Document.new(\"Hello World\" * 100)\n\n# \u2705 Sequential access - ALLOWED\ndoc.read_chunk  # Main fiber reads\n\nFiber.new do\n  doc.read_chunk  # Different fiber reads after main completes - OK\nend.resume\n\ndoc.read_chunk  # Main fiber reads again - OK\n```\n\n## Mark Class as Single-Owner with ASYNC_SAFE Constant\n\n```ruby\nrequire 'async/safe'\n\n# Mark entire class as single-owner\nclass MyBody\n  ASYNC_SAFE = false  # Enable tracking for this class\n\n  def initialize(chunks)\n    @chunks = chunks\n    @index = 0\n  end\n\n  def read\n    chunk = @chunks[@index]\n    @index += 1\n    chunk\n  end\nend\n\nAsync::Safe.enable!\n\nbody = MyBody.new([\"chunk1\", \"chunk2\", \"chunk3\"])\nbody.read  # Main fiber - OK\n\n# Sequential access across fibers is allowed\nFiber.new do\n  body.read  # Different fiber - OK, sequential access\nend.resume\n\n# Concurrent access will raise ViolationError\nrequire 'async'\nAsync do |task|\n  task.async { body.read }  # Fiber A starts reading\n  task.async { body.read }  # Fiber B tries concurrently - ViolationError!\nend\n```\n\n## Enable Global Monitoring in Ruby\n\n```ruby\nrequire 'async/safe'\n\n# Enable monitoring\nAsync::Safe.enable!\n\n# Your concurrent code here...\n\n```",
    "library": "safety",
    "topic": "overview",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-05T14:47:16.135268"
}