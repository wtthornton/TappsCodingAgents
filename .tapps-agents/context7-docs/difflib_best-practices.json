{
  "library": "difflib",
  "topic": "best-practices",
  "documentation": {
    "content": "## View imglab help\n\n```bash\nimglab -h\n```\n\n## SVM Model Selection with Cross-Validation in C++\n\n```cpp\n#include <dlib/svm.h>\n#include <dlib/global_optimization.h>\n#include <iostream>\n\nusing namespace dlib;\n\nint main() {\n    typedef matrix<double, 2, 1> sample_type;\n\n    // Generate training data\n    std::vector<sample_type> samples;\n    std::vector<double> labels;\n\n    for (double r = -20; r <= 20; r += 0.8) {\n        for (double c = -20; c <= 20; c += 0.8) {\n            sample_type samp;\n            samp(0) = r;\n            samp(1) = c;\n            samples.push_back(samp);\n            labels.push_back(sqrt(r*r + c*c) <= 10 ? +1 : -1);\n        }\n    }\n\n    // Normalize and randomize\n    vector_normalizer<sample_type> normalizer;\n    normalizer.train(samples);\n    for (auto& s : samples)\n        s = normalizer(s);\n    randomize_samples(samples, labels);\n\n    // Define cross-validation function\n    auto cross_validation_score = [&](const double gamma, const double c1,\n                                       const double c2) {\n        typedef radial_basis_kernel<sample_type> kernel_type;\n        svm_c_trainer<kernel_type> trainer;\n        trainer.set_kernel(kernel_type(gamma));\n        trainer.set_c_class1(c1);\n        trainer.set_c_class2(c2);\n\n        // 10-fold cross validation\n        matrix<double> result = cross_validate_trainer(trainer, samples, labels, 10);\n        std::cout << \"gamma: \" << gamma << \" c1: \" << c1 << \" c2: \" << c2\n                  << \" accuracy: \" << result;\n\n        // Return harmonic mean of class accuracies\n        return 2*prod(result)/sum(result);\n    };\n\n    // Grid search for best parameters\n    double best_gamma = 0, best_c1 = 0, best_c2 = 0;\n    double best_score = 0;\n\n    for (double gamma = 0.00001; gamma <= 1; gamma *= 5) {\n        for (double c = 0.1; c <= 100; c *= 5) {\n            double score = cross_validation_score(gamma, c, c);\n            if (score > best_score) {\n                best_score = score;\n                best_gamma = gamma;\n                best_c1 = best_c2 = c;\n            }\n        }\n    }\n\n    std::cout << \"\\nBest parameters: gamma=\" << best_gamma\n              << \" c=\" << best_c1 << \" score=\" << best_score << std::endl;\n\n    return 0;\n}\n\n```\n\n## C++ Serialization of Machine Learning Models with Dlib\n\n```cpp\n#include <dlib/serialize.h>\n#include <dlib/svm.h>\n#include <dlib/dnn.h>\n#include <iostream>\n#include <fstream>\n\nusing namespace dlib;\n\nint main() {\n    // Save/load SVM model\n    typedef matrix<double, 2, 1> sample_type;\n    typedef radial_basis_kernel<sample_type> kernel_type;\n    typedef decision_function<kernel_type> dec_func;\n\n    dec_func svm_model;\n    // ... train svm_model ...\n\n    // Save to file\n    serialize(\"svm_model.dat\") << svm_model;\n\n    // Load from file\n    dec_func loaded_svm;\n    deserialize(\"svm_model.dat\") >> loaded_svm;\n\n    // Save/load neural network\n    using net_type = loss_multiclass_log<fc<10,input<matrix<float>>>>;\n    net_type net;\n    // ... train net ...\n\n    net.clean();  // Remove transient state\n    serialize(\"neural_net.dat\") << net;\n\n    net_type loaded_net;\n    deserialize(\"neural_net.dat\") >> loaded_net;\n\n    // Serialize multiple objects\n    std::vector<matrix<double>> data;\n    std::string metadata = \"model_v1\";\n    int version = 1;\n\n    std::ofstream fout(\"bundle.dat\", std::ios::binary);\n    serialize(metadata, fout);\n    serialize(version, fout);\n    serialize(svm_model, fout);\n    serialize(data, fout);\n    fout.close();\n\n    // Deserialize bundle\n    std::ifstream fin(\"bundle.dat\", std::ios::binary);\n    std::string loaded_meta;\n    int loaded_version;\n    dec_func loaded_model;\n    std::vector<matrix<double>> loaded_data;\n\n    deserialize(loaded_meta, fin);\n    deserialize(loaded_version, fin);\n    deserialize(loaded_model, fin);\n    deserialize(loaded_data, fin);\n    fin.close();\n\n    std::cout << \"Loaded: \" << loaded_meta\n              << \" version \" << loaded_version << std::endl;\n\n    return 0;\n}\n\n```\n\n## Binary SVM Classification with RBF Kernel in C++\n\n```cpp\n#include <dlib/svm.h>\n#include <iostream>\n#include <vector>\n\nusing namespace dlib;\n\nint main() {\n    // Define sample type (2D points)\n    typedef matrix<double, 2, 1> sample_type;\n    typedef radial_basis_kernel<sample_type> kernel_type;\n\n    // Create training data (circular decision boundary)\n    std::vector<sample_type> samples;\n    std::vector<double> labels;\n\n    for (int r = -20; r <= 20; ++r) {\n        for (int c = -20; c <= 20; ++c) {\n            sample_type samp;\n            samp(0) = r;\n            samp(1) = c;\n            samples.push_back(samp);\n\n            // Label: +1 if distance < 10, else -1\n            if (sqrt((double)r*r + c*c) <= 10)\n                labels.push_back(+1);\n            else\n                labels.push_back(-1);\n        }\n    }\n\n    // Normalize data\n    vector_normalizer<sample_type> normalizer;\n    normalizer.train(samples);\n    for (unsigned long i = 0; i < samples.size(); ++i)\n        samples[i] = normalizer(samples[i]);\n\n    // Randomize for cross-validation\n    randomize_samples(samples, labels);\n\n    // Train SVM\n    svm_nu_trainer<kernel_type> trainer;\n    trainer.set_kernel(kernel_type(0.15625));\n    trainer.set_nu(0.15625);\n\n    typedef decision_function<kernel_type> dec_funct_type;\n    typedef normalized_function<dec_funct_type> funct_type;\n\n    funct_type learned_function;\n    learned_function.normalizer = normalizer;\n    learned_function.function = trainer.train(samples, labels);\n\n    std::cout << \"Support vectors: \"\n              << learned_function.function.basis_vectors.size() << std::endl;\n\n    // Test prediction\n    sample_type test_sample;\n    test_sample(0) = 3.0;\n    test_sample(1) = 4.0;\n    double prediction = learned_function(test_sample);\n    std::cout << \"Prediction for (3,4): \" << prediction\n              << \" (class: \" << (prediction >= 0 ? \"+1\" : \"-1\") << \")\" << std::endl;\n\n    // Serialize model\n    serialize(\"svm_model.dat\") << learned_function;\n\n    return 0;\n}\n\n```\n\n## Dlib Matrix Operations and Linear System Solving in C++\n\n```cpp\n#include <dlib/matrix.h>\n#include <iostream>\n\nusing namespace dlib;\n\nint main() {\n    // Solve y = M*x for x\n    // Compile-time sized vector (3x1)\n    matrix<double,3,1> y;\n    y = 3.5, 1.2, 7.8;\n\n    // Runtime-sized matrix (3x3)\n    matrix<double> M(3,3);\n    M = 54.2,  7.4,  12.1,\n        1,     2,    3,\n        5.9,   0.05, 1;\n\n    // Solve using matrix inverse\n    matrix<double> x = inv(M)*y;\n    std::cout << \"Solution x:\\n\" << x << std::endl;\n\n    // Verify solution\n    std::cout << \"M*x - y (should be ~0):\\n\" << M*x - y << std::endl;\n\n    // Element access\n    std::cout << \"M(0,1) = \" << M(0,1) << std::endl;  // 7.4\n    std::cout << \"y(1) = \" << y(1) << std::endl;      // 1.2\n\n    // Matrix statistics\n    std::cout << \"sum(M) = \" << sum(M) << std::endl;\n    std::cout << \"mean(M) = \" << mean(M) << std::endl;\n    std::cout << \"max(M) = \" << max(M) << std::endl;\n\n    // Matrix operations\n    matrix<double> Mt = trans(M);              // Transpose\n    matrix<double> Id = identity_matrix<double>(3);  // 3x3 identity\n    double det = det(M);                       // Determinant\n    matrix<double> L = chol(M*trans(M));      // Cholesky decomposition\n\n    // Eigenvalues and eigenvectors\n    matrix<double> symmetric = M*trans(M);\n    matrix<double> eigenvalues = eigenvalue(symmetric);\n\n    // CSV output\n    std::cout << csv << M << std::endl;\n\n    // Runtime resizing\n    matrix<double,0,1> runtime_vec;\n    runtime_vec.set_size(5);\n\n    // Matrix from data\n    matrix<double> data = {{1, 2, 3},\n                           {4, 5, 6}};\n\n    std::cout << \"rows: \" << data.nr() << \" cols: \" << data.nc() << std::endl;\n\n    return 0;\n}\n\n```\n\n## C++ HTTP Server with Form Handling using Dlib\n\n```cpp\n#include <dlib/server.h>\n#include <iostream>\n#include <sstream>\n\nusing namespace dlib;\n\nclass web_server : public server_http {\n    const std::string on_request(\n        const incoming_things& incoming,\n        outgoing_things& outgoing\n    ) {\n        std::ostringstream sout;\n\n        // HTML form\n        sout << \"<html><body>\"\n             << \"<form action='/form_handler' method='post'>\"\n             << \"User Name: <input name='user' type='text'><br>\"\n             << \"Password: <input name='pass' type='password'>\"\n             << \"<input type='submit'>\"\n             << \"</form>\";\n\n        // Display request info\n        sout << \"<h2>Request Info</h2>\"\n             << \"<br>path = \" << incoming.path\n             << \"<br>request_type = \" << incoming.request_type\n             << \"<br>content_type = \" << incoming.content_type\n             << \"<br>foreign_ip = \" << incoming.foreign_ip\n             << \"<br>foreign_port = \" << incoming.foreign_port\n             << \"<br>body = \\\"\" << incoming.body << \"\\\"\";\n\n        // Handle form submission\n        if (incoming.path == \"/form_handler\") {\n            sout << \"<h2>Form Submission</h2>\";\n            sout << \"<br>user = \" << incoming.queries[\"user\"];\n            sout << \"<br>pass = \" << incoming.queries[\"pass\"];\n\n            // Set cookies\n            outgoing.cookies[\"user\"] = incoming.queries[\"user\"];\n            outgoing.cookies[\"pass\"] = incoming.queries[\"pass\"];\n        }\n\n        // Echo cookies\n        sout << \"<h2>Cookies</h2>\";\n        for (auto ci = incoming.cookies.begin();\n             ci != incoming.cookies.end(); ++ci) {\n            sout << \"<br>\" << ci->first << \" = \" << ci->second;\n        }\n\n        // Echo headers\n        sout << \"<h2>HTTP Headers</h2>\";\n        for (auto ci = incoming.headers.begin();\n             ci != incoming.headers.end(); ++ci) {\n            sout << \"<br>\" << ci->first << \": \" << ci->second;\n        }\n\n        sout << \"</body></html>\";\n        return sout.str();\n    }\n};\n\nint main() {\n    try {\n        web_server server;\n        server.set_listening_port(5000);\n        server.start_async();\n\n        std::cout << \"Server running on http://localhost:5000\" << std::endl;\n        std::cout << \"Press enter to stop server\" << std::endl;\n        std::cin.get();\n    }\n    catch (std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n```\n\n## Face Detection with MMOD CNN using dlib C++\n\n```cpp\n#include <dlib/dnn.h>\n#include <dlib/image_io.h>\n#include <dlib/gui_widgets.h>\n\nusing namespace dlib;\n\n// Define MMOD CNN architecture for face detection\ntemplate <long num_filters, typename SUBNET>\nusing con5d = con<num_filters,5,5,2,2,SUBNET>;\ntemplate <long num_filters, typename SUBNET>\nusing con5  = con<num_filters,5,5,1,1,SUBNET>;\n\ntemplate <typename SUBNET>\nusing downsampler = relu<affine<con5d<32, relu<affine<con5d<32,\n                    relu<affine<con5d<16,SUBNET>>>>>>>>>;\ntemplate <typename SUBNET>\nusing rcon5 = relu<affine<con5<45,SUBNET>>>;\n\nusing net_type = loss_mmod<con<1,9,9,1,1,rcon5<rcon5<rcon5<\n                 downsampler<input_rgb_image_pyramid<pyramid_down<6>>>>>>>>;\n\nint main(int argc, char** argv) {\n    // Load pretrained face detector model\n    net_type net;\n    deserialize(\"mmod_human_face_detector.dat\") >> net;\n\n    // Load and process image\n    matrix<rgb_pixel> img;\n    load_image(img, \"photo.jpg\");\n\n    // Upsample for detecting smaller faces\n    while(img.size() < 1800*1800)\n        pyramid_up(img);\n\n    // Detect faces\n    auto dets = net(img);\n\n    // Display results\n    image_window win;\n    win.set_image(img);\n    for (auto&& d : dets)\n        win.add_overlay(d);\n\n    std::cout << \"Found \" << dets.size() << \" faces\" << std::endl;\n    win.wait_until_closed();\n\n    return 0;\n}\n\n```\n\n## Face Recognition with ResNet Embeddings\n\n```cpp\n#include <dlib/dnn.h>\n#include <dlib/clustering.h>\n#include <dlib/image_processing/frontal_face_detector.h>\n#include <dlib/image_io.h>\n\nusing namespace dlib;\n\n// ResNet architecture for face recognition (simplified definition)\ntemplate <template <int,template<typename>class,int,typename> class block,\n          int N, template<typename>class BN, typename SUBNET>\nusing residual = add_prev1<block<N,BN,1,tag1<SUBNET>>>;\n\ntemplate <int N, template <typename> class BN, int stride, typename SUBNET>\nusing block = BN<con<N,3,3,1,1,relu<BN<con<N,3,3,stride,stride,SUBNET>>>>>;\n\ntemplate <int N, typename SUBNET>\nusing ares = relu<residual<block,N,affine,SUBNET>>;\n\nusing anet_type = loss_metric<fc_no_bias<128,avg_pool_everything<\n                  /* ...residual layers... */\n                  input_rgb_image_sized<150>\n                  >>>;\n\nint main() {\n    // Load models\n    frontal_face_detector detector = get_frontal_face_detector();\n    shape_predictor sp;\n    deserialize(\"shape_predictor_5_face_landmarks.dat\") >> sp;\n    anet_type net;\n    deserialize(\"dlib_face_recognition_resnet_model_v1.dat\") >> net;\n\n    // Load image\n    matrix<rgb_pixel> img;\n    load_image(img, \"group_photo.jpg\");\n\n    // Detect and extract face chips\n    std::vector<matrix<rgb_pixel>> faces;\n    for (auto face : detector(img)) {\n        auto shape = sp(img, face);\n        matrix<rgb_pixel> face_chip;\n        extract_image_chip(img, get_face_chip_details(shape,150,0.25), face_chip);\n        faces.push_back(std::move(face_chip));\n    }\n\n    // Convert faces to 128D descriptors\n    std::vector<matrix<float,0,1>> face_descriptors = net(faces);\n\n    // Cluster faces using Chinese whispers algorithm\n    std::vector<sample_pair> edges;\n    for (size_t i = 0; i < face_descriptors.size(); ++i) {\n        for (size_t j = i+1; j < face_descriptors.size(); ++j) {\n            if (length(face_descriptors[i] - face_descriptors[j]) < 0.6)\n                edges.push_back(sample_pair(i, j));\n        }\n    }\n\n    std::vector<unsigned long> labels;\n    chinese_whispers(edges, labels);\n\n    std::cout << \"Found \" << *std::max_element(labels.begin(), labels.end()) + 1\n              << \" unique people\" << std::endl;\n\n    return 0;\n}\n\n```\n\n## Dlib Configuration File Syntax\n\n```config\n# This is an example config file.  Note that # is used to create a comment.\n\n# At its most basic level a config file is just a bunch of key/value pairs.\n# So for example:\nkey1 = value2\ndlib = a C++ library\n\n# You can also define \"sub blocks\" in your config files like so\nuser1 \n{\n    # Inside a sub block you can list more key/value pairs.  \n    id = 42\n    name = davis\n\n    # you can also nest sub-blocks as deep as you want\n    details \n    {\n        editor = vim\n        home_dir = /home/davis\n    }\n}\nuser2 {\n    id = 1234\n    name = joe\n    details {\n        editor = emacs\n        home_dir = /home/joe\n    }\n}\n```\n\n## HOG-based Face Detection\n\n```cpp\n#include <dlib/image_processing/frontal_face_detector.h>\n#include <dlib/image_io.h>\n#include <dlib/gui_widgets.h>\n\nusing namespace dlib;\n\nint main(int argc, char** argv) {\n    try {\n        // Get the default HOG-based face detector\n        frontal_face_detector detector = get_frontal_face_detector();\n        image_window win;\n\n        // Process each image\n        for (int i = 1; i < argc; ++i) {\n            array2d<unsigned char> img;\n            load_image(img, argv[i]);\n\n            // Upsample to detect smaller faces (40x40 pixels minimum)\n            pyramid_up(img);\n\n            // Detect faces\n            std::vector<rectangle> dets = detector(img);\n\n            std::cout << \"Found \" << dets.size() << \" faces in \"\n                      << argv[i] << std::endl;\n\n            // Display with red boxes\n            win.clear_overlay();\n            win.set_image(img);\n            win.add_overlay(dets, rgb_pixel(255,0,0));\n\n            std::cin.get();\n        }\n    }\n    catch (std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n```",
    "library": "difflib",
    "topic": "overview",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:27:03.464281"
}