{
  "library": "event_bus",
  "topic": "examples",
  "documentation": {
    "content": "## EventBus.notify Event Example\n\n```elixir\nEventBus.notify(%EventBus.Model.Event{})\n```\n\n## Subscriber Mark as Completed Example\n\n```elixir\nEventBus.mark_as_completed({topic, event_id})\n```\n\n## Subscriber Fetch Event Example\n\n```elixir\nEventBus.fetch_event({topic, event_id})\n```\n\n## Define an Event Struct\n\n```elixir\nalias EventBus.Model.Event\nevent = %Event{id: \"123\", transaction_id: \"1\",\n  topic: :hello_received, data: %{message: \"Hello\"}}\nanother_event = %Event{id: \"124\", transaction_id: \"1\",\n  topic: :bye_received, data: [user_id: 1, goal: \"exit\"]}\n```\n\n## Persistent Event Storage Pattern\n\n```elixir\ndefmodule PersistentEventStore do\n  use GenServer\n\n  def start_link(_) do\n    GenServer.start_link(__MODULE__, nil, name: __MODULE__)\n  end\n\n  def init(_) do\n    # Subscribe to all events with wildcard pattern\n    EventBus.subscribe({__MODULE__, [\".*\"]})\n    {:ok, %{connection: establish_db_connection()}}\n  end\n\n  def process({topic, id}) do\n    GenServer.cast(__MODULE__, {topic, id})\n    :ok\n  end\n\n  def handle_cast({topic, id}, %{connection: conn} = state) do\n    event = EventBus.fetch_event({topic, id})\n\n    # Persist to permanent storage\n    :ok = insert_event_to_postgres(conn, %{\n      event_id: event.id,\n      topic: event.topic,\n      transaction_id: event.transaction_id,\n      data: Jason.encode!(event.data),\n      occurred_at: event.occurred_at,\n      source: event.source\n    })\n\n    # Always mark as completed\n    EventBus.mark_as_completed({__MODULE__, {topic, id}})\n\n    {:noreply, state}\n  end\n\n  defp establish_db_connection do\n    # Return database connection\n    :connection\n  end\n\n  defp insert_event_to_postgres(conn, event_attrs) do\n    # SQL INSERT implementation\n    :ok\n  end\nend\n\n# Add to application supervision tree\nchildren = [\n  # ... other children\n  PersistentEventStore\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)\n```\n\n## Elixir Querying Unprocessed Events from ETS Watcher Table\n\n```elixir\n# The following command will return a list of tuples with the `id`, and `event_subscribers_list` where `subscribers` is the list of event subscribers, `completers` is the subscribers those processed the event and notified `Observation Manager`, and lastly `skippers` is the subscribers those skipped the event without processing.\n\n# Assume you have an event with the name ':hello_received'\n:ets.tab2list(:eb_ew_hello_received)\n> [{id, {subscribers, completers, skippers}}, ...]\n```\n\n## Subscribe Consumer to Topics Matching Pattern - Elixir\n\n```elixir\nsubscriber = MyFirstConsumer\ntopics = [\"^user_*\"]\nEventBus.subscribe({subscriber, topics})\n```\n\n## Track Event Processing Status\n\n```elixir\n# After subscribing, events are automatically tracked\nEventBus.subscribe({AnalyticsSubscriber, [\".*\"]})\n\n# Notify an event\nevent = %Event{id: \"evt_500\", topic: :order_placed, data: %{order_id: 42}}\nEventBus.notify(event)\n\n# In your subscriber, mark processing status\ndefmodule AnalyticsSubscriber do\n  def process({topic, id} = event_shadow) do\n    event = EventBus.fetch_event(event_shadow)\n\n    case track_analytics(event.data) do\n      :ok ->\n        # Mark as successfully completed\n        EventBus.mark_as_completed({__MODULE__, event_shadow})\n\n      {:error, _reason} ->\n        # Mark as skipped (subscriber couldn't process)\n        EventBus.mark_as_skipped({__MODULE__, event_shadow})\n    end\n\n    :ok\n  end\n\n  defp track_analytics(_data), do: :ok\nend\n\n# Alternative syntax with separate topic and id\nEventBus.mark_as_completed({AnalyticsSubscriber, :order_placed, \"evt_500\"})\n# => :ok\n\n# For configured subscribers\nconfig = %{endpoint: \"https://api.example.com\"}\nsubscriber = {AnalyticsSubscriber, config}\nEventBus.mark_as_completed({subscriber, :order_placed, \"evt_500\"})\n# => :ok\n\n# Query ETS watcher table directly for debugging (unprocessed events)\n:ets.tab2list(:eb_ew_order_placed)\n# => [{\"evt_500\", {[AnalyticsSubscriber], [], []}}]\n#     Format: {id, {subscribers, completers, skippers}}\n```\n\n## Registering EventBus Topics with Extended Tracing in Elixir\n\n```elixir\ndefmodule EventBus.Extended do\n  use EventBus.EventSource\n\n  @sys_topic :eb_sys_event_occurred\n  @source \"EventBus.Extended\"\n\n  def register_topic(topic) do\n    EventSource.notify sys_params() do\n      EventBus.register(topic)\n      %{action: :register_topic, topic: topic}\n    end\n    :ok\n  end\n\n  defp sys_params do\n    id = UUID.uuid4() # Assumed you are using UUID for id generation\n    %{id: id, transaction_id: id, topic: @sys_topic, source: @source}\n  end\nend\n```\n\n## Elixir Event Subscriber Processing Logic\n\n```elixir\ndefmodule MyEventSubscriber do\n  ...\n\n  # if your subscriber does not have a config\n  def process({topic, id} = event_shadow) do\n    GenServer.cast(__MODULE__, event_shadow)\n    :ok\n  end\n\n  ...\n\n  # if your subscriber has a config\n  def process({config, topic, id} = event_shadow_with_conf) do\n    GenServer.cast(__MODULE__, event_shadow_with_conf)\n    :ok\n  end\n\n  ...\n\n\n  # if your subscriber does not have a config\n  def handle_cast({:bye_received, id} = event_shadow, state) do\n    event = EventBus.fetch_event(event_shadow)\n    # do sth with event\n\n    # update the watcher!\n    # version >= 1.4.0\n    EventBus.mark_as_completed({__MODULE__, event_shadow})\n    # all versions\n    EventBus.mark_as_completed({__MODULE__, :bye_received, id})\n    ...\n    {:noreply, state}\n  end\n\n  def handle_cast({:hello_received, id} = event_shadow, state) do\n    event = EventBus.fetch_event({:hello_received, id})\n    # do sth with EventBus.Model.Event\n\n    # update the watcher!\n    # version >= 1.4.0\n    EventBus.mark_as_completed({__MODULE__, event_shadow})\n    # all versions\n    EventBus.mark_as_completed({__MODULE__, :hello_received, id})\n    ...\n    {:noreply, state}\n  end\n\n  def handle_cast({topic, id} = event_shadow, state) do\n    # version >= 1.4.0\n    EventBus.mark_as_skipped({__MODULE__, event_shadow})\n\n    # all versions\n    EventBus.mark_as_skipped({__MODULE__, topic, id})\n    {:noreply, state}\n  end\n\n  ...\n\n  # if your subscriber has a config\n  def handle_cast({config, :bye_received, id}, state) do\n    event = EventBus.fetch_event({:bye_received, id})\n    # do sth with event\n\n    # update the watcher!\n    subscriber = {__MODULE__, config}\n    EventBus.mark_as_completed({subscriber, :bye_received, id})\n    ...\n    {:noreply, state}\n  end\n\n  def handle_cast({config, :hello_received, id}, state) do\n    event = EventBus.fetch_event({:hello_received, id})\n    # do sth with EventBus.Model.Event\n\n    # update the watcher!\n    subscriber = {__MODULE__, config}\n    EventBus.mark_as_completed({subscriber, :hello_received, id})\n    ...\n    {:noreply, state}\n  end\n\n  def handle_cast({config, topic, id}, state) do\n    subscriber = {__MODULE__, config}\n    EventBus.mark_as_skipped({subscriber, topic, id})\n    {:noreply, state}\n  end\n\n  ...\nend\n```\n",
    "library": "event_bus",
    "topic": "examples",
    "source": "api"
  },
  "source": "api",
  "saved_at": "2026-01-30T16:10:46.813934"
}