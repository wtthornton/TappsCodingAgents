{
  "library": "dataclasses",
  "topic": null,
  "documentation": {
    "content": "## Example Dataclass Model and Client Usage\n\n```python\n# Example model definition (model.py)\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str | None\n    created_at: datetime\n\n    def index(self):\n        yield self.name\n        yield self.created_at\n\n# After running: dql generate\n# Import generated client\nfrom dclassql.client import Client\n\nclient = Client()\nuser = client.user.insert({\"name\": \"Alice\", \"email\": \"alice@example.com\", \"created_at\": datetime.now()})\nprint(user.id)  # Type-safe access, pyright knows id is int\n```\n\n## Unwrap Optional Values with dataclassql Utilities\n\n```python\nfrom dclassql import unwarp, unwarp_or, unwarp_or_raise\n\n# Assume 'user' is an object with an optional 'email' attribute\n# For demonstration, let's mock a user object:\nclass MockUser:\n    def __init__(self, email):\n        self.email = email\n\n# Example with a user having an email\nuser_with_email = MockUser(\"test@example.com\")\n\n# unwarp: raise ValueError if None\nvalue = unwarp(user_with_email.email)  # Returns \"test@example.com\"\nprint(value)  # Type: str (None eliminated)\n\n# unwarp_or: provide default value\nemail = unwarp_or(user_with_email.email, \"no-email@example.com\")\nprint(email)  # Type: str (returns \"test@example.com\")\n\n# unwarp_or_raise: custom exception\ntry:\n    email = unwarp_or_raise(user_with_email.email, ValueError(\"Email required\"))\n    print(email) # Type: str (returns \"test@example.com\")\nexcept ValueError as e:\n    print(e)  # This won't be printed in this case\n\n# Example with a user NOT having an email\nuser_without_email = MockUser(None)\n\n# unwarp: raise ValueError if None\ntry:\n    value = unwarp(user_without_email.email) # Raises ValueError\nexcept ValueError as e:\n    print(f\"Caught expected error: {e}\")\n\n# unwarp_or: provide default value\nemail = unwarp_or(user_without_email.email, \"no-email@example.com\")\nprint(email)  # Type: str (returns \"no-email@example.com\")\n\n# unwarp_or_raise: custom exception\ntry:\n    email = unwarp_or_raise(user_without_email.email, ValueError(\"Email required\"))\nexcept ValueError as e:\n    print(e)  # \"Email required\"\n\n# Usage in business logic\ndef send_email(user):\n    # Assert non-None and get the value\n    to_address = unwarp(user.email) \n    print(f\"Attempting to send email to: {to_address}\")\n    # ... send email code (this part is illustrative)\n\nsend_email(user_with_email)\nsend_email(user_without_email) # This would raise an error if not handled upstream\n\n```\n\n## Manage Database Schema with DataclassQL CLI\n\n```bash\n# Preview and apply schema changes interactively\ndql -m model.py push-db --confirm-rebuild=prompt\n\n# Auto-apply all schema changes\ndql -m model.py push-db --confirm-rebuild=auto\n\n# Synchronize indexes (drop extra, create missing)\ndql -m model.py push-db --sync-indexes --confirm-rebuild=auto\n```\n\n## Multiple Datasources Configuration in dataclassql\n\n```python\n# In user_models.py\n__datasource__ = {\n    \"provider\": \"sqlite\",\n    \"url\": \"sqlite:///main.db\",\n    \"name\": \"main\"\n}\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\n# In analytics_models.py\n__datasource__ = {\n    \"provider\": \"sqlite\",\n    \"url\": \"sqlite:///analytics.db\",\n    \"name\": \"analytics\"\n}\n\n@dataclass\nclass PageView:\n    id: int\n    page: str\n    user_id: int\n```\n\n## Lazy and Eager Relations in DataClassSQL\n\n```python\nfrom dataclasses import dataclass\n\n# Model definitions with relations\n@dataclass\nclass Address:\n    id: int\n    location: str\n    user_id: int\n    user: 'User'\n\n    def foreign_key(self):\n        yield self.user.id == self.user_id, User.addresses\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    addresses: list[Address]\n\n# Generated client usage\nfrom dclassql.client import Client\n\nclient = Client()\n\n# Lazy loading (N+1 queries)\nuser = client.user.find_first(where={\"id\": 1})\n# Accessing user.addresses triggers automatic query\nfor address in user.addresses:\n    print(address.location)\n\n# Eager loading with include\nuser = client.user.find_first(\n    where={\"id\": 1},\n    include={\"addresses\": True}\n)\n# user.addresses already loaded, no additional queries\nfor address in user.addresses:\n    print(address.location)\n\n# Force resolve lazy relations\nfrom dclassql import eager\n\nuser = client.user.find_first(where={\"id\": 1})\neager(user)  # Resolves all lazy relations immediately\n```\n\n## Serialize Dataclasses to Dictionaries with asdict\n\n```python\nfrom dclassql import asdict, Client\n\nclient = Client()\n\nuser = client.user.find_first(\n    where={\"id\": 1},\n    include={\"addresses\": True}\n)\n\n# Skip relations (return empty list/None)\ndata = asdict(user, relation_policy=\"skip\")\n# {\"id\": 1, \"name\": \"Alice\", \"addresses\": []}\n\n# Keep loaded relations, skip unloaded\ndata = asdict(user, relation_policy=\"keep\")\n# {\"id\": 1, \"name\": \"Alice\", \"addresses\": [{\"id\": 1, \"location\": \"NY\", ...}]}\n\n# Fetch all relations before converting\ndata = asdict(user, relation_policy=\"fetch\")\n# Triggers queries for any unloaded relations\n\nimport json\nprint(json.dumps(data, default=str, indent=2))\n```\n\n## Query Records with DataclassQL Filtering\n\n```python\nfrom dclassql.client import Client\nfrom datetime import datetime, timedelta\n\nclient = Client()\n\n# Simple equality filter\nusers = client.user.find_many(where={\"name\": \"Alice\"})\n\n# Rich filters with operators\nrecent = client.user.find_many(where={\"created_at\": {\"GT\": datetime.now() - timedelta(days=7)}})\n\n# String filters\nusers = client.user.find_many(where={\"email\": {\"CONTAINS\": \"@example.com\"}})\n\n# Logical combinations\nusers = client.user.find_many(where={\"OR\": [\n    {\"name\": {\"STARTS_WITH\": \"A\"}},\n    {\"email\": {\"EQ\": None}}\n]})\n\n# Relation filters (for models with foreign keys)\naddresses = client.address.find_many(where={\"user\": {\"IS\": {\"name\": \"Alice\"}}})\n\n# First match only\nuser = client.user.find_first(\n    where={\"email\": {\"NOT\": None}},\n    order_by={\"created_at\": \"desc\"}\n)\n```\n\n## Insert and Query with Composite Keys using dataclassql Client\n\n```python\nfrom dclassql.client import Client\nfrom datetime import datetime\n\nclient = Client()\n\n# Insert with composite key\nub = client.user_book.insert({\n    \"user_id\": 1,\n    \"book_id\": 10,\n    \"created_at\": datetime.now()\n})\n\n# Query by composite key components\nlinks = client.user_book.find_many(where={\n    \"user_id\": 1\n})\n```\n\n## Update and Upsert Records in DataClassSQL\n\n```python\nfrom dclassql.client import Client\nfrom datetime import datetime\n\nclient = Client()\n\n# Update single record by primary key\nupdated = client.user.update(\n    where={\"id\": 1},\n    data={\"email\": \"newemail@example.com\"}\n)\nprint(updated.email)  # \"newemail@example.com\"\n\n# Update many with return_records\nupdated_list = client.user.update_many(\n    where={\"email\": None},\n    data={\"email\": \"default@example.com\"},\n    return_records=True  # Returns all updated records\n)\n\n# Update many, return count only (default)\ncount = client.user.update_many(\n    where={\"name\": {\"STARTS_WITH\": \"A\"}},\n    data={\"email\": \"admin@example.com\"}\n)\nprint(f\"Updated {count} records\")\n\n# Upsert: update if exists, insert if not\nuser = client.user.upsert(\n    where={\"id\": 100},\n    update={\"email\": \"updated@example.com\"},\n    insert={\"id\": 100, \"name\": \"New User\", \"email\": \"new@example.com\", \"created_at\": datetime.now()}\n)\n```\n\n## Define Foreign and Composite Primary Keys in DataClassSQL\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass UserBook:\n    user_id: int\n    book_id: int\n    user: 'User'\n    book: 'Book'\n    created_at: datetime\n\n    def primary_key(self):\n        return (self.user_id, self.book_id)  # Composite PK\n\n    def index(self):\n        yield self.created_at\n\n    def foreign_key(self):\n        yield self.user.id == self.user_id, User.books\n        yield self.book.id == self.book_id, Book.users\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    books: list['UserBook']\n\n@dataclass\nclass Book:\n    id: int\n    title: str\n    users: list['UserBook']\n\n```\n\nContext7 cache for dataclasses: cached at 2026-01-31T02:31:24.265299+00:00Z; consider refreshing if docs changed.",
    "library": "dataclasses",
    "topic": "overview",
    "source": "cache"
  },
  "source": "cache",
  "saved_at": "2026-01-30T18:31:24.334923"
}