{
  "library": "error_envelope",
  "topic": "examples",
  "documentation": {
    "content": "## Organize Errors by Team and Component\n\n```typescript\nimport { createError } from \"conway-errors\";\n\nconst createErrorContext = createError([\n  { errorType: \"FrontendLogicError\" },\n  { errorType: \"BackendLogicError\" },\n] as const);\n\nconst projectErrors = createErrorContext(\"MyProject\");\n\n// Method 1: Using extendedParams for team attribution (recommended)\nconst authErrors = projectErrors.subcontext(\"Auth\", {\n  extendedParams: { team: \"Platform Team\", component: \"Authentication\" }\n});\n\nconst searchErrors = projectErrors.subcontext(\"Search\", {\n  extendedParams: { team: \"User Experience Team\", component: \"Search\" }\n});\n\n// Method 2: Team-specific root contexts\nconst platformErrors = createErrorContext(\"PlatformTeam\");\nconst uxErrors = createErrorContext(\"UXTeam\");\n```\n\n## Organize Errors by Domain and Subcontext\n\n```typescript\nimport { createError } from \"conway-errors\";\n\n// Separate type sets for different contexts\nconst createPaymentErrors = createError([\n  { errorType: \"ValidationError\" },\n  { errorType: \"ProcessingError\" },\n  { errorType: \"GatewayError\" },\n] as const);\n\nconst createAuthErrors = createError([\n  { errorType: \"AuthenticationError\" },\n  { errorType: \"AuthorizationError\" },\n  { errorType: \"TokenError\" },\n] as const);\n\n// Payment domain errors\nconst paymentErrors = createPaymentErrors(\"Payment\");\nconst recurringPayments = paymentErrors.subcontext(\"Recurring\");\nconst refunds = paymentErrors.subcontext(\"Refund\");\n\nconst recurringError = recurringPayments.feature(\"RecurringPaymentError\");\nconst refundError = refunds.feature(\"RefundError\");\n\n// Auth domain errors\nconst authErrors = createAuthErrors(\"Authentication\");\nconst oauthError = authErrors.feature(\"OAuthError\");\n\n// Usage examples\nthrow recurringError(\"ProcessingError\", \"Card declined for recurring payment\");\nthrow oauthError(\"TokenError\", \"OAuth token has expired\");\n```\n\n## Sentry Integration for Error Tracking with Conway Errors\n\n```typescript\nimport { createError } from \"conway-errors\";\nimport * as Sentry from \"@sentry/nextjs\";\n\nconst createErrorContext = createError(\n  [\n    { errorType: \"ClientError\" },\n    { errorType: \"ServerError\" },\n    { errorType: \"ValidationError\" }\n  ] as const,\n  {\n    extendedParams: {\n      environment: process.env.NODE_ENV,\n      version: process.env.APP_VERSION\n    },\n    handleEmit: (err, extendedParams) => {\n      const { \n        environment, \n        version, \n        severity = \"error\", \n        userId, \n        userEmail, \n        action, \n        component, \n        ...customContext \n      } = extendedParams || {};\n\n      Sentry.withScope(scope => {\n        // Set user context\n        if (userId || userEmail) {\n          scope.setUser({\n            id: userId as string | undefined,\n            email: userEmail as string | undefined\n          });\n        }\n\n        // Set severity level\n        scope.setLevel(severity as Sentry.SeverityLevel);\n\n        // Add tags for filtering\n        scope.setTags({\n          environment: environment as string,\n          version: version as string,\n          errorType: err.name,\n          errorContext: err.rootContext,\n          errorFeature: err.feature,\n          action: action as string | undefined,\n          component: component as string | undefined\n        });\n\n        // Add custom context\n        scope.setContext(\"errorDetails\", {\n          fullPath: err.contextsChunk,\n          originalError: err.originalError,\n          ...customContext\n        });\n\n        // Capture exception\n        Sentry.captureException(err);\n      });\n    }\n  }\n);\n\nconst appErrors = createErrorContext(\"WebApp\");\nconst checkoutFlow = appErrors.subcontext(\"Checkout\");\nconst paymentStep = checkoutFlow.feature(\"Payment\");\n\n// Example usage with comprehensive context\nasync function processPayment(paymentData: any) {\n  try {\n    const result = await stripeAPI.charge(paymentData);\n    return result;\n  } catch (error) {\n    paymentStep(\"ServerError\", \"Payment processing failed\", {\n      originalError: error\n    }).emit({\n      extendedParams: {\n        userId: paymentData.userId,\n        userEmail: paymentData.email,\n        severity: \"critical\",\n        action: \"process_payment\",\n        component: \"stripe_integration\",\n        amount: paymentData.amount,\n        currency: paymentData.currency,\n        paymentMethod: paymentData.method\n      }\n    });\n    throw error;\n  }\n}\n\n```\n\n## Create Nested Error Contexts for Hierarchical Organization - TypeScript\n\n```typescript\nimport { createError } from \"conway-errors\";\n\nconst createErrorContext = createError([\n  { errorType: \"FrontendLogicError\" },\n  { errorType: \"BackendLogicError\" },\n  { errorType: \"APIError\" }\n] as const);\n\n// Root context\nconst projectErrors = createErrorContext(\"MyProject\");\n\n// Create subcontexts for logical grouping\nconst apiErrors = projectErrors.subcontext(\"API\");\nconst authErrors = projectErrors.subcontext(\"Auth\");\n\n// Further nesting\nconst oauthErrors = authErrors.subcontext(\"OAuth\");\nconst paymentAPIErrors = apiErrors.subcontext(\"Payment\");\n\n// Create feature errors\nconst oauthLogin = oauthErrors.feature(\"LoginError\");\nconst paymentCharge = paymentAPIErrors.feature(\"ChargeError\");\n\n// Hierarchical error paths\nthrow oauthLogin(\"FrontendLogicError\", \"User not found\");\n// Result: \"FrontendLogicError: MyProject/Auth/OAuth/LoginError: User not found\"\n\nthrow paymentCharge(\"BackendLogicError\", \"Payment already processed\");\n// Result: \"BackendLogicError: MyProject/API/Payment/ChargeError: Payment already processed\"\n```\n\n## Hierarchical Error Organization Example\n\n```typescript\nimport { createError } from \"conway-errors\";\n\n// Setup error configuration\nconst createErrorContext = createError([\n  { errorType: \"FrontendLogicError\" },\n  { errorType: \"BackendLogicError\" },\n] as const);\n\n// Create root context\nconst errorContext = createErrorContext(\"MyProject\");\n\n// Create organized subcontexts\nconst apiErrorContext = errorContext.subcontext(\"APIError\");\nconst authErrorContext = errorContext.subcontext(\"AuthError\");\n\n// Create specific error functions\nconst oauthError = authErrorContext.feature(\"OauthError\");\nconst apiPaymentError = apiErrorContext.feature(\"APIPaymentError\");\n\n// Throw errors\nthrow oauthError(\"FrontendLogicError\", \"User not found\");\n// Result: \"FrontendLogicError: MyProject/AuthError/OauthError: User not found\"\n\nthrow apiPaymentError(\"BackendLogicError\", \"Payment already processed\");\n// Result: \"BackendLogicError: MyProject/APIError/APIPaymentError: Payment already processed\"\n```\n\n## Hierarchical Extended Parameters for Metadata Propagation\n\n```typescript\nimport { createError } from \"conway-errors\";\nimport posthog from \"posthog-js\";\n\nconst createErrorContext = createError(\n  [\n    { errorType: \"ValidationError\" },\n    { errorType: \"NetworkError\" },\n    { errorType: \"ServerError\" }\n  ] as const,\n  {\n    // Global extended params for all errors\n    extendedParams: {\n      environment: process.env.NODE_ENV,\n      appVersion: \"2.1.0\"\n    },\n    handleEmit: (err, extendedParams) => {\n      posthog.captureException(err, {\n        ...extendedParams,\n        errorPath: err.contextsChunk,\n        timestamp: Date.now()\n      });\n    }\n  }\n);\n\n// Root context with service identifier\nconst paymentService = createErrorContext(\"PaymentService\", {\n  extendedParams: { service: \"stripe\", region: \"us-east-1\" }\n});\n\n// Subcontext with team attribution\nconst recurringBilling = paymentService.subcontext(\"RecurringBilling\", {\n  extendedParams: { team: \"Billing Team\", component: \"Subscriptions\" }\n});\n\n// Feature with specific metadata\nconst subscriptionCharge = recurringBilling.feature(\"SubscriptionCharge\", {\n  extendedParams: { retryable: true, maxRetries: 3 }\n});\n\n// All parameters are merged: global + service + billing + feature + emit-time\nconst error = subscriptionCharge(\"ServerError\", \"Stripe API unavailable\");\nerror.emit({\n  extendedParams: {\n    customerId: \"cus_123\",\n    subscriptionId: \"sub_456\",\n    attemptNumber: 2\n  }\n});\n\n// PostHog receives all merged parameters:\n// {\n//   environment: \"production\",\n//   appVersion: \"2.1.0\",\n//   service: \"stripe\",\n//   region: \"us-east-1\",\n//   team: \"Billing Team\",\n//   component: \"Subscriptions\",\n//   retryable: true,\n//   maxRetries: 3,\n//   customerId: \"cus_123\",\n//   subscriptionId: \"sub_456\",\n//   attemptNumber: 2,\n//   errorPath: \"PaymentService/RecurringBilling/SubscriptionCharge\",\n//   timestamp: 1234567890\n// }\n```\n\n## Type-Safe Error Handling with Subcontext Constraints (TypeScript)\n\n```typescript\nimport { createError, AnyFeatureOfSubcontext } from \"conway-errors\";\n\nconst createErrorContext = createError([\n  { errorType: \"ValidationError\" },\n  { errorType: \"ProcessingError\" },\n] as const);\n\nconst appErrors = createErrorContext(\"App\");\nconst authErrors = appErrors.subcontext(\"Auth\");\n\nconst loginError = authErrors.feature(\"LoginError\");\nconst generalError = appErrors.feature(\"GeneralError\");\n\n// Type-safe error handler for auth-specific features\nfunction handleAuthError(errorFeature: AnyFeatureOfSubcontext<typeof authErrors>) {\n  // Only accepts features from authErrors subcontext\n}\n\nhandleAuthError(loginError);    // \u2705 Valid\nhandleAuthError(generalError);  // \u274c TypeScript error\n```\n\n## Type-Safe Error Handling with Subcontexts and TypeScript Utility Types (TypeScript)\n\n```typescript\nimport { createError, AnyFeatureOfSubcontext } from \"conway-errors\";\n\nconst createErrorContext = createError([\n  { errorType: \"ValidationError\" },\n  { errorType: \"ProcessingError\" },\n] as const);\n\nconst appErrors = createErrorContext(\"App\");\nconst authErrors = appErrors.subcontext(\"Auth\");\n\nconst loginError = authErrors.feature(\"LoginError\");\nconst generalError = appErrors.feature(\"GeneralError\");\n\n// \u0422\u0438\u043f\u043e\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043e\u0448\u0438\u0431\u043e\u043a \u0434\u043b\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0439, \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u0447\u043d\u044b\u0445 \u0434\u043b\u044f \u0430\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438\nfunction handleAuthError(errorFeature: AnyFeatureOfSubcontext<typeof authErrors>) {\n  // \u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u0437 \u043f\u043e\u0434\u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 authErrors\n}\n\nhandleAuthError(loginError);    // \u2705 \u0412\u0430\u043b\u0438\u0434\u043d\u043e\nhandleAuthError(generalError);  // \u274c \u041e\u0448\u0438\u0431\u043a\u0430 TypeScript\n```\n\n## Basic Setup and Error Definition\n\n```typescript\nimport { createError } from \"conway-errors\";\n\n// Define your error types\nconst createErrorContext = createError([\n  { errorType: \"ValidationError\" },\n  { errorType: \"NetworkError\" },\n] as const);\n\n// Create your first error context\nconst appErrors = createErrorContext(\"MyApp\");\n```\n\n## Separate Root Contexts for Different Services\n\n```typescript\nimport { createError } from \"conway-errors\";\n\n// Configure API-specific error types\nconst createAPIErrorContext = createError([\n  { errorType: \"MissingRequiredHeader\" },\n  { errorType: \"InvalidInput\" },\n  { errorType: \"InternalError\" },\n  { errorType: \"RateLimitExceeded\" },\n] as const);\n\n// Create service-specific error contexts\nconst authAPIErrors = createAPIErrorContext(\"AuthAPI\");\nconst stockAPIErrors = createAPIErrorContext(\"StockAPI\");\n\n// Create feature-specific error handlers\nconst loginError = authAPIErrors.feature(\"LoginError\");\nconst registerError = authAPIErrors.feature(\"RegisterError\");\nconst stockSearchError = stockAPIErrors.feature(\"StockSearchError\");\n\n// Handle different error scenarios\ntry {\n  // API call logic\n  throw loginError(\"InvalidInput\", \"Invalid email format\");\n} catch (error) {\n  // Handle login validation errors\n}\n\n// Log errors for monitoring\nstockSearchError(\"RateLimitExceeded\", \"API quota exceeded\").emit();\n```",
    "library": "error_envelope",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:25:32.912581"
}