{
  "library": "ruff_grouping",
  "topic": "examples",
  "documentation": {
    "content": "## Python Nested Top and Bottom Type Usage\n\n```python\nfrom typing import Any\nfrom ty_extensions import Top, Bottom, static_assert, is_equivalent_to\n\nstatic_assert(is_equivalent_to(Top[Top[list[Any]]], Top[list[Any]]))\nstatic_assert(is_equivalent_to(Bottom[Top[list[Any]]], Top[list[Any]]))\n\nstatic_assert(is_equivalent_to(Bottom[Bottom[list[Any]]], Bottom[list[Any]]))\nstatic_assert(is_equivalent_to(Top[Bottom[list[Any]]], Bottom[list[Any]]))\n```\n\n## Invalid Ellipsis Usage in Non-Stub Files (Python)\n\n```python\n# error: [invalid-parameter-default] \"Default value of type `EllipsisType` is not assignable to annotated parameter type `int`\"\ndef f(x: int = ...) -> None: ...\n\n# error: [invalid-assignment] \"Object of type `EllipsisType` is not assignable to `int`\"\na: int = ...\nb = ...\nreveal_type(b)  # revealed: EllipsisType\n```\n\n## Handling Invalid Union Type Usage\n\n```python\nfrom typing import Union\n\n# error: [invalid-type-form] \"`typing.Union` requires at least one argument when used in a type expression\"\ndef f(x: Union) -> None:\n    reveal_type(x)  # revealed: Unknown\n```\n\n## Python Type Hinting: Callable Usage\n\n```python\nfrom typing import Callable, Union\n\nCallableNoArgs = Callable[[], None]\nBasicCallable = Callable[[int, str], bytes]\nGradualCallable = Callable[..., str]\n\nreveal_type(CallableNoArgs)  # revealed: <typing.Callable special-form '() -> None'>\nreveal_type(BasicCallable)  # revealed: <typing.Callable special-form '(int, str, /) -> bytes'>\nreveal_type(GradualCallable)  # revealed: <typing.Callable special-form '(...) -> str'>\n\ndef _(\n    callable_no_args: CallableNoArgs,\n    basic_callable: BasicCallable,\n    gradual_callable: GradualCallable,\n):\n    reveal_type(callable_no_args)  # revealed: () -> None\n    reveal_type(basic_callable)  # revealed: (int, str, /) -> bytes\n    reveal_type(gradual_callable)  # revealed: (...) -> str\n```\n\n## Python typing.Annotated Usage and Limitations in Ruff\n\n```python\nfrom typing import Annotated\n\nMyAnnotatedInt = Annotated[int, \"some metadata\", 1, 2, 3]\n\ndef _(annotated_int: MyAnnotatedInt):\n    reveal_type(annotated_int)  # revealed: int\n\n```\n\n## Python typing.Annotated Usage and Limitations in Ruff\n\n```python\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\nDeprecated = Annotated[T, \"deprecated attribute\"]\n\nclass C:\n    old: Deprecated[int]\n\nreveal_type(C().old)  # revealed: int\n\n```\n\n## Python typing.Annotated Usage and Limitations in Ruff\n\n```python\n# error: [invalid-type-form] \"Special form `typing.Annotated` expected at least 2 arguments (one type and at least one metadata element)\"\nWronglyAnnotatedInt = Annotated[int]\n\ndef _(wrongly_annotated_int: WronglyAnnotatedInt):\n    reveal_type(wrongly_annotated_int)  # revealed: int\n\n```\n\n## Basic dataclasses.InitVar Usage\n\n```python\nfrom dataclasses import InitVar, dataclass\n\nclass Database: ...\n\n@dataclass(order=True)\nclass Person:\n    db: InitVar[Database]\n\n    name: str\n    age: int\n\nreveal_type(Person.__init__)  # revealed: (self: Person, db: Database, name: str, age: int) -> None\ndb = Database()\nalice = Person(db, \"Alice\", 30)\n\nalice.db  # error: [unresolved-attribute]\nPerson.db  # error: [unresolved-attribute]\nreveal_type(alice.name)  # revealed: str\nreveal_type(alice.age)  # revealed: int\n```\n\n## Ruff Type Hinting: UnionType Instance Usage\n\n```python\nfrom types import UnionType\n\ndef f(SomeUnionType: UnionType):\n    pass\n```\n\n## Modifying `__all__` via Named Import\n\n```python\nfrom subexporter import __all__\n\n__all__.append(\"B\")\n\nclass B: ...\n\n```\n\n## Invalid Literal usage in typing\n\n```python\nfrom typing import Literal\n\n# error: [invalid-type-form] \"`typing.Literal` requires at least one argument when used in a type expression\"\ndef _(x: Literal):\n    reveal_type(x)  # revealed: Unknown\n```\n\n## Check invalid @overload usages in Python\n\n```python\nfrom typing import overload\n\n@overload\ndef foo(x: int) -> int: ...\ndef foo(x: int | None) -> int | None:\n    return x\n\n@overload\ndef foo() -> None: ...\n@overload\ndef foo(x: int) -> int: ...\n# This is problematic as no implementation is provided for foo\n```",
    "library": "ruff_grouping",
    "topic": "usage",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-03T09:49:04.669775"
}