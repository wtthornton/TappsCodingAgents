{
  "library": "prompt_base",
  "topic": "examples",
  "documentation": {
    "content": "## Extended Service Mapping for Future Extensions - TypeScript\n\n```typescript\nconst serviceMap = [\n  // ... existing services ...\n  { service: this.imageModelManager, dataKey: 'imageModels' },\n  { service: this.favoriteManager, dataKey: 'favorites' }\n];\n```\n\n## Claude Desktop Services Configuration (JSON)\n\n```json\n{\n  \"services\": [\n    {\n      \"name\": \"Prompt Optimizer\",\n      \"url\": \"http://localhost:8081/mcp\"\n    }\n  ]\n}\n```\n\n## Service Level Error Collection in TypeScript\n\n```typescript\n// From TemplateManager.importData()\nconst failedTemplates: { template: Template; error: Error }[] = [];\n\nfor (const template of templates) {\n  try {\n    await this.saveTemplate(userTemplate);\n  } catch (error) {\n    failedTemplates.push({ template, error: error as Error });\n  }\n}\n\nif (failedTemplates.length > 0) {\n  console.warn(`Failed to import ${failedTemplates.length} templates`);\n  // Continues without throwing - partial success allowed\n}\n```\n\n## Electron IPC Handler Examples\n\n```javascript\n// Model import handleripcMain.handle('model-importData', async (event, data) => {\n  try {\n    const safeData = safeSerialize(data);\n    await modelManager.importData(safeData);\n    return createSuccessResponse(null);\n  } catch (error) {\n    return createErrorResponse(error);\n  }\n});\n\n// Model update handleripcMain.handle('model-updateModel', async (event, id, updates) => {\n  try {\n    const safeUpdates = safeSerialize(updates);\n    await modelManager.updateModel(id, safeUpdates);\n    return createSuccessResponse(null);\n  } catch (error) {\n    return createErrorResponse(error);\n  }\n});\n\n// Preference import handleripcMain.handle('preference-importData', async (event, data) => {\n  try {\n    const safeData = safeSerialize(data);\n    await preferenceService.importData(safeData);\n    return createSuccessResponse(null);\n  } catch (error) {\n    return createErrorResponse(error);\n  }\n});\n```\n\n## Apply Optimized Message to Conversation - TypeScript\n\n```typescript\nconst handleApplyToConversation = () => {\n  if (!conversationOptimization.selectedMessage) return\n  \n  const messageId = conversationOptimization.selectedMessage.id\n  const optimizedContent = conversationOptimization.optimizedPrompt\n  \n  // Find and update the message in conversation array\n  const messages = [...optimizationContext]\n  const index = messages.findIndex(m => m.id === messageId)\n  \n  if (index !== -1) {\n    messages[index] = {\n      ...messages[index],\n      content: optimizedContent\n    }\n    \n    emit('update:optimizationContext', messages)\n  }\n  \n  // Clear selection\n  conversationOptimization.clearSelection()\n}\n```\n\n## Render Message Card with Editing and Preview Options\n\n```vue\n<NCard v-for=\"(message, index) in localState.messages\">\n  <template #header>\n    <NSelect\n      v-model:value=\"message.role\"\n      :options=\"roleOptions\"\n      @update:value=\"handleMessageUpdate(index, message)\"\n    />\n    <NButton @click=\"togglePreview(index)\">\n      {{ previewMode.get(index) ? 'Edit' : 'Preview' }}\n    </NButton>\n  </template>\n  \n  <!-- Edit Mode -->\n  <VariableAwareInput\n    v-if=\"!previewMode.get(index)\"\n    v-model=\"message.content\"\n    :existing-global-variables=\"globalVariableNames\"\n    @variable-extracted=\"handleVariableExtracted\"\n  />\n  \n  <!-- Preview Mode -->\n  <MarkdownRenderer\n    v-else\n    :content=\"replaceVariables(message.content, mergedVariables)\"\n  />\n</NCard>\n```\n\n## Variable Extraction and Multi-level Sync (TypeScript)\n\n```typescript\n// In Workspace\nconst handleVariableExtracted = (data: {\n  variableName: string\n  variableValue: string\n  variableType: 'global' | 'temporary'\n}) => {\n  if (data.variableType === 'global') {\n    variableManager.addVariable(data.variableName, data.variableValue)\n    // \u2190 Syncs to PreferenceService \u2192 Storage\n  } else {\n    tempVars.addVariable(data.variableName, data.variableValue)\n    // \u2190 Syncs to session-only state\n  }\n}\n```\n\n## Inject Tool Context into Optimization Requests (JavaScript)\n\n```javascript\nconst handleOptimizeWithTools = () => {\n  const toolsContext = tools.map(t => \n    `${t.function.name}: ${t.function.description}`\n  ).join('\\n')\n  \n  const request = {\n    originalPrompt: selectedMessage.content,\n    optimizationMode: 'system',\n    template: selectedTemplate,\n    context: {\n      // Other conversation messages\n      messages: optimizationContext,\n      \n      // Auto-injected variables\n      variables: {\n        ...globalVariables,\n        toolsContext  // \u2190 Auto-injected\n      }\n    }\n  }\n  \n  promptService.optimizePromptStream(request)\n}\n```\n\n## Prompt Display Adapter Logic - TypeScript\n\n```typescript\nconst displayAdapter = usePromptDisplayAdapter({\n  conversationOptimization,\n  globalOptimization\n})\n\n// Computed properties determine which state to display\nconst isInMessageOptimizationMode = computed(() => \n  !!conversationOptimization.selectedMessage\n)\n\nconst displayedOptimizedPrompt = computed(() =>\n  isInMessageOptimizationMode.value\n    ? conversationOptimization.optimizedPrompt\n    : globalOptimization.optimizedPrompt\n)\n```\n\n## Electron Environment Proxy Implementations\n\n```typescript\nfunction createElectronLLMProxy(): ILLMService {\n  // Implementation details for Electron proxy\n  return new ElectronLLMProxy();\n}\n\nfunction createElectronModelManagerProxy(): IModelManager {\n  // Implementation details for Electron proxy\n  return new ElectronModelManagerProxy();\n}\n// ... other proxy initializations\n```",
    "library": "prompt_analyzer",
    "topic": "examples",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:32:53.032756"
}