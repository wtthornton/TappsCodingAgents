{
  "library": "task_state",
  "topic": "best-practices",
  "documentation": {
    "content": "## Type-Safe Machine Configuration with Reusable Implementations (TypeScript)\n\n```typescript\nimport { setup, createActor, assign } from 'xstate';\n\ninterface UserContext {\n  userId: string | null;\n  retries: number;\n}\n\ntype UserEvent =\n  | { type: 'LOGIN'; username: string; password: string }\n  | { type: 'LOGOUT' }\n  | { type: 'REFRESH' };\n\nconst userAuthSetup = setup({\n  types: {} as {\n    context: UserContext;\n    events: UserEvent;\n  },\n  actions: {\n    setUser: assign({\n      userId: ({ event }) => (event as any).userId\n    }),\n    clearUser: assign({\n      userId: null,\n      retries: 0\n    }),\n    incrementRetries: assign({\n      retries: ({ context }) => context.retries + 1\n    })\n  },\n  guards: {\n    hasReachedMaxRetries: ({ context }) => context.retries >= 3,\n    isAuthenticated: ({ context }) => context.userId !== null\n  },\n  delays: {\n    retryDelay: ({ context }) => Math.min(1000 * Math.pow(2, context.retries), 10000)\n  }\n});\n\nconst authMachine = userAuthSetup.createMachine({\n  id: 'auth',\n  initial: 'loggedOut',\n  context: { userId: null, retries: 0 },\n  states: {\n    loggedOut: {\n      on: {\n        LOGIN: { target: 'authenticating' }\n      }\n    },\n    authenticating: {\n      on: {\n        SUCCESS: {\n          target: 'loggedIn',\n          actions: 'setUser'\n        },\n        FAILURE: [\n          {\n            guard: 'hasReachedMaxRetries',\n            target: 'loggedOut',\n            actions: 'clearUser'\n          },\n          {\n            target: 'authenticating',\n            actions: 'incrementRetries'\n          }\n        ]\n      }\n    },\n    loggedIn: {\n      on: {\n        LOGOUT: {\n          target: 'loggedOut',\n          actions: 'clearUser'\n        }\n      }\n    }\n  }\n});\n\nconst authActor = createActor(authMachine);\nauthActor.start();\n\n```\n\n## Scaffold Vite Project for New Example\n\n```bash\npnpm create vite@latest my-example-react --template react-ts\ncd my-example-react\n```\n\n## Implement History States in XState JS\n\n```javascript\nimport { createMachine, createActor } from 'xstate';\n\nconst paymentMachine = createMachine({\n  id: 'payment',\n  initial: 'method',\n  states: {\n    method: {\n      initial: 'cash',\n      states: {\n        cash: {\n          on: {\n            SWITCH_CHECK: 'check'\n          }\n        },\n        check: {\n          on: {\n            SWITCH_CASH: 'cash'\n          }\n        },\n        hist: { type: 'history' }\n      },\n      on: { NEXT: 'review' }\n    },\n    review: {\n      on: { PREVIOUS: 'method.hist' }\n    }\n  }\n});\n\nconst actor = createActor(paymentMachine);\n\nactor.subscribe((state) => {\n  console.log(state.value);\n});\n\nactor.start();\n// logs {\n//   value: { method: 'cash' },\n// }\n\nactor.send({ type: 'SWITCH_CHECK' });\n// logs {\n//   value: { method: 'check' },\n// }\n\nactor.send({ type: 'NEXT' });\n// logs {\n//   value: 'review',\n// }\n\nactor.send({ type: 'PREVIOUS' });\n// logs {\n//   value: { method: 'check' },\n// }\n```\n\n## Integrate @xstate/store with Immer\n\n```typescript\nimport { createStoreWithProducer } from '@xstate/store';\nimport { produce } from 'immer'; // or { create } from 'mutative'\n\nconst donutStore = createStoreWithProducer(produce, {\n  context: {\n    donuts: 0,\n    favoriteFlavor: 'chocolate'\n  },\n  on: {\n    addDonut: (context) => {\n      context.donuts++; // \"Mutation\" (thanks to the producer)\n    },\n    changeFlavor: (context, event: { flavor: string }) => {\n      context.favoriteFlavor = event.flavor;\n    },\n    eatAllDonuts: (context) => {\n      context.donuts = 0;\n    }\n  }\n});\n\n// Everything else is the same!\n\n```\n\n## Using @xstate/immer with XState\n\n```javascript\nimport { createMachine, interpret } from 'xstate';\nimport { assign, createUpdater } from '@xstate/immer';\n\nconst levelUpdater = createUpdater('UPDATE_LEVEL', (ctx, { input }) => {\n  ctx.level = input;\n});\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  context: {\n    count: 0,\n    level: 0\n  },\n  initial: 'inactive',\n  states: {\n    inactive: {\n      on: {\n        TOGGLE: {\n          target: 'active',\n          // Immutably update context the same \"mutable\"\n          // way as you would do with Immer!\n          actions: assign((ctx) => ctx.count++)\n        }\n      }\n    },\n    active: {\n      on: {\n        TOGGLE: {\n          target: 'inactive'\n        },\n        // Use the updater for more convenience:\n        [levelUpdater.type]: {\n          actions: levelUpdater.action\n        }\n      }\n    }\n  }\n});\n\nconst toggleService = interpret(toggleMachine)\n  .onTransition((state) => {\n    console.log(state.context);\n  })\n  .start();\n\ntoggleService.send({ type: 'TOGGLE' });\n// { count: 1, level: 0 }\n\ntoggleService.send(levelUpdater.update(9));\n// { count: 1, level: 9 }\n\ntoggleService.send({ type: 'TOGGLE' });\n// { count: 2, level: 9 }\n\ntoggleService.send(levelUpdater.update(-100));\n// Notice how the level is not updated in 'inactive' state:\n// { count: 2, level: 9 }\n```\n\n## Persisting and Rehydrating State with useActor in SolidJS\n\n```javascript\n// ...\n\n// Get the persisted state config object from somewhere, e.g. localStorage\nconst persistedSnapshot = JSON.parse(localStorage.getItem('some-persisted-state-key')) || someMachine.initialState;\n\nconst App = () => {\n  const [snapshot, send] = useActor(someMachine, {\n    snapshot: persistedSnapshot\n  });\n\n  // snapshot will rehydrate the provided persisted snapshot, it won't be the machine's initial snapshot\n\n  return (/* ... */)\n}\n```\n\n## Vue 3: Use xstate Machine with useMachine Composition Function\n\n```vue\n<script setup>\nimport { useMachine } from '@xstate/vue';\nimport { createMachine } from 'xstate';\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: {\n      on: { TOGGLE: 'active' }\n    },\n    active: {\n      on: { TOGGLE: 'inactive' }\n    }\n  }\n});\n\nconst { snapshot, send } = useMachine(toggleMachine);\n</script>\n\n<template>\n  <button @click=\"send({ type: 'TOGGLE' })\">\n    {{ \n      snapshot.value === 'inactive'\n        ? 'Click to activate'\n        : 'Active! Click to deactivate'\n    }}\n  </button>\n</template>\n```\n\n## Use Optional Arrays for Actions/Transitions (XState)\n\n```javascript\n{\n  // This still works\n  onEntry: ['someEntryAction'],\n  onExit: [{ type: 'someExitAction' }],\n\n  // But you can do this instead, if you prefer:\n  onEntry: 'someEntryAction',\n  onExit: { type: 'someExitAction' }\n}\n```\n\n## Hierarchical State Machine in JavaScript (XState)\n\n```javascript\nimport { createMachine, createActor } from 'xstate';\n\nconst pedestrianStates = {\n  initial: 'walk',\n  states: {\n    walk: {\n      on: {\n        PED_TIMER: 'wait'\n      }\n    },\n    wait: {\n      on: {\n        PED_TIMER: 'stop'\n      }\n    },\n    stop: {}\n  }\n};\n\nconst lightMachine = createMachine({\n  id: 'light',\n  initial: 'green',\n  states: {\n    green: {\n      on: {\n        TIMER: 'yellow'\n      }\n    },\n    yellow: {\n      on: {\n        TIMER: 'red'\n      }\n    },\n    red: {\n      on: {\n        TIMER: 'green'\n      },\n      ...pedestrianStates\n    }\n  }\n});\n\nconst actor = createActor(lightMachine);\n\nactor.subscribe((state) => {\n  console.log(state.value);\n});\n\nactor.start();\n// logs 'green'\n\nactor.send({ type: 'TIMER' });\n// logs 'yellow'\n\nactor.send({ type: 'TIMER' });\n// logs { red: 'walk' }\n\nactor.send({ type: 'PED_TIMER' });\n// logs { red: 'wait' }\n```\n\n## Create XState Store with Type Inference (TypeScript)\n\n```typescript\nimport { createStore } from '@xstate/store';\n\nconst donutStore = createStore({\n  // Context inferred as:\n  // {\n  //   donuts: number;\n  //   favoriteFlavor: string;\n  // }\n  context: {\n    donuts: 0,\n    favoriteFlavor: 'chocolate'\n  },\n  on: {\n    // Event inferred as:\n    // {\n    //   type: 'changeFlavor';\n    //   flavor: string;\n    // }\n    changeFlavor: (context, event: { flavor: string }) => {\n      context.favoriteFlavor = event.flavor;\n    }\n  }\n});\n\ndonutStore.getSnapshot().context.favoriteFlavor; // string\n\ndonutStore.send({\n  type: 'changeFlavor', // Strongly-typed from transition key\n  flavor: 'strawberry' // Strongly-typed from { flavor: string }\n});\n```\n\nContext7 cache for task_state: cached at 2026-01-31T02:26:56.246382+00:00Z; consider refreshing if docs changed.",
    "library": "task_state",
    "topic": "best-practices",
    "source": "cache"
  },
  "source": "cache",
  "saved_at": "2026-01-30T18:26:56.337884"
}