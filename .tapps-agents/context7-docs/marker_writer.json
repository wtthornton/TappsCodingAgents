{
  "library": "marker_writer",
  "topic": null,
  "documentation": {
    "content": "## Implement AudienceDisplay Lifecycle Hooks in Kotlin\n\n```kotlin\nclass ExampleAudienceDisplay : AudienceDisplay() {  \n    override fun initialize() {  \n        // This is called when the first player is added to the audience.  \n        super.initialize()\n        // Do something when the audience is initialized  \n    }\n\n    override fun onPlayerAdd(player: Player) {  \n        // Do something when a player gets added to the audience  \n    }\n\n    override fun onPlayerRemove(player: Player) {  \n        // Do something when a player gets removed from the audience  \n    }\n\n    override fun dispose() {  \n        super.dispose()\n        // Do something when the audience is disposed  \n        // It will always call onPlayerRemove for all players.  \n        // So no player cleanup is needed here.  \n    }\n}\n\n```\n\n## Kotlin PathStreamDisplay Implementation Example\n\n```kotlin\nclass ExampleParticleDisplay(private val player: Player) : PathStreamDisplay {\n    override fun display(position: Position) {\n        player.spawnParticle(Particle.FLAME, position.x, position.y, position.z, 1)\n    }\n\n    override fun dispose() {\n        // As path stream displays are stateful, you can clean up resources here if needed.\n    }\n}\n\n```\n\n## Implement Basic SingleFilter in Kotlin\n\n```kotlin\nimport java.util.Optional\nimport java.util.UUID\nimport java.util.concurrent.ConcurrentHashMap\nimport kotlin.reflect.KClass\n\n// Assuming Player, Colors, AudienceFilterEntry, PriorityEntry, AudienceEntry, Ref, AudienceFilter, PlayerExampleDisplay, PlayerSingleDisplay, SingleFilter are defined elsewhere.\n\n@Entry(\"example_single_filter\", \"An example single filter entry\", Colors.MYRTLE_GREEN, \"material-symbols:filter-alt\")\nclass ExampleSingleFilterEntry(\n    override val id: String = \"\",\n    override val name: String = \"\",\n    override val priorityOverride: Optional<Int> = Optional.empty(),\n) : AudienceFilterEntry, PriorityEntry {\n    override val children: List<Ref<out AudienceEntry>> get() = emptyList()\n\n    override suspend fun display(): AudienceFilter = ExampleSingleFilter(ref()) {\n        player -> PlayerExampleDisplay(player, ExampleSingleFilter::class, ref())\n    }\n}\n\nprivate class ExampleSingleFilter(\n    ref: Ref<ExampleSingleFilterEntry>,\n    createDisplay: (Player) -> PlayerExampleDisplay,\n) : SingleFilter<ExampleSingleFilterEntry, PlayerExampleDisplay>(ref, createDisplay) {\n    // This must be a references to a shared map.\n    // It CANNOT cache the map itself.\n    override val displays: MutableMap<UUID, PlayerExampleDisplay>\n        get() = map\n\n    companion object {\n        // This map is shared between all instances of the filter.\n        private val map = ConcurrentHashMap<UUID, PlayerExampleDisplay>()\n    }\n}\n\nprivate class PlayerExampleDisplay(\n    player: Player,\n    displayKClass: KClass<out SingleFilter<ExampleSingleFilterEntry, *>>,\n    current: Ref<ExampleSingleFilterEntry>\n) : PlayerSingleDisplay<ExampleSingleFilterEntry>(player, displayKClass, current) {\n    override fun setup() {\n        super.setup()\n        player.sendMessage(\"Display activated!\")\n    }\n\n    override fun tearDown() {\n        super.tearDown()\n        player.sendMessage(\"Display deactivated!\")\n    }\n}\n```\n\n## AudienceDisplay Lifecycle Implementation in Kotlin\n\n```kotlin\nclass ExampleAudienceDisplay : AudienceDisplay() {  \n    override fun initialize() {  \n        // This is called when the first player is added to the audience.  \n        super.initialize()  \n        // Do something when the audience is initialized  \n    }  \n  \n    override fun onPlayerAdd(player: Player) {  \n        // Do something when a player gets added to the audience  \n    }  \n  \n    override fun onPlayerRemove(player: Player) {  \n        // Do something when a player gets removed from the audience  \n    }  \n  \n    override fun dispose() {  \n        super.dispose()  \n        // Do something when the audience is disposed  \n        // It will always call onPlayerRemove for all players.  \n        // So no player cleanup is needed here.  \n    }  \n}\n\n```\n\n## Manage SingleFilter Display Lifecycle in Kotlin\n\n```kotlin\nimport java.util.UUID\nimport kotlin.reflect.KClass\n\n// Assuming Player, SingleFilter, ExampleSingleFilterEntry, PlayerSingleDisplay are defined elsewhere.\n\nprivate class ComplexPlayerDisplay(\n    player: Player,\n    displayKClass: KClass<out SingleFilter<ExampleSingleFilterEntry, *>>,\n    current: Ref<ExampleSingleFilterEntry>\n) : PlayerSingleDisplay<ExampleSingleFilterEntry>(player, displayKClass, current) {\n    override fun initialize() {\n        super.initialize()\n        // Called once when the display is first created\n        player.sendMessage(\"Display initialized!\")\n    }\n\n    override fun setup() {\n        super.setup()\n        // Called every time this display becomes active\n        player.sendMessage(\"Display setup!\")\n    }\n\n    override fun tick() {\n        // Called every tick while the display is active\n        // Update display content here\n    }\n\n    override fun tearDown() {\n        super.tearDown()\n        // Called when this display becomes inactive\n        player.sendMessage(\"Display torn down!\")\n    }\n\n    override fun dispose() {\n        super.dispose()\n        // Called when the display is being completely removed\n        player.sendMessage(\"Display disposed!\")\n    }\n}\n```\n\n## SingleFilter Display Lifecycle Example\n\n```kotlin\nprivate class ComplexPlayerDisplay(  \n    player: Player,  \n    displayKClass: KClass<out SingleFilter<ExampleSingleFilterEntry, *>>,  \n    current: Ref<ExampleSingleFilterEntry>  \n) : PlayerSingleDisplay<ExampleSingleFilterEntry>(player, displayKClass, current) {  \n    override fun initialize() {  \n        super.initialize()  \n        // Called once when the display is first created  \n        player.sendMessage(\"Display initialized!\")  \n    }  \n  \n    override fun setup() {  \n        super.setup()  \n        // Called every time this display becomes active  \n        player.sendMessage(\"Display setup!\")  \n    }  \n  \n    override fun tick() {  \n        // Called every tick while the display is active  \n        // Update display content here  \n    }  \n  \n    override fun tearDown() {  \n        super.tearDown()  \n        // Called when this display becomes inactive  \n        player.sendMessage(\"Display torn down!\")  \n    }  \n  \n    override fun dispose() {  \n        super.dispose()  \n        // Called when the display is being completely removed  \n        player.sendMessage(\"Display disposed!\")  \n    }  \n}  \n\n```\n\n## Implement Basic Interaction with Kotlin\n\n```kotlin\nclass ExampleInteraction(\n    val player: Player,\n    override val context: InteractionContext,\n    override val priority: Int,\n    val eventTriggers: List<EventTrigger>\n) : Interaction { \n    override suspend fun initialize(): Result<Unit> {\n        if (Random.nextBoolean()) {\n            // Failing during initialization makes it so that the interaction will be stopped.  \n            return failure(\"Failed to initialize\")  \n        }\n\n        // Setup your interaction state  \n        player.sendMessage(\"Starting interaction!\")  \n\n        return ok(Unit)\n    }\n\n    override suspend fun tick(deltaTime: Duration) {\n        // Update your interaction state  \n        if (shouldEnd()) {\n            // Trigger the stop event when done  \n            ExampleStopTrigger.triggerFor(player, context)\n        }\n    }\n\n    override suspend fun teardown() {\n        // Cleanup your interaction state  \n        player.sendMessage(\"Ending interaction!\")\n    }\n\n    private fun shouldEnd(): Boolean = false // Your end condition  \n}\n\n```\n\n## Implement Tickable Audience Display in Kotlin\n\n```kotlin\nclass TickableAudienceDisplay : AudienceDisplay(), TickableDisplay {  \n    override fun onPlayerAdd(player: Player) {}  \n    override fun onPlayerRemove(player: Player) {}  \n  \n    override fun tick() {  \n        // Do something when the audience is ticked  \n        players.forEach { player ->  \n            // Do something with the player  \n        }  \n  \n        // This is running asynchronously  \n        // If you need to do something on the main thread  \n        Dispatchers.Sync.launch {  \n            // Though this will run a tick later, to sync with the bukkit scheduler.  \n        }  \n    }  \n}\n\n```\n\n## Dynamic Audience Filtering with Health Range in Kotlin\n\n```kotlin\nclass HealthAudienceFilter(\n    ref: Ref<out AudienceFilterEntry>,\n    private val healthRange: ClosedFloatingPointRange<Float> = 0f..20f\n) : AudienceFilter(ref), TickableDisplay {\n    override fun filter(player: Player): Boolean {\n        return player.health in healthRange\n    }\n\n    // You can refresh the filters on events\n    @EventHandler\n    fun healthRegent(event: EntityRegainHealthEvent) {\n        val player = event.entity as? Player ?: return\n        // Reruns the filter\n        player.refresh()\n\n        // Or if you know the player should be filtered, you can update the filter directly\n        player.updateFilter(isFiltered = event.amount in healthRange)\n    }\n\n    // It is also possible to run the filter every tick\n    override fun tick() {\n        // Refresh the filter for all considered players\n        consideredPlayers.forEach { it.refresh() }\n    }\n}\n\n```\n\n## Invertible Audience Filter Example in Kotlin\n\n```kotlin\n@Entry(\"inverted_example_audience_filter\", \"An example audience filter.\", Colors.MYRTLE_GREEN, \"material-symbols:filter-alt\")\nclass InvertedExampleAudienceFilterEntry(\n    override val id: String = \"\",\n    override val name: String = \"\",\n    override val children: List<Ref<out AudienceEntry>> = emptyList(),\n    override val inverted: Boolean = true,\n) : AudienceFilterEntry, Invertible {\n    override suspend fun display(): AudienceFilter = ExampleAudienceFilter(ref())\n}\n\n```\n",
    "library": "marker_writer",
    "topic": "overview",
    "source": "api"
  },
  "source": "api",
  "saved_at": "2026-01-30T16:09:21.721366"
}