{
  "library": "pydantic",
  "topic": "examples",
  "documentation": {
    "content": "## Use Parametrized Generic Models as Field Types\n\n```python\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass ResponseModel(BaseModel, Generic[T]):\n    content: T\n\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n\nclass Order(BaseModel):\n    id: int\n    product: ResponseModel[Product]\n\n\nproduct = Product(name='Apple', price=0.5)\nresponse = ResponseModel[Product](content=product)\norder = Order(id=1, product=response)\nprint(repr(order))\n\"\"\"\nOrder(id=1, product=ResponseModel[Product](content=Product(name='Apple', price=0.5)))\n\"\"\"\n```\n\n## Extend Base Model with create_model using __base__\n\n```python\nfrom pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple=(str, 'russet'),\n    banana=(str, 'yellow'),\n    __base__=FooModel,\n)\nprint(BarModel)\n#> <class '__main__.BarModel'>\nprint(BarModel.model_fields.keys())\n#> dict_keys(['foo', 'bar', 'apple', 'banana'])\n```\n\n## Define Nested Model Hierarchies in Pydantic\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple: str = 'x'\n    banana: str = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\nprint(m.model_dump())\n```\n\n## Model Validator with Generic Types in Pydantic\n\n```python\nfrom typing import Any, Generic, Self, TypeVar\n\nfrom pydantic import BaseModel, model_validator\n\nT = TypeVar('T')\n\n\nclass GenericModel(BaseModel, Generic[T]):\n    a: T\n\n    @model_validator(mode='after')\n    def validate_after(self: Self) -> Self:\n        print('after validator running custom validation...')\n        return self\n\n\nclass Model(BaseModel):\n    inner: GenericModel[Any]\n\n\nm = Model.model_validate(Model(inner=GenericModel[int](a=1)))\n#> after validator running custom validation...\n#> after validator running custom validation...\nprint(repr(m))\n#> Model(inner=GenericModel[Any](a=1))\n```\n\n## Pydantic Dynamic Model Creation with create_model\n\n```python\nfrom pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=str, bar=(int, 123))\n```\n\n## Configure Pydantic Model with `model_config` (Python)\n\n```python\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    model_config = dict(frozen=True)\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\n## Create Pydantic Self-Referencing Model with Optional Field\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    sibling: 'Optional[Foo]' = None\n\n\nprint(Foo())\n# > a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n# > a=123 sibling=Foo(a=321, sibling=None)\n```\n\n## Create Dynamic Model with Field and Annotated\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PrivateAttr, create_model\n\nDynamicModel = create_model(\n    'DynamicModel',\n    foo=(str, Field(alias='FOO')),\n    bar=Annotated[str, Field(description='Bar field')],\n    _private=(int, PrivateAttr(default=1)),\n)\n\n\nclass StaticModel(BaseModel):\n    foo: str = Field(alias='FOO')\n    bar: Annotated[str, Field(description='Bar field')]\n    _private: int = PrivateAttr(default=1)\n```\n\n## Create Pydantic Model Copies with optional updates and deep copy in Python\n\n```python\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.model_copy(update={'banana': 0}))\n# > banana=0 foo='hello' bar=BarModel(whatever=123)\n\n# normal copy gives the same object reference for bar:\nprint(id(m.bar) == id(m.model_copy().bar))\n# > True\n# deep copy gives a new object reference for `bar`:\nprint(id(m.bar) == id(m.model_copy(deep=True).bar))\n# > False\n```\n\n## Pickle Pydantic Models for Serialization in Python\n\n```python\nimport pickle\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\ndata = pickle.dumps(m)\nprint(data[:20])\nm2 = pickle.loads(data)\nprint(m2)\n```",
    "library": "pydantic",
    "topic": "models",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T16:11:11.141197"
}