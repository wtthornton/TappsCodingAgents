{
  "library": "customization_schema",
  "topic": "examples",
  "documentation": {
    "content": "## ValidationErrors: Creating and Manipulating Errors\n\n```js\nimport {Map} from \"immutable\"\nimport {createValidatorErrors, ERROR_NOT_SET} from \"@ui-schema/ui-schema\"\n\nerrors = errors.addError(ERROR_NOT_SET)\n\n// with context, e.g. for detailed error messages\nerrors = errors.addError(ERROR_NOT_SET, Map({}))\n\nerrors.hasError(ERROR_NOT_SET) // true!\nerrors.hasError('custom-error') // false!\n\ntypeErrors = errors.getError(ERROR_NOT_SET)\n\nconsole.log(errors.errCount) // 2\n\ntypeErrors.forEach(errorContext => {\n    // multiple errors for the same type\n    // maybe different contexts, the context is a `Map`, even when empty\n    let info = errorContext.get('info')\n    if(info) {\n    } else {\n    }\n})\n\nlet tmpError = createValidatorErrors() // create an empty Record\ntmpError.addErrors(errors) // add the errors of e.g. another validation function to the actual errors\n```\n\n## ValidationErrors Type and Methods\n\n```APIDOC\nValidationErrors Type Properties and Methods:\n  - errCount: {number} Total count of errors.\n  - errors: {Map<{}, undefined>} Map of errors for the current widget.\n  - childErrors: {Map<{}, undefined>} Map of errors for child widgets.\n  - errorsToJS: {() => any} Converts errors to a plain JavaScript object.\n  - hasError: {(type?: string) => boolean} Checks if an error of a specific type exists.\n  - addError: {(type: string, context?: Map<any, any>) => ValidatorErrorsType} Adds a new error with an optional context.\n  - addErrors: {(errors: ValidatorErrorsType) => ValidatorErrorsType} Adds multiple errors from another ValidatorErrorsType instance.\n  - getError: {(type: string) => List<any>} Retrieves a list of errors for a specific type.\n  - getErrors: {() => Map<{ [key: string]: List<any> }, undefined>} Retrieves all errors.\n  - addChildError: {(type: string, context?: Map<any, any>) => ValidatorErrorsType} Adds a new child error with an optional context.\n  - addChildErrors: {(errors: ValidatorErrorsType) => ValidatorErrorsType} Adds multiple child errors from another ValidatorErrorsType instance.\n  - getChildError: {(type: string) => List<any>} Retrieves a list of child errors for a specific type.\n  - getChildErrors: {() => Map<{ [key: string]: List<any> }, undefined>} Retrieves all child errors.\n```\n\n## Define Multi-language Pattern Error Message in UI-Schema\n\n```json\n{\n    \"pattern\": \"^(\\\\([0-9]{3}\\\\))?[0-9]{3}-[0-9]{4}$\",\n    \"patternError\": {\n        \"en\": \"be a valid zip code\",\n        \"de\": \"eine g\u00fcltige PLZ\"\n    }\n}\n```\n\n## validateSchema Function and Included Handlers\n\n```APIDOC\nvalidateSchema(schema, value, ...)\n  - Purpose: Exports the validation functions used by the plugins for usage outside of the render tree.\n  - Return Value: `ValidatorErrorsType`, initialized by `createValidatorErrors`.\n  - Included Handlers:\n    - validateType\n    - validatePattern\n    - validateConst\n    - validateEnum\n    - validateMinMax\n    - validateMultipleOf\n    - validateObject\n    - validateContains\n  - `not` Keyword Support: Supports the `not` keyword for any validation. When `not` is specified, its sub-schema is evaluated exclusively.\n```\n\n## Merge JSON Schemas with mergeSchema\n\n```APIDOC\nmergeSchema(a, b)\n  - Merges two schemas into each other: ab = mergeSchema(a, b)\n  - Supported keywords (only if existing on b):\n    - properties: deep-merge b into a\n    - required: combining both arrays/lists\n    - type: b overwrites a\n    - format: b overwrites a\n    - widget: b overwrites a\n    - enum: b overwrites a\n    - const: b overwrites a\n    - not: b overwrites a\n    - allOf: ignored, should be resolved by e.g. combining handler\n    - if, then, else: ignored, should be resolved by e.g. conditional handler, also if that are inside allOf\n```\n\n## Advanced RichContent Schema Example\n\n```javascript\nconst schema = {\n    type: 'array',\n    widget: 'RichContent',\n    editor: {\n        spellCheck: true,\n        enableOnly: [\n            'p',\n            'h1',\n            'h2',\n            'h3',\n            'bold',\n        ],\n        initialRoot: 'h1',\n    },\n    view: {\n        noUnderline: true,\n        linkMd: 'https://example.org/markdown',\n        enableKeyMd: true,\n    },\n}\n```\n\n## UI-Schema Validation Plugin Reference\n\n```APIDOC\nValidation Plugins:\n\n- minMaxValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: validateMinMax\n  - Handles: min/max validity\n  - Added Props: valid, errors\n\n- typeValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: validateType\n  - Handles: keyword `type`\n  - Added Props: valid, errors\n\n- valueValidatorConst\n  - Package: @ui-schema/ui-schema\n  - Validity Function: validateConst\n  - Handles: keywords `const`\n  - Added Props: valid, errors\n\n- valueValidatorEnum\n  - Package: @ui-schema/ui-schema\n  - Validity Function: validateEnum\n  - Handles: keywords `enum`\n  - Added Props: valid, errors\n\n- multipleOfValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: validateMultipleOf\n  - Handles: keywords `type:number,integer`, `multipleOf`\n  - Added Props: valid, errors\n  - Notes: Applies custom float conversions to mitigate JS precision issues for `multipleOf`.\n\n- patternValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: validatePattern\n  - Handles: keywords `type:string`, `pattern`\n  - Added Props: valid, errors\n  - Notes: Supports `patternError` keyword for human-understandable, translatable error messages.\n\n- oneOfValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: validateOneOf\n  - Handles: keywords `type:*`, `oneOf`\n  - Added Props: valid, errors\n\n- arrayValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: (None specified, handled by `validateSchema`)\n  - Handles: `type:array`\n  - Added Props: valid, errors\n\n- objectValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: (None specified)\n  - Handles: `type:object`, keywords `additionalProperties`, `propertyNames`\n  - Added Props: valid, errors\n\n- requiredValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: checkValueExists\n  - Handles: keywords `type:object`, `required`\n  - Added Props: valid, errors, required\n\n- emailValidator\n  - Package: @ui-schema/ui-schema\n  - Validity Function: (None specified)\n  - Handles: keywords `type:object`, `required` (likely a typo, should be `type:string`, `format:email`)\n  - Added Props: valid, errors\n\n- sub-schema validation/array validation is done by `validateSchema`.\n```\n\n## ConditionalHandler Schema Example with If/Then/Else Logic\n\n```js\nconst schemaWConditional = createOrderedMap({\n    type: 'object',\n    properties: {\n        country: {\n            type: 'string',\n            widget: 'Select',\n            enum: [\n                'usa',\n                'canada',\n                'eu'\n            ],\n            default: 'eu'\n        }\n    },\n    required: [\n        'country'\n    ],\n    if: {\n        properties: {\n            'country': {\n                type: 'string',\n                const: 'canada'\n            }\n        },\n        required: ['country']\n    },\n    then: {\n        properties: {\n            'maple_trees': {\n                type: 'number'\n            }\n        }\n    },\n    else: {\n        properties: {\n            'accept': {\n                type: 'boolean',\n                const: true\n            }\n        },\n        required: [\n            'accept'\n        ]\n    }\n});\n```\n\n## Custom Error Translation Component with UI-Schema\n\n```jsx\nimport React from \"react\";\nimport FormHelperText from \"@mui/material/FormHelperText\";\nimport {Trans} from '@ui-schema/ui-schema/Translate/Trans';\n\nconst LocaleHelperText = ({text, schema, context}) => {\n    return <FormHelperText>\n        <Trans\n            text={text}\n            context={\n                /* adding some default stuff to the context which may be needed */\n                context.set('type', schema.get('type'))\n                    .set('widget', schema.get('widget'))\n            }\n            // errors need no fallback and no schema keyword `t` or `tt` support\n        />\n    </FormHelperText>\n};\n```\n\n## Basic RichContent Schema Example\n\n```javascript\nconst schema = {\n    type: 'array',\n    widget: 'RichContent',\n    editor: {\n        placeholder: 'Write something great!',\n    },\n    view: {\n        hideMd: true,\n    },\n}\n```",
    "library": "customization_schema",
    "topic": "common-mistakes",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:27:22.290851"
}