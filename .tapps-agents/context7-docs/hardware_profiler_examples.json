{
  "library": "hardware_profiler",
  "topic": "examples",
  "documentation": {
    "content": "## Implement Feature Flags for A/B Testing (PowerShell)\n\n```powershell\n# In your script (MyScript.ps1), wrap code changes with feature flags:\n#\n# if ($_profiler) {\n#     # New optimized code\n#     $values = [System.Linq.Enumerable]::Range(1, 10000)\n#     $result = foreach ($v in $values) { $v + 10 }\n# }\n# else {\n#     # Original slow code\n#     $values = 1..10000\n#     $result = @()\n#     foreach ($v in $values) { $result += $v + 10 }\n# }\n\n# Compare performance with Invoke-Script\n$flag = @{ _profiler = $true }\nInvoke-Script -ScriptBlock { & \"./MyScript.ps1\" } -Repeat 5 -Flag $flag\n\n# Profile \"after\" changes\n$traceAfter = Trace-Script -ScriptBlock { & \"./MyScript.ps1\" } -Flag $flag\n$traceAfter.TotalDuration  # e.g., 00:00:00.234\n\n# Profile \"before\" changes (all flags set to $false)\n$traceBefore = Trace-Script -ScriptBlock { & \"./MyScript.ps1\" } -Flag $flag -Before\n$traceBefore.TotalDuration  # e.g., 00:00:02.456\n\n# Multiple independent flags for granular testing\n$flags = @{\n    _useLinq = $true\n    _parallelProcessing = $false\n    _cacheResults = $true\n}\nInvoke-Script -ScriptBlock { & \"./MyScript.ps1\" } -Repeat 3 -Flag $flags\n```\n\n## Analyze Trace Results for Performance Bottlenecks (PowerShell)\n\n```powershell\n# Profile a script\n$trace = Trace-Script -ScriptBlock { & \"./MyScript.ps1\" }\n\n# Explore available properties\n$trace | Get-Member\n\n# Top 50 views available:\n$trace.Top50Duration           # Lines by total duration (including called code)\n$trace.Top50SelfDuration       # Lines by self duration (excluding called code)\n$trace.Top50HitCount           # Lines by execution count\n$trace.Top50FunctionDuration   # Functions by total duration\n$trace.Top50FunctionSelfDuration # Functions by self duration\n$trace.Top50FunctionHitCount   # Functions by call count\n$trace.Top50SelfMemory         # Lines by memory allocation\n$trace.Top50Memory             # Lines by total memory\n\n# Drill into a specific slow line\n$slowLine = $trace.Top50Duration | Where-Object Text -match 'Invoke-WebRequest'\n$slowLine | Format-List\n\n# See all hits (executions) of that line\n$slowLine.Hits | Format-Table\n\n# Analyze what happened between a function call and its return\n$hit = $slowLine.Hits[0]\n$trace.Events[$hit.Index..$hit.ReturnIndex] | Format-Table\n\n# Find top consumers within a specific call\n$trace.Events[$hit.Index..$hit.ReturnIndex] |\n    Sort-Object -Descending SelfDuration |\n    Select-Object -First 10 |\n    Format-Table\n\n# Filter all lines by file\n$trace.AllLines | Where-Object Path -like '*MyModule*' | Format-Table\n\n# Get total execution time\n$trace.TotalDuration\n\n# Access raw events for custom analysis\n$trace.Events |\n    Where-Object { $_.SelfDuration.TotalMilliseconds -gt 10 } |\n    Sort-Object -Descending SelfDuration |\n    Format-Table Path, Line, Text, SelfDuration\n```\n\n## Retrieve Latest Trace with Get-LatestTrace in PowerShell\n\n```powershell\n# Run profiling without capturing output\nTrace-Script -ScriptBlock { & \"./MyScript.ps1\" }\n# Output: \"Looks like you did not assign the output to a variable...\"\n\n# Retrieve the trace afterward\n$trace = Get-LatestTrace\n\n# Now explore the results\n$trace.Top50SelfDuration | Format-Table\n$trace.Top50FunctionDuration | Format-Table\n\n# Access all profiled lines\n$trace.AllLines | Where-Object { $_.Duration.TotalMilliseconds -gt 100 } | Format-Table\n\n# Access raw trace events\n$trace.Events | Select-Object -First 10 | Format-Table\n```\n\n## Identify Slowest Line and Get Call Stack (PowerShell)\n\n```powershell\n# Find a slow line\n$slowLine = $trace.Top50SelfDuration | Select-Object -First 1\n\n# Get the call stack for the first hit of that line\n$hit = $slowLine.Hits[0]\nGet-CallStack -Hit $hit | Format-Table\n```\n\n## Profile Script Blocks with Memory Tracking in PowerShell\n\n```powershell\n$trace = Trace-Script -ScriptBlock {\n    $list = [System.Collections.Generic.List[int]]::new()\n\n    # Inefficient: array concatenation creates new array each iteration\n    $array = @()\n    foreach ($i in 1..1000) {\n        $array += $i  # High memory allocation\n    }\n\n    # Efficient: List.Add() modifies in place\n    foreach ($i in 1..1000) {\n        $list.Add($i)  # Low memory allocation\n    }\n\n    # Memory-intensive operation\n    $processes = Get-Process\n}\n\n# View top memory consumers\n$trace.Top50SelfMemory | Format-Table\n\n# View total memory by line (including called code)\n$trace.Top50Memory | Format-Table\n\n# Filter lines with high memory allocation\n$trace.AllLines |\n    Where-Object { $_.SelfMemory -gt 1MB } |\n    Sort-Object -Descending SelfMemory |\n    Format-Table Path, Line, Text, SelfMemory, SelfMemoryPercent\n```\n\n## Visualize Script Execution Flow (PowerShell)\n\n```powershell\n# Profile and visualize execution\n$trace = Trace-Script -ScriptBlock { & \"./MyScript.ps1\" }\n\n# Show execution flow (instant display)\nShow-ScriptExecution -Trace $trace\n\n# Show execution with 10x slowdown to mimic real timing\nShow-ScriptExecution -Trace $trace -x10\n\n# Show execution with 100x slowdown\nShow-ScriptExecution -Trace $trace -x100\n\n# Use without specifying trace (uses Get-LatestTrace)\nTrace-Script -ScriptBlock { & \"./MyScript.ps1\" }\nShow-ScriptExecution\n```\n\n## Retrieve Latest Trace Data\n\n```powershell\nInvoke-Script -ScriptBlock $scriptBlock -Preheat 0 -Repeat 3 -Flag $flag\n\n# Output:\n# Looks like you did not assign the output to a variable. Use Get-LatestTrace to retrieve the trace, e.g.: $trace = Get-LatestTrace\n\n$trace = Get-LatestTrace\n$trace.Top50Duration\n```\n\n## Memory Profiling for Allocation Analysis (PowerShell)\n\n```powershell\n# Memory profiling is typically done by accessing properties like:\n# $trace.Top50SelfMemory\n# $trace.Top50Memory\n# These properties would be populated after running Trace-Script.\n```\n\n## Trace Script Execution and Export Results\n\n```powershell\n$trace =  Trace-Script -ScriptBlock { & \"demo-scripts/Get-Icons.ps1\" } -ExportPath icons\n$trace.Top50SelfDuration\n```\n\n## Measure PowerShell Script Execution Time with Invoke-Script\n\n```powershell\n# Basic execution timing with 3 repetitions\nInvoke-Script -ScriptBlock { & \"./MyScript.ps1\" } -Repeat 3\n\n# Compare before and after performance with feature flags\n# Your script should contain: if ($_profiler) { <new code> } else { <old code> }\n$flag = @{ _profiler = $true }\nInvoke-Script -ScriptBlock { & \"./MyScript.ps1\" } -Preheat 2 -Repeat 5 -Flag $flag\n\n# Output shows color-coded comparison:\n# Run 1: 00:00:00.5234 -> 00:00:00.3127 (-210 ms)  # Green = improvement\n# Run 2: 00:00:00.4891 -> 00:00:00.2984 (-191 ms)\n# Run 3: 00:00:00.5012 -> 00:00:00.3056 (-196 ms)\n\n# Use multiple feature flags for granular testing\n$flags = @{\n    _useLinq = $true      # Test LINQ vs native\n    _parallelLoop = $true # Test parallel processing\n}\nInvoke-Script -ScriptBlock { & \"./MyScript.ps1\" } -Repeat 3 -Flag $flags\n```",
    "library": "hardware_profiler",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:24:29.669987"
}