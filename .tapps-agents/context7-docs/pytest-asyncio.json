{
  "library": "pytest-asyncio",
  "topic": null,
  "documentation": {
    "content": "## Parametrization with Async Tests in pytest\n\n```python\nimport asyncio\nimport pytest\nimport pytest_asyncio\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"value\", [1, 2, 3, 4, 5])\nasync def test_parametrized_async(value):\n    await asyncio.sleep(0.01)\n    result = await compute(value)\n    assert result == value * 2\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"x,y,expected\", [\n    (1, 2, 3),\n    (5, 3, 8),\n    (10, -5, 5),\n])\nasync def test_async_addition(x, y, expected):\n    result = await async_add(x, y)\n    assert result == expected\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"url\", [\n    \"http://example.com\",\n    \"http://example.org\",\n    \"http://example.net\",\n])\nasync def test_multiple_endpoints(url):\n    response = await fetch_url(url)\n    assert response.status == 200\n\n# Parametrized async fixtures\n@pytest_asyncio.fixture(params=[\"sqlite\", \"postgres\", \"mysql\"])\nasync def database(request):\n    db = await connect_database(request.param)\n    yield db\n    await db.close()\n\n@pytest.mark.asyncio\nasync def test_with_parametrized_fixture(database):\n    await database.execute(\"SELECT 1\")\n    assert database.is_connected()\n\nasync def compute(value):\n    await asyncio.sleep(0.01)\n    return value * 2\n\nasync def async_add(x, y):\n    await asyncio.sleep(0.01)\n    return x + y\n\nasync def fetch_url(url):\n    await asyncio.sleep(0.01)\n    return MockResponse(200)\n\nclass MockResponse:\n    def __init__(self, status):\n        self.status = status\n\nasync def connect_database(db_type):\n    await asyncio.sleep(0.01)\n    return MockDatabase(db_type)\n\nclass MockDatabase:\n    def __init__(self, db_type):\n        self.db_type = db_type\n\n    async def execute(self, query):\n        await asyncio.sleep(0.01)\n        return []\n\n    async def close(self):\n        pass\n\n    def is_connected(self):\n        return True\n```\n\n## Parametrize Async Test Function with pytest-asyncio\n\n```python\nimport asyncio\n\nimport pytest\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"value\", [1, 2, 3])\nasync def test_parametrized_async_function(value):\n    await asyncio.sleep(1)\n    assert value > 0\n```\n\n## Parametrize Event Loop Policy for Async Tests\n\n```python\nimport asyncio\nimport warnings\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", DeprecationWarning)\n    from asyncio import DefaultEventLoopPolicy\n\nimport pytest\n\n\nclass CustomEventLoopPolicy(DefaultEventLoopPolicy):\n    pass\n\n\n@pytest.fixture(\n    scope=\"session\",\n    params=(\n        CustomEventLoopPolicy(),\n        CustomEventLoopPolicy(),\n    ),\n)\ndef event_loop_policy(request):\n    return request.param\n\n\n@pytest.mark.asyncio\n@pytest.mark.filterwarnings(\"ignore::DeprecationWarning\")\nasync def test_uses_custom_event_loop_policy():\n    assert isinstance(asyncio.get_event_loop_policy(), CustomEventLoopPolicy)\n\n```\n\n## Parametrized Event Loop Policy Fixture\n\n```python\nimport asyncio\nimport pytest\n\nclass WindowsSelectorEventLoopPolicy(asyncio.DefaultEventLoopPolicy):\n    pass\n\nclass UnixDefaultEventLoopPolicy(asyncio.DefaultEventLoopPolicy):\n    pass\n\n@pytest.fixture(\n    scope=\"session\",\n    params=[WindowsSelectorEventLoopPolicy, UnixDefaultEventLoopPolicy]\n)\ndef event_loop_policy(request):\n    return request.param()\n\n@pytest.mark.asyncio\nasync def test_with_different_policies():\n    # This test runs twice, once for each policy\n    await asyncio.sleep(0.01)\n    assert asyncio.get_running_loop() is not None\n```\n\n## Create Async Fixtures with @pytest_asyncio.fixture\n\n```python\nimport asyncio\nimport pytest\nimport pytest_asyncio\n\nasync def create_connection(url):\n    await asyncio.sleep(0.01)\n    return MockConnection()\n\nclass MockConnection:\n    async def execute(self, query):\n        await asyncio.sleep(0.01)\n        return 1\n    async def close(self):\n        pass\n\nclass AsyncCache:\n    @classmethod\n    async def create(cls):\n        await asyncio.sleep(0.01)\n        return cls()\n    async def set(self, key, value):\n        pass\n    async def get(self, key):\n        return True\n    async def clear(self):\n        pass\n    async def close(self):\n        pass\n\nasync def compute_value(param):\n    return param * 2\n\nasync def expensive_setup():\n    await asyncio.sleep(0.01)\n    return MockResource()\n\nclass MockResource:\n    async def cleanup(self):\n        pass\n\n@pytest_asyncio.fixture\nasync def database_connection():\n    # Setup: create async connection\n    conn = await create_connection(\"postgresql://localhost/test\")\n    await conn.execute(\"CREATE TABLE IF NOT EXISTS test_table (id INT, value TEXT)\")\n\n    yield conn\n\n    # Teardown: cleanup\n    await conn.execute(\"DROP TABLE test_table\")\n    await conn.close()\n\n@pytest_asyncio.fixture(scope=\"module\")\nasync def shared_cache():\n    # Module-scoped async fixture\n    cache = await AsyncCache.create()\n    await cache.set(\"initialized\", True)\n    yield cache\n    await cache.clear()\n    await cache.close()\n\n@pytest_asyncio.fixture(params=[1, 2, 3])\nasync def parametrized_fixture(request):\n    # Parametrized async fixture\n    value = await compute_value(request.param)\n    yield value\n\n@pytest_asyncio.fixture(loop_scope=\"session\", scope=\"module\")\nasync def session_loop_module_fixture():\n    # Runs in session-scoped loop, cached at module level\n    resource = await expensive_setup()\n    yield resource\n    await resource.cleanup()\n\n@pytest.mark.asyncio\nasync def test_with_async_fixture(database_connection):\n    result = await database_connection.execute(\"SELECT 1\")\n    assert result == 1\n\n@pytest.mark.asyncio\nasync def test_with_cache(shared_cache):\n    value = await shared_cache.get(\"initialized\")\n    assert value is True\n\n```\n\n## Configure Session-Scoped Event Loop Fixture Scope (TOML)\n\n```toml\n[tool.pytest.ini_options]\nasyncio_default_fixture_loop_scope = \"session\"\n```\n\n## Marking All Tests in a Module with pytestmark.asyncio\n\n```python\nimport asyncio\n\nimport pytest\n\n# Marks all test coroutines in this module\npytestmark = pytest.mark.asyncio\n\n\nasync def test_runs_in_asyncio_event_loop():\n    assert asyncio.get_running_loop()\n```\n\n## Test with Multiple Event Loop Policies\n\n```python\nimport asyncio\nimport warnings\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", DeprecationWarning)\n    from asyncio import DefaultEventLoopPolicy\n\nimport pytest\n\n\nclass CustomEventLoopPolicy(DefaultEventLoopPolicy):\n    pass\n\n\n@pytest.fixture(\n    params=(\n        DefaultEventLoopPolicy(),\n        CustomEventLoopPolicy(),\n    ),\n)\ndef event_loop_policy(request):\n    return request.param\n\n\n@pytest.mark.asyncio\n@pytest.mark.filterwarnings(\"ignore::DeprecationWarning\")\nasync def test_uses_custom_event_loop_policy():\n    assert isinstance(asyncio.get_event_loop_policy(), DefaultEventLoopPolicy)\n```\n\n## Configure Default Event Loop Scope (TOML)\n\n```toml\n[tool.pytest.ini_options]\nasyncio_default_test_loop_scope = \"session\"\n```\n\n## Sharing Event Loop Across Module Tests with loop_scope='module'\n\n```python\nimport asyncio\n\nimport pytest\n\npytestmark = pytest.mark.asyncio(loop_scope=\"module\")\n\nloop: asyncio.AbstractEventLoop\n\n\nasync def test_remember_loop():\n    global loop\n    loop = asyncio.get_running_loop()\n\n\nasync def test_this_runs_in_same_loop():\n    global loop\n    assert asyncio.get_running_loop() is loop\n\n\nclass TestClassA:\n    async def test_this_runs_in_same_loop(self):\n        global loop\n        assert asyncio.get_running_loop() is loop\n```",
    "library": "pytest-asyncio",
    "topic": "parametrize",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-24T12:14:41.953035"
}