{
  "library": "step_dependencies",
  "topic": "examples",
  "documentation": {
    "content": "## Singleton Provider Usage in Python\n\n```python\nimport random\n\nfrom that_depends import BaseContainer, Provide, inject, providers\n\n\ndef some_function() -> float:\n   \"\"\"Generate number between 0.0 and 1.0\"\"\"\n   return random.random()\n\n\n# define container with `Singleton` provider:\nclass MyContainer(BaseContainer):\n   singleton = providers.Singleton(some_function)\n\n\n# The provider will call `some_function` once and cache the return value\n\n# 1) Synchronous resolution\n# MyContainer.singleton.resolve_sync()  # e.g. 0.3\n# MyContainer.singleton.resolve_sync()  # 0.3 (cached)\n\n# 2) Asynchronous resolution\n# await MyContainer.singleton.resolve()  # 0.3 (same cached value)\n\n\n# 3) Injection example\n@inject\nasync def with_singleton(number: float = Provide[MyContainer.singleton]):\n   # number == 0.3\n   pass\n\n\n# Teardown Support\n# await MyContainer.singleton.tear_down() # Clears the cached instance\n# await MyContainer.singleton.tear_down_sync() # Synchronous teardown\n```\n\n## ThreadLocalSingleton Provider Usage (Python)\n\n```python\nimport random\nimport threading\nfrom that_depends.providers import ThreadLocalSingleton\n\ndef factory() -> int:\n   \"\"\"Return a random int between 1 and 100.\"\"\"\n   return random.randint(1, 100)\n\n\n# ThreadLocalSingleton caches an instance per thread\nsingleton = ThreadLocalSingleton(factory)\n\n# In a single thread:\n# instance1 = singleton.resolve_sync()  # e.g. 56\n# instance2 = singleton.resolve_sync()  # 56 (cached in the same thread)\n\n\n# In multiple threads:\ndef thread_task():\n   return singleton.resolve_sync()\n\n\n# thread1 = threading.Thread(target=thread_task)\n# thread2 = threading.Thread(target=thread_task)\n# thread1.start()\n# thread2.start()\n\n# thread1 and thread2 each get a different cached value\n```\n\n## Replace init_async_resources with init_resources in BaseContainer\n\n```python\nfrom that_depends import BaseContainer\n\nclass MyContainer(BaseContainer):\n    # Define your providers here\n    ...\n\n# Replace this:\n# await MyContainer.init_async_resources()\n\n# With this:\nawait MyContainer.init_resources()\n```\n\n## Define Dependency Container with BaseContainer and Providers\n\n```python\nfrom that_depends import BaseContainer, providers\nimport asyncio\n\nclass Config:\n    def __init__(self):\n        self.database_url = \"postgresql://localhost/mydb\"\n        self.debug = True\n\nclass DatabaseSession:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.connected = False\n\n    def connect(self):\n        self.connected = True\n        return self\n\nclass UserRepository:\n    def __init__(self, session: DatabaseSession, debug: bool):\n        self.session = session\n        self.debug = debug\n\n    def get_user(self, user_id: int):\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\nclass AppContainer(BaseContainer):\n    # Singleton - created once and reused\n    config = providers.Singleton(Config)\n\n    # Factory - new instance each time, with dependency injection\n    db_session = providers.Factory(\n        DatabaseSession,\n        connection_string=config.cast.database_url\n    )\n\n    # Factory with multiple dependencies\n    user_repo = providers.Factory(\n        UserRepository,\n        session=db_session.cast,\n        debug=config.cast.debug\n    )\n\n# Usage\nasync def main():\n    # Resolve dependencies\n    config = await AppContainer.config.resolve()\n    print(f\"Debug mode: {config.debug}\")\n\n    user_repo = await AppContainer.user_repo.resolve()\n    user = user_repo.get_user(1)\n    print(f\"User: {user}\")\n\nasyncio.run(main())\n\n```\n\n## Python List Provider Example\n\n```python\nimport random\nfrom that_depends import BaseContainer, providers\n\n\nclass DIContainer(BaseContainer):\n    random_number = providers.Factory(random.random)\n    numbers_sequence = providers.List(random_number, random_number)\n\n\nDIContainer.numbers_sequence.resolve_sync()\n# [0.3035656170071561, 0.8280498192037787]\n```\n\n## Reset all containers with reset_all_containers=True in container_context (Python)\n\n```python\nfrom that_depends import container_context, fetch_context_item\n\nmy_global_context = {\"some_key\": \"some_value\"}\n\nasync with container_context(global_context=my_global_context, reset_all_containers=True):\n   assert fetch_context_item(\"some_key\") == \"some_value\"\n\n# Note: This only reinitializes context for ContextResource instances within containers.\n```\n\n## Using Context as a Decorator for Resource Injection\n\n```python\n@MyContainer._context_provider.context  # wrap with a session-specific context\n@inject\nasync def insert_into_database(session=Provide[MyContainer._context_provider]):\n   ...\n```\n\n## Define Singleton App Settings with Pydantic and that-depends\n\n```python\nfrom that_depends import BaseContainer, providers\nfrom pydantic import BaseModel\n\nclass AppSettings(BaseModel):\n    database_url: str = \"sqlite:///:memory:\"\n\nclass MyAdvancedContainer(BaseContainer):\n    # Provide a single, shared settings instance\n    settings = providers.Singleton(AppSettings)\n```\n\n## Use Provide[...] for Type Resolution in Python\n\n```python\nfrom that_depends import inject, Provide\n\n@inject\ndef greet_user_direct(\n        greeting: str = Provide[MyContainer.greeting_provider] # (1)!\n    ) -> str: \n    return f\"Greeting: {greeting}\"\n```\n\n## Pydantic-Settings Integration Example (Python)\n\n```python\nfrom pydantic_settings import BaseSettings\nfrom pydantic import BaseModel\n\n\nclass DatabaseConfig(BaseModel):\n    address: str = \"127.0.0.1\"\n    port: int = 5432\n    db_name: str = \"postgres\"\n\n\nclass Settings(BaseSettings):\n    auth_key: str = \"my_auth_key\"\n    db: DatabaseConfig = DatabaseConfig()\n\n# Example of how you might use this with a singleton provider:\n# from that_depends import providers\n# class AppContainer(BaseContainer):\n#     settings = providers.Singleton(Settings)\n\n# config = AppContainer.settings.resolve_sync()\n```",
    "library": "step_dependencies",
    "topic": "usage",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-29T22:14:39.682120"
}