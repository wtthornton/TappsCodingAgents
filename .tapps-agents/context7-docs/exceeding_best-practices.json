{
  "library": "exceeding",
  "topic": "best-practices",
  "documentation": {
    "content": "## Define Benchmark Operations with Pre and Post Hooks (TypeScript)\n\n```typescript\nimport { Benchmark, printJSONReports } from 'overtake';\n\nconst suite = new Benchmark('data', () => ({ items: [1, 2, 3, 4, 5] }));\n\nconst target = suite.target('serialization', () => {\n  const { parse, stringify } = JSON;\n  let serialized: string = '';\n  return { parse, stringify, serialized };\n});\n\n// Measure stringify operation\ntarget\n  .measure('stringify', ({ stringify }, input) => {\n    stringify(input);\n  })\n  .pre(async (ctx, input) => {\n    // Runs before each measurement - not timed\n  })\n  .post(async (ctx, input) => {\n    // Runs after each measurement - not timed\n  });\n\n// Measure parse with pre-serialization\ntarget\n  .measure('parse', ({ parse, serialized }) => {\n    parse(serialized);\n  })\n  .pre(async (ctx, input) => {\n    // Serialize before measuring parse\n    ctx.serialized = ctx.stringify(input);\n  })\n  .post(async (ctx) => {\n    // Clean up to avoid GC during next measurement\n    ctx.serialized = '';\n  });\n\nconst reports = await suite.execute({\n  workers: 4,\n  reportTypes: ['ops', 'mean', 'median', 'p95'],\n});\n\nprintJSONReports(reports, 2);\n```\n\n## Create Benchmark Suite with Multiple Feeds (TypeScript)\n\n```typescript\n// Create with initial feed\nconst suite = benchmark('initial data', () => data).feed('more data', () => moreData); // Add more datasets\n\n// Define what to compare\nsuite.target('implementation A').measure('operation', (ctx, input) => {\n  /* ... */\n});\n\nsuite.target('implementation B').measure('operation', (ctx, input) => {\n  /* ... */\n});\n```\n\n## Example Benchmark Command with Multiple Metrics\n\n```bash\nnpx overtake bench.ts -r ops mean sd rme p50 p95 p99\n```\n\n## Overtake CLI Usage and Options\n\n```bash\n# Basic usage - run all benchmarks matching pattern\nnpx overtake \"**/*.bench.ts\"\n\n# Table output format\nnpx overtake benchmark.ts -f table\n\n# Detailed statistics\nnpx overtake bench.ts -r ops mean sd rme p50 p95 p99\n\n# JSON output for CI pipelines\nnpx overtake bench.ts -f json > results.json\n\n# Markdown output for documentation/PRs\nnpx overtake bench.ts -f markdown\n\n# ASCII histogram visualization\nnpx overtake bench.ts -f histogram\n\n# Progress bar for long benchmarks\nnpx overtake bench.ts --progress\n\n# Custom worker count and cycles\nnpx overtake bench.ts -w 8 --min-cycles 100 --max-cycles 500\n\n# Convergence thresholds\nnpx overtake bench.ts --abs-threshold 500 --rel-threshold 0.01\n\n# Disable GC detection\nnpx overtake bench.ts --no-gc-observer\n\n# Output examples:\n# simple format (default):\n#   for loop sum\n#     1M numbers: 1,607 ops/s +/- 0.15% (heap: 1024KB)\n#\n# histogram format:\n#   for loop - sum\n#     1M numbers | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 1,607 ops/s\n#   reduce - sum\n#     1M numbers | \u2588\u2588\u2588\u2588\u2588\u2588 238 ops/s\n```\n\n## Handle Dynamic Imports in Worker Context with TypeScript\n\n```typescript\nimport 'overtake';\n\n// WRONG: closes over imported binding - undefined in worker\n// import { serialize } from 'node:v8';\n// benchmark('data', getData).target('v8', () => ({ serialize }));\n\n// CORRECT: import inside worker-run function\nconst suite = benchmark('data', () => ({ key: 'value', num: 42 }));\n\nsuite\n  .target('v8 serialization', async () => {\n    // Dynamic import works in worker context\n    const { serialize, deserialize } = await import('node:v8');\n    return { serialize, deserialize };\n  })\n  .measure('serialize', ({ serialize }, input) => {\n    serialize(input);\n  });\n\n// Local file imports (CLI mode - relative to benchmark file)\nsuite\n  .target('local module', async () => {\n    const { join } = await import('node:path');\n    const modulePath = join(process.cwd(), './build/myModule.js');\n    const { myHelper } = await import(modulePath);\n    return { myHelper };\n  })\n  .measure('use helper', ({ myHelper }, input) => {\n    myHelper(input);\n  });\n\n// Node built-in modules\nsuite\n  .target('crypto', async () => {\n    const { createHash } = await import('node:crypto');\n    const { gzip } = await import('node:zlib');\n    const { promisify } = await import('node:util');\n    return { createHash, gzip: promisify(gzip) };\n  })\n  .measure('hash', ({ createHash }, input) => {\n    createHash('md5').update(JSON.stringify(input)).digest('hex');\n  });\n\n// Run: npx overtake benchmark.ts\n\n```\n\n## Overtake: Handling Capture-Free Functions in Workers\n\n```typescript\n// \u274c WRONG: closes over serialize; it is undefined in the worker\nimport { serialize } from 'node:v8';\nbenchmark('data', getData).target('v8', () => ({ serialize }));\n\n// \u2705 CORRECT: import inside the worker-run function\nbenchmark('data', getData)\n  .target('v8', async () => {\n    const { serialize } = await import('node:v8');\n    return { serialize };\n  })\n  .measure('serialize', ({ serialize }, input) => serialize(input));\n```\n\n## Overtake: Importing Local Files in CLI vs. Programmatic Mode\n\n```typescript\n// CLI usage \u2013 relative path is fine\nbenchmark('local', () => 1)\n  .target('helper', async () => {\n    const { helper } = await import('./helpers.js');\n    return { helper };\n  })\n  .measure('use helper', ({ helper }) => helper());\n\n// Programmatic usage \u2013 provide baseUrl\nconst suite = new Benchmark('local');\nsuite\n  .target('helper', async () => {\n    const { helper } = await import('./helpers.js');\n    return { helper };\n  })\n  .measure('use helper', ({ helper }) => helper());\nawait suite.execute({ baseUrl: import.meta.url });\n```\n\n## Import Local Modules for Benchmarking (TypeScript)\n\n```typescript\n// examples/imports.ts - Correct way to import local files\nconst suite = benchmark('local modules', () => testData);\n\nsuite\n  .target('local files', async () => {\n    const { join } = await import('node:path');\n    const modulePath = join(process.cwd(), './build/myModule.js');\n    const { myFunction } = await import(modulePath);\n    return { myFunction };\n  })\n  .measure('call function', ({ myFunction }, input) => {\n    myFunction(input);\n  });\n```\n\n## Prevent Garbage Collection During Measurement (TypeScript)\n\n```typescript\nconst suite = benchmark('data', () => [1, 2, 3, 4, 5]);\n\nsuite\n  .target('no GC', () => {\n    const gcBlock = new Set(); // Keeps references alive\n    return { gcBlock };\n  })\n  .measure('process', ({ gcBlock }, input) => {\n    const result = input.map((x) => x * x);\n    gcBlock.add(result); // Prevent GC during measurement\n  });\n```\n\n## Benchmark Target Setup with Async Operations (TypeScript)\n\n```typescript\nconst suite = benchmark('data', () => Buffer.from('test data'));\n\nsuite\n  .target('with setup', async () => {\n    // Setup runs once before measurements\n    const { createHash } = await import('node:crypto');\n    const cache = new Map();\n    return { createHash, cache }; // Available as ctx in measure\n  })\n  .measure('hash', ({ createHash, cache }, input) => {\n    // ctx contains setup return value\n    const hash = createHash('sha256').update(input).digest();\n    cache.set(input, hash);\n  });\n```\n",
    "library": "exceeding",
    "topic": "best-practices",
    "source": "api"
  },
  "source": "api",
  "saved_at": "2026-02-03T18:26:00.354290"
}