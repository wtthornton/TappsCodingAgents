{
  "library": "performance_scorer",
  "topic": "usage",
  "documentation": {
    "content": "## PCM Command-Line Utility Usage Examples\n\n```bash\n# Basic usage: monitor system every 1 second\nsudo ./pcm\n\n# Monitor every 2 seconds\nsudo ./pcm 2\n\n# Monitor for 10 iterations at 1 second intervals\nsudo ./pcm 1 -i=10\n\n# Hide core output, show only socket and system summary\nsudo ./pcm -nc\n\n# Hide socket output\nsudo ./pcm -ns\n\n# CSV output to file\nsudo ./pcm 1 -csv=output.csv -i=60\n\n# Monitor specific process by PID\nsudo ./pcm 1 -pid 12345\n\n# Run as non-root (limited metrics, requires perf_event support)\necho -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\nexport PCM_NO_MSR=1\nexport PCM_KEEP_NMI_WATCHDOG=1\n./pcm\n```\n\n## pcm-memory Command-Line Utility Usage Examples\n\n```bash\n# Monitor memory bandwidth per-channel\nsudo ./pcm-memory\n\n# Monitor memory bandwidth with 2-second intervals\nsudo ./pcm-memory 2\n\n# Show per-DIMM rank bandwidth (rank 0)\nsudo ./pcm-memory -rank=0\n\n# Monitor Persistent Memory (PMM) bandwidth\nsudo ./pcm-memory -pmm\n\n# CSV output\nsudo ./pcm-memory 1 -csv=memory.csv\n\n# Hide channel output, show only system summary\nsudo ./pcm-memory -nc\n\n# Monitor CXL memory bandwidth (newer processors)\nsudo ./pcm-memory\n\n# Suppress CXL output\nsudo ./pcm-memory --nocxl\n```\n\n## pcm-sensor-server Command-Line Utility Usage Examples\n\n```bash\n# Start HTTP server on default port 9738\nsudo ./pcm-sensor-server\n\n# Run on custom port\nsudo ./pcm-sensor-server -p 8080\n\n# Bind to specific IP address (localhost only)\nsudo ./pcm-sensor-server -l 127.0.0.1 -p 9738\n\n# Run in background (daemon mode, Linux/macOS)\nsudo ./pcm-sensor-server -d\n\n# Run with real-time priority (Linux only)\nsudo ./pcm-sensor-server -R\n\n# Debug mode with verbosity\nsudo ./pcm-sensor-server -D 2\n\n# As non-root with limited metrics\necho -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\nPCM_NO_MSR=1 PCM_KEEP_NMI_WATCHDOG=1 ./pcm-sensor-server\n```\n\n## Display pcm-sensor-server Help Information (Bash)\n\n```bash\n./pcm-sensor-server --help\n```\n\n## Monitor Accelerators with pcm-accel\n\n```bash\n# Monitor Intel accelerators (IAA, DSA, QAT)\nsudo ./pcm-accel\n\n# Monitor with 1-second intervals\nsudo ./pcm-accel 1\n\n# List available accelerators\nsudo ./pcm-accel -l\n\n# Monitor specific accelerator types\nsudo ./pcm-accel -iaa  # Intel IAA only\nsudo ./pcm-accel -dsa  # Intel DSA only\nsudo ./pcm-accel -qat  # Intel QAT only\n```\n\n## Run pcm-sensor-server on Windows\n\n```powershell\npcm-sensor-server.exe\n```\n\n## Load PCM C API Dynamically using dlopen\n\n```c\n#include <stdio.h>\n#include <dlfcn.h>\n#include <stdint.h.h>\n#include <unistd.h>\n\n// Function pointer structure for PCM C API\nstruct {\n    int (*pcm_c_build_core_event)(uint8_t id, const char* argv);\n    int (*pcm_c_init)();\n    void (*pcm_c_start)();\n    void (*pcm_c_stop)();\n    uint64_t (*pcm_c_get_cycles)(uint32_t core_id);\n    uint64_t (*pcm_c_get_instr)(uint32_t core_id);\n    uint64_t (*pcm_c_get_core_event)(uint32_t core_id, uint32_t event_id);\n} PCM;\n\nint main(int argc, char* argv[]) {\n    // Load shared library dynamically\n    void* handle = dlopen(\"libpcm.so\", RTLD_LAZY);\n    if (!handle) {\n        printf(\"Error: Could not load libpcm.so\\n\");\n        return -1;\n    }\n\n    // Load function pointers\n    PCM.pcm_c_build_core_event = dlsym(handle, \"pcm_c_build_core_event\");\n    PCM.pcm_c_init = dlsym(handle, \"pcm_c_init\");\n    PCM.pcm_c_start = dlsym(handle, \"pcm_c_start\");\n    PCM.pcm_c_stop = dlsym(handle, \"pcm_c_stop\");\n    PCM.pcm_c_get_cycles = dlsym(handle, \"pcm_c_get_cycles\");\n    PCM.pcm_c_get_instr = dlsym(handle, \"pcm_c_get_instr\");\n    PCM.pcm_c_get_core_event = dlsym(handle, \"pcm_c_get_core_event\");\n\n    // Optional: Configure custom events (up to 4 events)\n    if (argc > 1) {\n        PCM.pcm_c_build_core_event(0, argv[1]);  // Event 0\n    }\n    if (argc > 2) {\n        PCM.pcm_c_build_core_event(1, argv[2]);  // Event 1\n    }\n\n    // Initialize PCM\n    if (PCM.pcm_c_init() != 0) {\n        printf(\"PCM initialization failed\\n\");\n        return -1;\n    }\n\n    // Start measurement\n    PCM.pcm_c_start();\n\n    // Your workload here\n    volatile int result = 0;\n    for (int i = 0; i < 1000000; i++) {\n        result += i * 2;\n    }\n\n    // Stop measurement\n    PCM.pcm_c_stop();\n\n    // Get core ID (using RDTSCP instruction)\n    uint32_t core_id = 0;  // Simplified: use core 0\n\n    // Retrieve results\n    uint64_t cycles = PCM.pcm_c_get_cycles(core_id);\n    uint64_t instructions = PCM.pcm_c_get_instr(core_id);\n    double ipc = (double)instructions / cycles;\n\n    printf(\"Core %u:\\n\", core_id);\n    printf(\"  Cycles: %llu\\n\", (unsigned long long)cycles);\n    printf(\"  Instructions: %llu\\n\", (unsigned long long)instructions);\n    printf(\"  IPC: %.2f\\n\", ipc);\n    printf(\"  Custom Event 0: %llu\\n\", (unsigned long long)PCM.pcm_c_get_core_event(core_id, 0));\n    printf(\"  Custom Event 1: %llu\\n\", (unsigned long long)PCM.pcm_c_get_core_event(core_id, 1));\n\n    dlclose(handle);\n    return 0;\n}\n\n```\n\n## C API - Dynamic Library Loading\n\n```APIDOC\n## C API - Dynamic Library Loading\n\n### Description\nThis section details the usage of the PCM C API through dynamic library loading. It includes initialization, starting/stopping measurements, and retrieving performance counters like cycles, instructions, and custom events.\n\n### Method\nDynamic Library Loading (using `dlopen`, `dlsym`)\n\n### Endpoint\nN/A (This is a C library usage example)\n\n### Parameters\nNone directly applicable in this format.\n\n### Request Example\n```c\n#include <stdio.h>\n#include <dlfcn.h>\n#include <stdint.h>\n#include <unistd.h>\n\n// Function pointer structure for PCM C API\nstruct {\n    int (*pcm_c_build_core_event)(uint8_t id, const char* argv);\n    int (*pcm_c_init)();\n    void (*pcm_c_start)();\n    void (*pcm_c_stop)();\n    uint64_t (*pcm_c_get_cycles)(uint32_t core_id);\n    uint64_t (*pcm_c_get_instr)(uint32_t core_id);\n    uint64_t (*pcm_c_get_core_event)(uint32_t core_id, uint32_t event_id);\n} PCM;\n\nint main(int argc, char* argv[]) {\n    // Load shared library dynamically\n    void* handle = dlopen(\"libpcm.so\", RTLD_LAZY);\n    if (!handle) {\n        printf(\"Error: Could not load libpcm.so\\n\");\n        return -1;\n    }\n\n    // Load function pointers\n    PCM.pcm_c_build_core_event = dlsym(handle, \"pcm_c_build_core_event\");\n    PCM.pcm_c_init = dlsym(handle, \"pcm_c_init\");\n    PCM.pcm_c_start = dlsym(handle, \"pcm_c_start\");\n    PCM.pcm_c_stop = dlsym(handle, \"pcm_c_stop\");\n    PCM.pcm_c_get_cycles = dlsym(handle, \"pcm_c_get_cycles\");\n    PCM.pcm_c_get_instr = dlsym(handle, \"pcm_c_get_instr\");\n    PCM.pcm_c_get_core_event = dlsym(handle, \"pcm_c_get_core_event\");\n\n    // Optional: Configure custom events (up to 4 events)\n    if (argc > 1) {\n        PCM.pcm_c_build_core_event(0, argv[1]);  // Event 0\n    }\n    if (argc > 2) {\n        PCM.pcm_c_build_core_event(1, argv[2]);  // Event 1\n    }\n\n    // Initialize PCM\n    if (PCM.pcm_c_init() != 0) {\n        printf(\"PCM initialization failed\\n\");\n        return -1;\n    }\n\n    // Start measurement\n    PCM.pcm_c_start();\n\n    // Your workload here\n    volatile int result = 0;\n    for (int i = 0; i < 1000000; i++) {\n        result += i * 2;\n    }\n\n    // Stop measurement\n    PCM.pcm_c_stop();\n\n    // Get core ID (using RDTSCP instruction)\n    uint32_t core_id = 0;  // Simplified: use core 0\n\n    // Retrieve results\n    uint64_t cycles = PCM.pcm_c_get_cycles(core_id);\n    uint64_t instructions = PCM.pcm_c_get_instr(core_id);\n    double ipc = (double)instructions / cycles;\n\n    printf(\"Core %%u:\\n\", core_id);\n    printf(\"  Cycles: %%llu\\n\", (unsigned long long)cycles);\n    printf(\"  Instructions: %%llu\\n\", (unsigned long long)instructions);\n    printf(\"  IPC: %.2f\\n\", ipc);\n    printf(\"  Custom Event 0: %%llu\\n\", (unsigned long long)PCM.pcm_c_get_core_event(core_id, 0));\n    printf(\"  Custom Event 1: %%llu\\n\", (unsigned long long)PCM.pcm_c_get_core_event(core_id, 1));\n\n    dlclose(handle);\n    return 0;\n}\n```\n\n### Response\nN/A (This is a C library usage example)\n\n### Response Example\nN/A\n```\n\n## List Available Events (pcm-raw)\n\n```bash\npcm-raw -?\n```\n\n## Configure PMT Raw Telemetry Counter\n\n```bash\npmt/config=0x87b6fef1,config1=770,config2=0,config3=32,config4=63,name=\"Temperature_histogram_range_5_(50.5-57.5C)_counter_for_core_0\"\n```",
    "library": "performance_monitor",
    "topic": "usage",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-03T09:49:28.999839"
}