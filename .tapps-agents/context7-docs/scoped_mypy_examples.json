{
  "library": "scoped_mypy",
  "topic": "examples",
  "documentation": {
    "content": "## ISOTPSoftSocket Implementation Notes\n\n```APIDOC\nISOTPSoftSocket:\n  Internal Implementation: Requires a background thread.\n  Recommendation: Use Python's 'with' statement to ensure proper thread closure.\n```\n\n## Scapy Packet Object Core Commands\n\n```APIDOC\nraw(pkt): assemble the packet\nhexdump(pkt): have a hexadecimal dump\nls(pkt): have the list of fields values\npkt.summary(): for a one-line summary\npkt.show(): for a developed view of the packet\npkt.show2(): same as show but on the assembled packet (checksum is calculated, for instance)\npkt.sprintf(): fills a format string with fields values of the packet\npkt.decode_payload_as(): changes the way the payload is decoded\npkt.psdump(): draws a PostScript diagram with explained dissection\npkt.pdfdump(): draws a PDF with explained dissection\npkt.command(): return a Scapy command that can generate the packet\npkt.json(): return a JSON string representing the packet\n```\n\n## Scapy PipeTools: Core Class Types\n\n```APIDOC\nSources:\n  Description: Objects that provide data input to the PipeTools system.\nDrains:\n  Description: Intermediate blocks in a PipeTools sequence that process data.\nSinks:\n  Description: Objects that handle the output of data from the PipeTools system.\nPipeEngine:\n  Description: Orchestrates the execution and handling of Sources, Drains, and Sinks. It waits for data from a Source and sends it to linked Drains.\n```\n\n## Scapy PipeTool Core Concepts API Reference\n\n```APIDOC\nDrain Class:\n  Description: Receives data from lower canal via 'push' and higher canal via 'high_push'.\n  Methods:\n    push(msg): Receives data from lower canal. To send data back, call self._send(msg).\n    high_push(msg): Receives data from higher canal. To send data back, call self._high_send(msg).\n\nSink Class:\n  Description: Destinations for messages. Receives data like a Drain but does not send any messages after it.\n  Methods:\n    push(msg): Receives data on the low entry.\n    high_push(msg): Receives data on the high entry.\n\nPipeEngine Class:\n  Description: The core class of the Pipetool system. Must be initialized and passed the list of all Sources.\n  Initialization:\n    PipeEngine(source1, source2, ...): Initialize with sources.\n  Methods:\n    add(source): Add a source to the engine.\n    start(): Start the PipeEngine.\n    stop(): Force-stop the PipeEngine.\n    wait_and_stop(): Cleanly stop the PipeEngine (works if Sources are exhausted).\n    graph(): Print the pipe graph (see help(do_graph) for available keyword arguments).\n```\n\n## Scapy PipeTool Default Sink Classes API Reference\n\n```APIDOC\nDefault Sink Classes:\n  ConsoleSink: Prints messages on low and high entries to stdout.\n  RawConsoleSink: Prints messages on low and high entries, using os.write.\n  TermSink: Prints messages on low and high entries, on a separate terminal.\n  QueueSink: Collects messages on low and high entries into a Queue.\n```\n\n## Scapy PacketList Object Core Commands\n\n```APIDOC\nsummary(): displays a list of summaries of each packet\nnsummary(): same as previous, with the packet number\nconversations(): displays a graph of conversations\nshow(): displays the preferred representation (usually nsummary())\nfilter(): returns a packet list filtered with a lambda function\nhexdump(): returns a hexdump of all packets\nhexraw(): returns a hexdump of the Raw layer of all packets\npadding(): returns a hexdump of packets with padding\nnzpadding(): returns a hexdump of packets with non-zero padding\nplot(): plots a lambda function applied to the packet list\nmake_table(): displays a table according to a lambda function\n```\n\n## Implement Custom TCP Reassembly in Scapy\n\n```python\nclass TLS(Packet):\n    [...]\n\n    @classmethod\n    def tcp_reassemble(cls, data, metadata, session):\n        length = struct.unpack(\"!H\", data[3:5])[0] + 5\n        if len(data) == length:\n            return TLS(data)\n```\n\n## Scapy ASN.1: Defining Universal and Context Classes\n\n```Python\nclass ASN1_Class_UNIVERSAL(ASN1_Class):\n    name = \"UNIVERSAL\"\n# [...]\n    BOOLEAN = 1\n    INTEGER = 2\n    BIT_STRING = 3\n# [...]\n\nclass ASN1_Class_SNMP(ASN1_Class_UNIVERSAL):\n    name=\"SNMP\"\n    PDU_GET = 0xa0\n    PDU_NEXT = 0xa1\n    PDU_RESPONSE = 0xa2\n\nclass ASN1_Class_X509(ASN1_Class_UNIVERSAL):\n    name=\"X509\"\n    CONT0 = 0xa0\n    CONT1 = 0xa1\n# [...]\n```\n\n## Scapy Pipetool Component API Reference\n\n```APIDOC\nSources:\n  CLIFeeder:\n    Description: A source especially used in interactive software.\n    Methods:\n      send(data): Generates the event data on the lower canal.\n  CLIHighFeeder:\n    Description: Same as CLIFeeder, but writes on the higher canal.\n  PeriodicSource:\n    Description: Generates messages periodically on the low canal.\n  AutoSource:\n    Description: The default source, that must be extended to create custom sources.\n    Methods:\n      _gen_data(msg): Sends data into the PipeEngine on the low canal.\n      _gen_high_data(msg): Sends data into the PipeEngine on the high canal.\n    Properties:\n      is_exhausted: bool - Should be set to True when the source is empty to allow clean stop of PipeEngine.\n\nDrains:\n  Drain:\n    Description: The most basic Drain possible. Will pass on both low and high entry if linked properly.\n  TransformDrain:\n    Description: Apply a function to messages on low and high entry.\n  UpDrain:\n    Description: Repeat messages from low entry to high exit.\n  DownDrain:\n    Description: Repeat messages from high entry to low exit.\n```\n\n## Scapy Automaton: Defining States, Conditions, and Actions\n\n```python\nfrom random import random\n\nclass Example(Automaton):\n    @ATMT.state(initial=1)\n    def BEGIN(self):\n        pass\n\n    @ATMT.state(final=1)\n    def END(self):\n        pass\n\n    @ATMT.condition(BEGIN, prio=1)\n    def maybe_go_to_end(self):\n        if random() > 0.5:\n            raise self.END()\n\n    @ATMT.condition(BEGIN, prio=2)\n    def certainly_go_to_end(self):\n            raise self.END()\n\n    @ATMT.action(maybe_go_to_end)\n    def maybe_action(self):\n        print(\"We are lucky...\")\n\n    @ATMT.action(certainly_go_to_end)\n    def certainly_action(self):\n        print(\"We are not lucky...\")\n\n    @ATMT.action(maybe_go_to_end, prio=1)\n    @ATMT.action(certainly_go_to_end, prio=1)\n    def always_action(self):\n        print(\"This wasn't luck!...\")\n```",
    "library": "scoped_mypy",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-03T09:49:05.289338"
}