{
  "library": "__future__",
  "topic": "best-practices",
  "documentation": {
    "content": "## APIDOC: future.globals.resolve Option\n\n```APIDOC\nfuture.globals.resolve:\n  Description: Controls whether globals should be resolved.\n  Behavior: doFuture now respects this option instead of being hardcoded to always resolve globals (future.globals.resolve = TRUE), making it consistent with other future frontends.\n```\n\n## Ensuring Consistent Random Number Generation with `withDoRNG()`\n\n```R\nwithDoRNG({\n  # Your foreach %dopar% expression here\n  # e.g., foreach(i = 1:10) %dopar% { rnorm(1) }\n})\n```\n\n## APIDOC: foreach Scheduling Options (.options.future)\n\n```APIDOC\nforeach(..., .options.future = list(scheduling = <value>)):\n  Description: Controls whether scheduling (\"chunking\") should take place or not, and if so, how granular it should be.\n  Parameters:\n    scheduling:\n      Type: numeric | logical\n      Values:\n        1.0 (or TRUE): Elements (iterations) will be split into equally sized chunks such that each backend worker processes exactly one chunk. (Default if not set and .options.multicore not used)\n        Inf (or FALSE): Chunking is disabled; each worker processes exactly one element at a time.\n        0.0: A single worker processes all elements (other workers will not be used).\n        2.0 (or higher): Each worker will process 'value' chunks.\n  Fallback: If .options.future is not set, then .options.multicore = list(preschedule = <logical>) (defined by doParallel) is used, where preschedule maps to scheduling. If neither is set, scheduling = 1.0 is used by default.\n```\n\n## APIDOC: doFuture.foreach.export Option\n\n```APIDOC\ndoFuture.foreach.export:\n  Description: Controls how global variables are identified and exported for foreach() loops.\n  Values:\n    \"manual\": Strictly follows the .export argument of foreach(). Disables future + globals framework.\n    \"automatic-unless-.export\" (Defunct): Previously a default, now falls back to \"export-and-automatic\".\n    \"automatic\" (Defunct): Previously a default, now falls back to \"export-and-automatic\".\n    \"export-and-automatic\": Uses the future framework for global identification, potentially combining with .export.\n    \"export-and-automatic-with-warning\": Similar to \"export-and-automatic\", but produces a warning listing globals potentially missing from the .export argument. Useful for developers.\n```\n\n## APIDOC: future.globals.maxSize Option\n\n```APIDOC\nfuture.globals.maxSize:\n  Description: Maximum total size of globals allowed per future (\"chunk\").\n  Behavior: Scaled up by the number of elements processed by the future (\"chunk\"), making the protection approximately invariant to the amount of chunking done by foreach.\n```\n\n## Enabling Verbose Output for `foreach` Operations\n\n```R\nforeach(..., .verbose = TRUE) %dofuture% { # Your parallel task }\n```\n\n## R: Accessing Globals in foreach Loops with doFuture\n\n```R\nforeach(f = F, g = G) %dopar% { f() + g() }\n```\n\n## Using the %dofuture% Operator for Parallel Execution\n\n```R\ny <- foreach(x = 1:3) %dofuture% { slow_fcn(x) }\n```\n\n## Controlling Future Options with Infix Operators (%stdout%, %conditions%)\n\n```R\ny <- foreach(i = 1:3) %dopar% { my_fun(i) } %stdout% FALSE\n# Equivalent to:\ny <- foreach(i = 1:3, .options.future = list(stdout = FALSE)) %dopar% { my_fun(i) }\n```\n\n## Temporarily Registering doFuture Adapter with `with()`\n\n```R\nwith(registerDoFuture(), {\n  # Your foreach code here\n})\n\n# Or temporarily within a function:\nmy_function <- function() {\n  with(registerDoFuture(), local = TRUE, {\n    # Your foreach code here\n  })\n}\n```",
    "library": "__future__",
    "topic": "overview",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-06T14:21:25.610898"
}