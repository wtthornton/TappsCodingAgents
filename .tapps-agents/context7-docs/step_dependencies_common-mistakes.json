{
  "library": "step_dependencies",
  "topic": "common-mistakes",
  "documentation": {
    "content": "## Pydantic-Settings Integration Example (Python)\n\n```python\nfrom pydantic_settings import BaseSettings\nfrom pydantic import BaseModel\n\n\nclass DatabaseConfig(BaseModel):\n    address: str = \"127.0.0.1\"\n    port: int = 5432\n    db_name: str = \"postgres\"\n\n\nclass Settings(BaseSettings):\n    auth_key: str = \"my_auth_key\"\n    db: DatabaseConfig = DatabaseConfig()\n\n# Example of how you might use this with a singleton provider:\n# from that_depends import providers\n# class AppContainer(BaseContainer):\n#     settings = providers.Singleton(Settings)\n\n# config = AppContainer.settings.resolve_sync()\n```\n\n## Define Singleton App Settings with Pydantic and that-depends\n\n```python\nfrom that_depends import BaseContainer, providers\nfrom pydantic import BaseModel\n\nclass AppSettings(BaseModel):\n    database_url: str = \"sqlite:///:memory:\"\n\nclass MyAdvancedContainer(BaseContainer):\n    # Provide a single, shared settings instance\n    settings = providers.Singleton(AppSettings)\n```\n\n## Define Domain Models and Services in Python\n\n```python\nimport datetime\nfrom typing import AsyncIterator\n\nclass UserService:\n    def __init__(self, db_session: str):\n        self.db_session = db_session\n\n    def get_user(self, user_id: int):\n        return {\n            \"id\": user_id,\n            \"name\": f\"User {user_id}\",\n            \"db_session\": self.db_session\n        }\n\nasync def create_db_session() -> AsyncIterator[str]:\n    \"\"\"Simulated database session with lifecycle management.\"\"\"\n    session_id = f\"session_{datetime.datetime.now().timestamp()}\"\n    print(f\"Opening DB session: {session_id}\")\n    try:\n        yield session_id\n    finally:\n        print(f\"Closing DB session: {session_id}\")\n\n```\n\n## Use Provide[...] for Type Resolution in Python\n\n```python\nfrom that_depends import inject, Provide\n\n@inject\ndef greet_user_direct(\n        greeting: str = Provide[MyContainer.greeting_provider] # (1)!\n    ) -> str: \n    return f\"Greeting: {greeting}\"\n```\n\n## GET /users/{user_id}/alt\n\n```APIDOC\n## GET /users/{user_id}/alt\n\n### Description\nRetrieves user information by user ID using an alternative string-based provider reference for dependency injection.\n\n### Method\nGET\n\n### Endpoint\n/users/{user_id}/alt\n\n### Parameters\n#### Path Parameters\n- **user_id** (int) - Required - The unique identifier for the user.\n\n#### Query Parameters\nNone\n\n#### Request Body\nNone\n\n### Request Example\nNone\n\n### Response\n#### Success Response (200)\n- **id** (int) - The user's ID.\n- **name** (str) - The user's name.\n- **db_session** (str) - The identifier for the database session used.\n\n#### Response Example\n```json\n{\n  \"id\": 456,\n  \"name\": \"User 456\",\n  \"db_session\": \"session_1678886400.65432\"\n}\n```\n```\n\n## Tear Down Propagation Example (Python)\n\n```python\nclass MyContainer(BaseContainer):\n    B = providers.Singleton(lambda: random.random())\n    A = providers.Singleton(lambda x: x, B)\n\nb = await MyContainer.B()\na = await MyContainer.A()\n\nassert a == b\n\nawait MyContainer.B.tear_down()\na_new = await MyContainer.A()\nassert a_new != a\n```\n\n## Managing Multiple Scopes with That Depends\n\n```python\nfrom that_depends import BaseContainer, providers, inject, Provide\nfrom that_depends.providers import ContextScopes\nimport asyncio\n\n# Assume database_resource, container_context, example_with_context, example_with_inject are defined elsewhere\n\nclass MultiScopeContainer(BaseContainer):\n    app_db = providers.ContextResource(database_resource).with_config(\n        scope=ContextScopes.APP\n    )\n    request_db = providers.ContextResource(database_resource).with_config(\n        scope=ContextScopes.REQUEST\n    )\n\nasync def example_multiple_scopes():\n    print(\"\\n--- Example 3: Multiple Scopes ---\")\n    async with container_context(scope=ContextScopes.APP):\n        app_db = await MultiScopeContainer.app_db.resolve()\n        print(\"APP scope database initialized\")\n\n        async with container_context(scope=ContextScopes.REQUEST):\n            request_db = await MultiScopeContainer.request_db.resolve()\n            print(\"REQUEST scope database initialized\")\n            print(app_db.execute(\"APP: SELECT config\"))\n            print(request_db.execute(\"REQUEST: SELECT session_data\"))\n        print(\"REQUEST scope exited - request_db closed\")\n    print(\"APP scope exited - app_db closed\")\n\nasync def main():\n    # Placeholder for other examples\n    # await example_with_context()\n    # await example_with_inject()\n    await example_multiple_scopes()\n\n# asyncio.run(main())\n\n```\n\n## Define Container and Singleton Provider (Python)\n\n```python\nfrom that_depends import BaseContainer, providers\nimport random\n\nclass MyContainer(BaseContainer):\n    config = providers.Singleton(lambda: random.random())\n```\n\n## Define IndependentFactory with Factory Provider\n\n```python\nimport dataclasses\n\nfrom that_depends import BaseContainer, providers\n\n\n@dataclasses.dataclass(kw_only=True, slots=True)\nclass IndependentFactory:\n    dep1: str\n    dep2: int\n\n\nclass DIContainer(BaseContainer):\n    independent_factory = providers.Factory(IndependentFactory, dep1=\"text\", dep2=123)\n```\n\n## Contravariant Binding for Supertype Injection in Python\n\n```python\nclass A:\n    ...\n\nclass B(A):\n    ...\n\nclass Container(BaseContainer):\n    my_provider = providers.Factory(lambda: B()).bind(B, contravariant=True)\n\n@Container.inject\nasync def foo(v: A = Provide()) -> A: # (1)!\n    return v\n```",
    "library": "step_dependencies",
    "topic": "overview",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-29T22:14:36.026098"
}