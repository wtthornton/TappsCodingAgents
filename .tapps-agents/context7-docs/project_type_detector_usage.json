{
  "library": "project_type_detector",
  "topic": "usage",
  "documentation": {
    "content": "## Utilize Type-Safe MIME Type Constants\n\n```rust\nuse mimetype_detector::{detect, constants::*};\n\n// Image constants\nlet png = detect(b\"\\x89PNG\\r\\n\\x1a\\n\");\nassert_eq!(png.mime(), IMAGE_PNG);\n\nlet jpeg = detect(b\"\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF\");\nassert_eq!(jpeg.mime(), IMAGE_JPEG);\n\n// Document constants\nlet pdf = detect(b\"%PDF-1.4\");\nassert_eq!(pdf.mime(), APPLICATION_PDF);\n\n// Archive constants\nlet zip = detect(b\"PK\\x03\\x04\");\nassert_eq!(zip.mime(), APPLICATION_ZIP);\n\nlet rar = detect(b\"Rar!\\x1a\\x07\\x00\");\nassert_eq!(rar.mime(), APPLICATION_X_RAR_COMPRESSED);\n\n// Audio/Video constants\nlet mp3 = detect(b\"\\xff\\xfb\\x90\\x00\");\nassert_eq!(mp3.mime(), AUDIO_MPEG);\n\nlet mp4 = detect(b\"\\x00\\x00\\x00 ftypmp42\");\nassert_eq!(mp4.mime(), VIDEO_MP4);\n\n// Office format constants\nlet mut docx = vec![0u8; 100];\ndocx[0..4].copy_from_slice(b\"PK\\x03\\x04\");\ndocx[30..35].copy_from_slice(b\"word/\");\nlet doc = detect(&docx);\nassert_eq!(doc.mime(), APPLICATION_VND_OPENXML_WORDPROCESSINGML_DOCUMENT);\n\n// Text format constants\nlet html = detect(b\"<!DOCTYPE html>\");\nassert!(html.is(TEXT_HTML) || html.is(TEXT_HTML_BASE));\n\nlet json = detect(b\"{\\\"key\\\": \\\"value\\\"}\");\nassert_eq!(json.mime(), APPLICATION_JSON);\n\n// Executable constants\nlet wasm = detect(b\"\\x00asm\\x01\\x00\\x00\\x00\");\nassert_eq!(wasm.mime(), APPLICATION_WASM);\n\nlet elf = detect(b\"\\x7fELF\\x02\\x01\\x01\\x00\");\nassert_eq!(elf.mime(), APPLICATION_X_ELF);\n\n// Use constants in pattern matching\nmatch png.mime() {\n    IMAGE_PNG => println!(\"PNG image\"),\n    IMAGE_JPEG => println!(\"JPEG image\"),\n    IMAGE_GIF => println!(\"GIF image\"),\n    _ => println!(\"Other format\"),\n}\n\n// Filter by category\nlet media_types = vec![IMAGE_PNG, VIDEO_MP4, AUDIO_MP3];\nfor mime_type in media_types {\n    println!(\"Media type: {}\", mime_type);\n}\n\n```\n\n## MimeKind::union - Combine MIME Categories (Rust)\n\n```rust\nuse mimetype_detector::MimeKind;\n\n// Combine two categories\nlet media = MimeKind::IMAGE.union(MimeKind::VIDEO);\nassert!(media.is_image());\nassert!(media.is_video());\nassert!(!media.is_audio());\n\n// Combine multiple categories\nlet documents = MimeKind::DOCUMENT\n    .union(MimeKind::TEXT)\n    .union(MimeKind::SPREADSHEET);\nassert!(documents.is_document());\nassert!(documents.is_text());\nassert!(documents.is_spreadsheet());\n\n// Display shows all combined categories\nprintln!(\"{}\", media);  // Prints: \"IMAGE | VIDEO\"\nprintln!(\"{}\", documents);  // Prints: \"DOCUMENT | TEXT | SPREADSHEET\"\n\n// Use in filtering logic\nlet kind = MimeKind::ARCHIVE.union(MimeKind::EXECUTABLE);\nif kind.contains(MimeKind::ARCHIVE) && kind.contains(MimeKind::EXECUTABLE) {\n    println!(\"Self-extracting archive\");\n}\n```\n\n## Test File Categories with MimeKind Constants\n\n```rust\nuse mimetype_detector::{detect, MimeKind};\n\n// Image detection\nlet png = detect(b\"\\x89PNG\\r\\n\\x1a\\n\");\nassert!(png.kind().is_image());\nassert!(!png.kind().is_video());\n\n// Video detection\nlet mp4 = detect(b\"\\x00\\x00\\x00 2ftypmp42\");\nassert!(mp4.kind().is_video());\n\n// Audio detection\nlet mp3 = detect(b\"\\xff\\xfb\\x90\\x00\");\nassert!(mp3.kind().is_audio());\n\n// Document detection\nlet pdf = detect(b\"%PDF-1.4\");\nassert!(pdf.kind().is_document());\n\n// Archive detection\nlet zip = detect(b\"PK\\x03\\x04\");\nassert!(zip.kind().is_archive());\n\n// Text detection\nlet html = detect(b\"<!DOCTYPE html>\");\nassert!(html.kind().is_text());\n\n// Font detection\nlet ttf = detect(b\"\\x00\\x01\\x00\\x00\");\nassert!(ttf.kind().is_font());\n\n// Executable detection\nlet wasm = detect(b\"\\x00asm\\x01\\x00\\x00\\x00\");\nassert!(wasm.kind().is_executable());\n\n// Database detection\nlet sqlite = detect(b\"SQLite format 3\\x00\");\nassert!(sqlite.kind().is_database());\n\n// Application detection (APK, JAR, etc.)\nlet mut jar_data = vec![0u8; 100];\njar_data[0..4].copy_from_slice(b\"PK\\x03\\x04\");\njar_data[30..49].copy_from_slice(b\"META-INF/MANIFEST.MF\");\nlet jar = detect(&jar_data);\nassert!(jar.kind().is_application());\n\n// Spreadsheet and Presentation detection\nassert!(MimeKind::SPREADSHEET.is_spreadsheet());\nassert!(MimeKind::PRESENTATION.is_presentation());\n\n// Model/3D detection\nassert!(MimeKind::MODEL.is_model());\n```\n\n## Utility Functions\n\n```APIDOC\n## Utility Functions\n\n### Description\nThese are utility functions that can be used for specific MIME type checks.\n\n### Functions\n\n- **`match_mime(data: &[u8], mime: &str) -> bool`**\n  Checks if the given data matches the specified MIME type.\n\n- **`equals_any(mime: &str, types: &[&str]) -> bool`**\n  Checks if a given MIME type is present in a slice of other MIME types.\n\n- **`is_supported(mime: &str) -> bool`**\n  Checks if the given MIME type is supported by the detector.\n\n### Request Example\n```rust\nuse mimetype_detector::{match_mime, is_supported};\n\nlet png_data = b\"\\x89PNG\\r\\n\\x1a\\n\";\nlet is_png = match_mime(png_data, \"image/png\");\nprintln!(\"Is PNG: {}\", is_png);\n\nlet supported = is_supported(\"application/json\");\nprintln!(\"Is JSON supported: {}\", supported);\n```\n\n### Response Example\n```json\n{\n  \"match_mime_result\": true,\n  \"is_supported_result\": true\n}\n```\n```\n\n## Check MIME Type with MimeType::is\n\n```rust\nuse mimetype_detector::{detect, constants::*};\n\nlet png = detect(b\"\\x89PNG\\r\\n\\x1a\\n\");\nassert!(png.is(IMAGE_PNG));\nassert!(png.is(\"image/png\"));\nassert!(!png.is(IMAGE_JPEG));\n\n// Ignores charset parameters\nlet html = detect(b\"<!DOCTYPE html>\");\nassert!(html.is(\"text/html\"));  // Works without charset\nassert!(html.is(\"text/html; charset=utf-8\"));  // Works with charset\n\n// Pattern matching with is()\nlet data = detect(b\"%PDF-1.5\");\nif data.is(APPLICATION_PDF) {\n    println!(\"Processing PDF document\");\n} else if data.is(IMAGE_PNG) {\n    println!(\"Processing PNG image\");\n}\n```\n\n## MimeKind::contains - Check Multiple Categories (Rust)\n\n```rust\nuse mimetype_detector::{detect, MimeKind};\n\n// DOCX contains both DOCUMENT and ARCHIVE\nlet mut docx_data = vec![0u8; 100];\ndocx_data[0..4].copy_from_slice(b\"PK\\x03\\x04\");\ndocx_data[30..35].copy_from_slice(b\"word/\");\nlet docx = detect(&docx_data);\n\nassert!(docx.kind().contains(MimeKind::DOCUMENT));\nassert!(docx.kind().contains(MimeKind::ARCHIVE));\nassert!(!docx.kind().contains(MimeKind::IMAGE));\n\n// Check multiple categories\nlet combined = MimeKind::IMAGE.union(MimeKind::VIDEO);\nassert!(combined.contains(MimeKind::IMAGE));\nassert!(combined.contains(MimeKind::VIDEO));\nassert!(!combined.contains(MimeKind::AUDIO));\n\n// Single category contains only itself\nlet image_only = MimeKind::IMAGE;\nassert!(image_only.contains(MimeKind::IMAGE));\nassert!(!image_only.contains(MimeKind::VIDEO));\n```\n\n## Core Detection Functions\n\n```APIDOC\n## Core Detection Functions\n\n### Description\nThese functions are used to detect the MIME type of data provided as a byte slice, from a file path, or from a reader.\n\n### Functions\n\n- **`detect(data: &[u8]) -> &'static MimeType`**\n  Detects the MIME type from a slice of bytes.\n\n- **`detect_file<P: AsRef<Path>>(path: P) -> io::Result<&'static MimeType>`**\n  Detects the MIME type from a file at the given path.\n\n- **`detect_reader<R: Read>(reader: R) -> io::Result<&'static MimeType>`**\n  Detects the MIME type from a reader.\n\n### Request Example\n```rust\nuse mimetype_detector::detect;\n\nlet data = b\"\\x89PNG\\r\\n\\x1a\\n\"; // Example PNG header\nlet mime_type = detect(data);\nprintln!(\"Detected MIME type: {}\", mime_type.mime());\n```\n\n### Response Example\n```json\n{\n  \"mime_type\": \"image/png\",\n  \"extension\": \".png\"\n}\n```\n```\n\n## equals_any - Compare MIME Type Against List (Rust)\n\n```rust\nuse mimetype_detector::{equals_any, detect};\n\n// Check if type is in list\nlet mime = \"image/png\";\nassert!(equals_any(mime, &[\"image/png\", \"image/jpeg\", \"image/gif\"]));\nassert!(!equals_any(mime, &[\"video/mp4\", \"audio/mp3\"]));\n\n// Ignores charset parameters\nlet html = \"text/html; charset=utf-8\";\nassert!(equals_any(html, &[\"text/html\"]));\n\n// Use with detected MIME types\nlet data = detect(b\"\\x89PNG\\r\\n\\x1a\\n\");\nlet supported_images = &[\"image/png\", \"image/jpeg\", \"image/webp\"];\nif equals_any(data.mime(), supported_images) {\n    println!(\"Supported image format\");\n}\n\n// Pattern matching alternative\nlet pdf_mime = detect(b\"%PDF-1.4\").mime();\nlet office_types = &[\"application/pdf\", \"application/msword\"];\nassert!(equals_any(pdf_mime, office_types));\n```\n\n## Check Supported MIME Types with is_supported\n\n```rust\nuse mimetype_detector::{is_supported, constants::*};\n\n// Check built-in types\nassert!(is_supported(IMAGE_PNG));\nassert!(is_supported(APPLICATION_PDF));\nassert!(is_supported(VIDEO_MP4));\nassert!(is_supported(AUDIO_MP3));\n\n// Check unsupported types\nassert!(!is_supported(\"application/x-custom-format\"));\nassert!(!is_supported(\"video/x-unknown\"));\n\n// Validate before processing\nlet mime_type = \"image/jpeg\";\nif is_supported(mime_type) {\n    println!(\"Format {} is supported\", mime_type);\n} else {\n    println!(\"Format {} is not supported\", mime_type);\n}\n\n// Works with charset parameters\nassert!(is_supported(\"text/html; charset=utf-8\"));\nassert!(is_supported(\"text/html\"));  // Both work\n\n```\n\n## MimeKind Methods\n\n```APIDOC\n## MimeKind Methods\n\n### Description\nThe `MimeKind` enum represents categories of MIME types. You can use its methods to check if a detected MIME type falls into specific categories.\n\n### Methods (called on `mime.kind()`)\n\n- **`is_image() -> bool`**, **`is_video() -> bool`**, **`is_audio() -> bool`**, **`is_archive() -> bool`**, **`is_document() -> bool`**, etc.\n  Check if the MIME type belongs to the respective category.\n\n- **`contains(kind: MimeKind) -> bool`**\n  Checks if the MIME type's kind bitmask contains the specified `MimeKind`.\n\n### Request Example\n```rust\nuse mimetype_detector::detect;\n\nlet png_data = b\"\\x89PNG\\r\\n\\x1a\\n\";\nlet mime = detect(png_data);\n\nif mime.kind().is_image() {\n    println!(\"The detected type is an image.\");\n}\n\nlet jar_data = b\"PK\\x03\\x04...\"; // Example ZIP/JAR header\nlet jar_mime = detect(jar_data);\n\nif jar_mime.kind().is_archive() && jar_mime.kind().contains(mimetype_detector::MimeKind::APPLICATION) {\n    println!(\"The detected type is an archive application.\");\n}\n```\n\n### Response Example\n```json\n{\n  \"is_image\": true,\n  \"is_archive\": false,\n  \"contains_application\": false\n}\n```\n```",
    "library": "project_type_detector",
    "topic": "common-mistakes",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:28:50.732487"
}