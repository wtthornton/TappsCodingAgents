{
  "library": "auto_progression",
  "topic": "best-practices",
  "documentation": {
    "content": "## Multiple Bars Updating Concurrently\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\t\"fortio.org/progressbar\"\n)\n\nfunc UpdateBar(b *progressbar.State, delay time.Duration) {\n\t// Update at random speed so bars move differently for a demo:\n\tfor i := 0; i <= 100; i++ {\n\t\tb.ProgressBar(float64(i))\n\t\ttime.Sleep(delay)\n\t}\n}\n\nfunc main() {\n\tcfg := progressbar.DefaultConfig()\n\tcfg.ExtraLines = 1\n\tcfg.ScreenWriter = os.Stdout\n\n\tmbar := cfg.NewMultiBarPrefixes(\n\t\t\"b1\",\n\t\t\"longest prefix\",\n\t\t\"short\",\n\t\t\"b4\",\n\t)\n\n\twg := sync.WaitGroup{}\n\tfor i, bar := range mbar {\n\t\twg.Add(1)\n\t\t// Update at random speed so bars move differently for a demo:\n\t\tdelay := time.Duration(5+rand.Intn(40)) * time.Millisecond\n\t\tbar.WriteAbove(fmt.Sprintf(\"\\t\\t\\tBar %d delay is %v\", i+1, delay))\n\t\tgo func(b *progressbar.State) {\n\t\t\tUpdateBar(b, delay)\n\t\t\twg.Done()\n\t\t}(bar)\n\t}\n\twg.Wait()\n\tprogressbar.MultiBarEnd(mbar)\n}\n```\n\n## Concurrent Safe Screen Writer\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"flag\"\n\t\"fortio.org/progressbar\"\n)\n\nvar ( \n\tdelayFlag = flag.Duration(\"delay\", 20*time.Millisecond, \"delay between updates\")\n\teveryFlag = flag.Int(\"every\", 1, \"print every Nth line\")\n)\n\nfunc PrintStuff(w *progressbar.Writer, every int) {\n\tfor i := 0; ; i++ {\n\t\tif i%every == 0 {\n\t\t\tfmt.Fprintln(w, \"Concurrent print line\", i)\n\t\t}\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n}\n\nfunc main() {\n\tflag.Parse()\n\tpb := progressbar.NewBar()\n\tw := pb.Writer()\n\tfmt.Fprintln(w, \"Progress bar example\")\n\t// demonstrate concurrency safety:\n\tgo PrintStuff(w, *everyFlag)\n\t// exact number of 'pixels', just to demo every smooth step:\n\tn := pb.Width * 8\n\tfor i := 0; i <= n; i++ {\n\t\tpb.ProgressBar(100. * float64(i) / float64(n))\n\t\ttime.Sleep(*delayFlag)\n\t}\n}\n```\n\n## Automatic Reader/Writer Progress Bar\n\n```go\npackage main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"fortio.org/progressbar\"\n)\n\nfunc main() {\n\turl := os.Args[1]\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Create a progress bar and wrap the response body\n\treader := progressbar.NewAutoReader(progressbar.NewBar(), resp.Body, resp.ContentLength)\n\n\t// Copy data, showing progress\n\t_, err = io.Copy(os.Stdout, reader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treader.Close() // Ensure finalization\n}\n```\n\n## Manually Update Progress Bar\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"fortio.org/progressbar\"\n)\n\nfunc main() {\n\tpb := progressbar.NewBar()\n\tfmt.Print(\"Progress bar example\\n\\n\") // 1 empty line before the progress bar, for the demo\n\tn := 1000\n\tfor i := 0; i <= n; i++ {\n\t\tpb.ProgressBar(100. * float64(i) / float64(n))\n\t\tif i%63 == 0 {\n\t\t\tprogressbar.MoveCursorUp(1)\n\t\t\tfmt.Printf(\"Just an extra demo print for %d\\n\", i)\n\t\t}\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n}\n```",
    "library": "progress_monitor",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T16:09:36.034267"
}