{
  "library": "cursor_verification",
  "topic": null,
  "documentation": {
    "content": "## Verus Importing Ambient Lemmas with `broadcast use`\n\n```Verus\nbroadcast use seq_contains_orig_elems_after_push;\n```\n\n## Verus Importing Ambient Lemmas with `broadcast use`\n\n```Verus\nbroadcast use vstd::seq_lib::group_seq_properties;\n```\n\n## Verus: Optimized lemma with reduced proof annotation\n\n```rust\n__\nproof fn my_long_function_helper(x: u64, y: int)\n    requires\n        f(x, y)\n    ensures\n        s1(x),\n        s2(x, y)\n{\n    P1; // It turns out that P2 and P3 aren't necessary when\n    P4; //    the solver is focused on just f, s1, s2, x, and y.\n}\n\n\n```\n\n## Verus: Dividing a large function's proof into sequential lemmas\n\n```rust\n__\nproof fn my_long_function(x: u64)\n    requires r(x)\n    ensures  e(x)\n{\n    P1;\n    P2;\n    P3;\n}\n\n\n```\n\n## Verus: Using Tracked and Ghost Types in Exec Functions\n\n```verus\n__\nexec fn example() {\n    let tracked (Tracked(x), Ghost(y)) = some_call();\n}\n\nexec fn example(Tracked(x): Tracked<X>, Ghost(y): Ghost<Y>) {\n}\n```\n\n## Verus: Ghost and Tracked Variable Usage\n\n```Verus\n/// Exec code can use \"let ghost\" and \"let tracked\" to create local ghost and tracked variables.\n/// Exec code can extract individual ghost and tracked values from Ghost and Tracked wrappers\n/// with \"let ...Ghost(x)...\" and \"let ...Tracked(x)...\".\nfn test_ghost_tuple_match(t: (Tracked<S>, Tracked<S>, Ghost<int>, Ghost<int>)) -> Tracked<S> {\n    let ghost g: (int, int) = (10, 20);\n    assert(g.0 + g.1 == 30);\n    let ghost (g1, g2) = g;\n    assert(g1 + g2 == 30);\n    // b1, b2: Tracked<S> and g3, g4: Ghost<int>\n    let (Tracked(b1), Tracked(b2), Ghost(g3), Ghost(g4)) = t;\n    Tracked(b2)\n}\n```\n\n## Verus: Analyzing broadcasted lemma usage with `-V axiom-usage-info`\n\n```text\nnote: checking this function used these broadcasted lemmas and broadcast groups:\n        - (group) broadcast_proof::multiple_broadcast_proof::Multiple::group_properties,\n        - broadcast_proof::multiple_broadcast_proof::Multiple::lemma_add_aligned\n   --> ../examples/broadcast_proof.rs:161:11\n    |\n161 |       proof fn increase_twice(\n    |  ___________^\n162 | |         p1: Multiple, v: Multiple, p2: Multiple)\n    | |________________________________________________^\n\n```\n\n## Verus: Impl using Default Trait Method\n\n```Verus\nstruct S1;\nstruct S2;\n\n/// An impl can choose to use the default impl of my_function_with_a_default,\n/// in which case the default_ensures applies to my_function_with_a_default\nimpl T for S1 {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int) {\n        i + j\n    }\n}\n```\n\n## Verus: Sequence Sortedness (Bad Trigger Example)\n\n```Verus\n__\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n    assert(s[2] <= s[4]);\n}\n\n```\n\n## Verus TreeMap Specifications\n\n```verus\nimpl<V> TreeMap<V> {\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n}\n```\n\n## Verus Trait and Impl Specifications\n\n```Verus\n/// Trait functions may have specifications\ntrait T {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int)\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    ;\n\n    /// A trait function may have a default (provided) implementation,\n    /// and this default may have additional ensures specified with default_ensures\n    fn my_function_with_a_default(&self, i: u32, j: u32) -> (r: u32)\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n        default_ensures\n            i == r || j == r,\n        {\n            if i >= j { i } else { j }\n        }\n}\n\nstruct S1;\nstruct S2;\n\n/// An impl can choose to use the default impl of my_function_with_a_default,\n/// in which case the default_ensures applies to my_function_with_a_default\nimpl T for S1 {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int) {\n        i + j\n    }\n}\n\n/// An impl can choose not to use the default impl of my_function_with_a_default,\n/// and instead provide its own impl, in which case the default_ensures is ignored\nimpl T for S2 {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int) {\n        i + j\n    }\n\n    fn my_function_with_a_default(&self, i: u32, j: u32) -> (r: u32)\n        ensures\n            r == i + j,\n    {\n        i + j\n    }\n}\n```",
    "library": "cursor_verification",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-30T18:28:32.132368"
}