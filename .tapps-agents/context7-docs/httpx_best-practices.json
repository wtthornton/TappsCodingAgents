{
  "library": "httpx",
  "topic": "best-practices",
  "documentation": {
    "content": "## Basic httpx Library Integration in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"github.com/projectdiscovery/goflags\"\n    \"github.com/projectdiscovery/gologger\"\n    \"github.com/projectdiscovery/gologger/levels\"\n    \"github.com/projectdiscovery/httpx/runner\"\n)\n\nfunc main() {\n    // Increase verbosity (optional)\n    gologger.DefaultLogger.SetMaxLevel(levels.LevelVerbose)\n\n    // Configure options\n    options := runner.Options{\n        Methods:         \"GET\",\n        InputTargetHost: goflags.StringSlice{\"scanme.sh\", \"projectdiscovery.io\", \"localhost\"},\n        StatusCode:      true,\n        TechDetect:      true,\n        OnResult: func(r runner.Result) {\n            // Handle errors\n            if r.Err != nil {\n                fmt.Printf(\"[Err] %s: %s\\n\", r.Input, r.Err)\n                return\n            }\n            // Process successful result\n            fmt.Printf(\"%s %s %d [%v]\\n\", r.Input, r.Host, r.StatusCode, r.Technologies)\n        },\n    }\n\n    // Validate options\n    if err := options.ValidateOptions(); err != nil {\n        log.Fatal(err)\n    }\n\n    // Create runner instance\n    httpxRunner, err := runner.New(&options)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer httpxRunner.Close()\n\n    // Execute enumeration\n    httpxRunner.RunEnumeration()\n}\n```\n\n## Advanced httpx Library Usage with Rate Control in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n    \"github.com/projectdiscovery/goflags\"\n    \"github.com/projectdiscovery/httpx/runner\"\n)\n\nfunc main() {\n    options := runner.Options{\n        Methods:                \"GET,POST\",\n        InputFile:              \"targets.txt\",\n        RateLimit:              50,        // 50 requests per second\n        RateLimitMinute:        2000,      // 2000 requests per minute\n        Threads:                25,        // 25 concurrent threads\n        Timeout:                10,        // 10 second timeout\n        Retries:                2,         // Retry failed requests twice\n        StatusCode:             true,\n        TechDetect:             true,\n        ExtractTitle:           true,\n        OutputServerHeader:     true,\n        OutputContentLength:    true,\n        OutputResponseTime:     true,\n        JSONOutput:             true,\n        Output:                 \"results.json\",\n        FollowRedirects:        true,\n        MaxRedirects:           5,\n        OnResult: func(r runner.Result) {\n            if r.Err != nil {\n                log.Printf(\"[Error] %s: %v\", r.Input, r.Err)\n                return\n            }\n\n            fmt.Printf(\"[%d] %s - %s (%s) [%dms]\\n\",\n                r.StatusCode,\n                r.URL,\n                r.Title,\n                r.WebServer,\n                r.ResponseTime,\n            )\n\n            // Process technology stack\n            if len(r.Technologies) > 0 {\n                fmt.Printf(\"  Technologies: %v\\n\", r.Technologies)\n            }\n        },\n    }\n\n    if err := options.ValidateOptions(); err != nil {\n        log.Fatal(err)\n    }\n\n    httpxRunner, err := runner.New(&options)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer httpxRunner.Close()\n\n    httpxRunner.RunEnumeration()\n}\n```\n\n## Technology Detection and Fingerprinting with httpx\n\n```bash\n# Detect web technologies using Wappalyzer fingerprints\nhttpx -tech-detect -l urls.txt\n# Output: https://example.com [nginx,jquery-3.6.0,bootstrap-5.0.0,wordpress]\n\n# Include web server and title for comprehensive fingerprinting\nhttpx -tech-detect -web-server -title -json -o tech-scan.json -l targets.txt\n# Output JSON includes: \"tech\": [\"nginx\",\"php\",\"mysql\"], \"webserver\": \"nginx/1.18.0\"\n\n# Use custom fingerprint database\nhttpx -tech-detect -custom-fingerprint-file custom-fingerprints.json -l urls.txt\n\n# Get detailed technology information with response storage\nhttpx -td -store-response -store-response-dir tech-output -l targets.txt\n```\n\n## Manage Feature Flags and Staged Rollouts\n\n```javascript\nfunction c(e,t){const r={staged:!1,priority:a.p[t]||0};d(e),s[e].get(t)||s[e].set(t,r)}function u(e,t){d(e),s[e].get(t)&&s[e].delete(t),s[e].size&&f(e)}function d(e){if(!e)throw new Error(\"agentIdentifier required\");s[e]||(s[e]=new Map)}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"feature\",r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(d(e),!e||!s[e].get(t)||r)return h(e,t);s[e].get(t).staged=!0,f(e)}function f(e){const t=Array.from(s[e]);t.every((e=>{let[t,r]=e;return r.staged}))&&(t.sort(((e,t)=>e[1].priority-t[1].priority)),t.forEach((t=>{let[r]=t;s[e].delete(r),h(e,r)})))}function h(e,t){const r=e?n.ee.get(e):n.ee,a=o.X.handlers;if(r.backlog&&a){var s=r.backlog[t],c=a[t];if(c){for(var u=0;s&&u<s.length;++u)p(s[u],c);(0,i.D)(c,(function(e,t){(0,i.D)(t,(function(t,r){r[0].on(e,r[1])}))}))}r.isolatedBacklog||delete a[t],r.backlog[t]=null,r.emit(\"drain-\"+t,[])}}function p(e,t){var r=e[1];(0,i.D)(t[r],(function(t,r){var n=e[0];if(r[0]===n){var i=r[1],o=e[3],a=e[2];i.apply(o,a)}}))}}\n```\n\n## httpx: Customize HTTP Methods and Request Body\n\n```bash\n# Custom HTTP methods\nhttpx -x GET,POST,PUT -l urls.txt\n\n# Test all HTTP methods\nhttpx -x all -l endpoints.txt\n\n# Custom request body for POST requests\nhttpx -x POST -body '{\"key\":\"value\"}' -l apis.txt\n\n# Load raw HTTP request from file\nhttpx -request raw-request.txt\n\n# Example raw-request.txt:\n# POST /api/endpoint HTTP/1.1\n# Host: example.com\n# Content-Type: application/json\n#\n# {\"data\":\"test\"}\n\n```\n\n## Manage Shared Context for Agents\n\n```javascript\nclass o{constructor(e){try{if(\"object\"!=typeof e)return(0,n.Z)(\"shared context requires an object as input\");this.sharedContext={},Object.assign(this.sharedContext,i),Object.entries(e).forEach((e=>{let[t,r]=e;Object.keys(i).includes(t)&&(this.sharedContext[t]=r)}))}catch(e){(0,n.Z)(\"An error occurred while setting SharedContext\",e)}}}}\n```\n\n## httpx: Filter and Store Error Pages\n\n```bash\n# Filter ML-based error page detection\nhttpx -filter-error-page -l urls.txt\n\n# Store filtered error pages to file\nhttpx -filter-error-page -filter-error-page-path errors.json -l urls.txt\n\n```\n\n## Using httpx as a Library in Go\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/projectdiscovery/httpx/runner\"\n)\n\nfunc main() {\n\toptions := &runner.Options{\n\t\t// Configure httpx options here, e.g.:\n\t\tThreads: 50,\n\t\tTimeout: 10,\n\t}\n\n\trunnerInstance, err := runner.New(options)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"unable to create runner: %v\", err))\n\t}\n\n\tdefer runnerInstance.Close()\n\n\tresults := make(chan string)\n\n\tgo func() {\n\t\tfor result := range results {\n\t\t\tfmt.Println(result)\n\t\t}\n\t}()\n\n\t// Example input: a slice of URLs to process\n\tinput := []string{\n\t\t\"http://example.com\",\n\t\t\"https://google.com\",\n\t}\n\n\trunnerInstance.RunEnumeration(input, results)\n}\n```\n\n## Go: Custom Filtering and Matching with httpx\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"github.com/projectdiscovery/goflags\"\n    \"github.com/projectdiscovery/httpx/runner\"\n)\n\nfunc main() {\n    options := runner.Options{\n        Methods\":                  \"GET\",\n        InputTargetHost\":          goflags.StringSlice{\"example.com\", \"test.com\"},\n        OutputMatchStatusCode\":    \"200,301,302\",           // Match these status codes\n        OutputFilterStatusCode\":   \"404,500,502,503\",       // Filter these status codes\n        OutputMatchContentLength\": \"1000,2000\",             // Match these content lengths\n        OutputMatchString\":        goflags.StringSlice{\"admin\", \"login\"}, // Match strings\n        OutputFilterRegex\":        goflags.StringSlice{\"error\", \"404\"},   // Filter regex\n        OutputMatchResponseTime\":  \"< 1\",                   // Match fast responses\n        TechDetect\":               true,\n        StatusCode\":               true,\n        ContentLength\":            true,\n        OutputResponseTime\":       true,\n        ExtractTitle\":             true,\n        JSONOutput\":               true,\n        OnResult: func(r runner.Result) {\n            if r.Err != nil {\n                return\n            }\n\n            // Custom processing logic\n            if r.StatusCode == 200 && r.ContentLength > 1000 {\n                fmt.Printf(\"[INTERESTING] %s - %s [%d bytes]\\n\",\n                    r.URL, r.Title, r.ContentLength)\n            }\n\n            // Check for specific technologies\n            for _, tech := range r.Technologies {\n                if tech == \"wordpress\" || tech == \"joomla\" {\n                    fmt.Printf(\"[CMS DETECTED] %s uses %s\\n\", r.URL, tech)\n                }\n            }\n        },\n    }\n\n    if err := options.ValidateOptions(); err != nil {\n        log.Fatal(err)\n    }\n\n    httpxRunner, err := runner.New(&options)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer httpxRunner.Close()\n\n    httpxRunner.RunEnumeration()\n}\n\n```\n\n## DOM Ready Check and Execution (JavaScript)\n\n```javascript\nfunction i(){return\"undefined\"==typeof document||\"complete\"===document.readyState}function o(e,t){if(i())return e();(0,n.bP)(\"load\",e,t)}function a(e){if(i())return e();(0,n.iz)(\"DOMContentLoaded\",e)}\n```\n\nContext7 cache for httpx: cached at 2026-01-30T06:13:23.863613+00:00Z; consider refreshing if docs changed.",
    "library": "httpx",
    "topic": "best-practices",
    "source": "cache"
  },
  "source": "cache",
  "saved_at": "2026-01-29T22:13:23.933521"
}