{
  "library": "checkpoint_manager",
  "topic": null,
  "documentation": {
    "content": "## List All Frames - Python\n\n```Python\npage.frames()\n```\n\n## Isolated World Contexts\n\n```APIDOC\n## Isolated World Contexts\n\n### Description\nThis section describes the system's support for isolated world contexts within frames. These contexts provide a separate JavaScript environment that shares the DOM but not global variables with the main world.\n\n### Key Features\n- **Independent Execution**: JavaScript executed in an isolated world runs in its own context, preventing interference with the main world's global scope.\n- **DOM Sharing**: Isolated worlds can access and manipulate the same DOM as the main world.\n- **Persistence and Recreation**: Isolated worlds persist across multiple evaluations within the same frame but are recreated upon frame navigation.\n\n### Scenarios\n\n#### Creating an Isolated World\n- **GIVEN**: A `Frame` object.\n- **WHEN**: An isolated world is requested for that frame.\n- **THEN**: A separate execution context is created for that frame.\n\n#### Isolation from Page Globals\n- **GIVEN**: A page with `window.pageSecret = \"secret\"` in the main world.\n- **WHEN**: JavaScript is evaluated in an isolated world of a frame.\n- **THEN**: `window.pageSecret` is `undefined` in the isolated world.\n\n#### DOM Access\n- **GIVEN**: A page with a `<button id=\"btn\">` element.\n- **WHEN**: `document.getElementById(\"btn\")` is evaluated in an isolated world.\n- **THEN**: The button element is returned, demonstrating DOM access.\n\n#### Context Persistence\n- **GIVEN**: An isolated world created for a frame.\n- **WHEN**: Multiple JavaScript evaluations are performed in that isolated world.\n- **THEN**: The same execution context is reused.\n\n#### Context Recreation After Navigation\n- **GIVEN**: An isolated world created for a frame.\n- **WHEN**: The frame navigates to a new URL.\n- **THEN**: The previous isolated world is destroyed, and a new one can be created for the new content.\n```\n\n## Fixture Scoping in Viewpoint Tests\n\n```rust\n// Test-scoped (default): New browser per test\nlet harness = TestHarness::new().await?;\n\n// Module-scoped: Share browser, fresh context per test\nlet harness = TestHarness::from_browser(&shared_browser).await?;\n\n// Shared context: Share context, fresh page per test\nlet harness = TestHarness::from_context(&shared_context).await?;\n```\n\n## Navigate to URL with Playwright-compatible behavior\n\n```rust\nuse crate::navigation::{NavigationError, NavigationResponse};\nuse crate::state::DocumentLoadState;\nuse crate::time::Duration;\n\n// ... \n\n// Navigate with default wait\nlet response: NavigationResponse = page.goto(\"https://example.com\").await?;\n\n// Navigate with custom wait state\nlet response: NavigationResponse = page.goto(\"https://example.com\").wait_until(DocumentLoadState::DomContentLoaded).goto().await?;\n\n// Navigate with referer\nlet response: NavigationResponse = page.goto(\"https://example.com\").referer(\"https://google.com\").goto().await?;\n\n// Navigate with timeout\nmatch page.goto(\"https://slow-site.com\").timeout(Duration::from_secs(5)).goto().await {\n    Ok(response) => { /* handle success */ },\n    Err(NavigationError::Timeout) => { /* handle timeout */ },\n    Err(_) => { /* handle other errors */ },\n};\n```\n\n## Create and manage pages within browser contexts\n\n```rust\nuse crate::page::Page;\n\n// ...\n\n// Create a new page\nlet page: Page = context.new_page().await?;\n\n// Create multiple pages\nlet page1: Page = context.new_page().await?;\nlet page2: Page = context.new_page().await?;\n\n// Close a page\npage.close().await?;\n```\n\n## Page Assertions for URL and Title in Rust\n\n```rust\nuse viewpoint_test::{TestHarness, expect_page};\n\n#[tokio::test]\nasync fn page_assertion_examples() -> Result<(), Box<dyn std::error::Error>> {\n    let harness = TestHarness::new().await?;\n    let page = harness.page();\n    page.goto(\"https://example.com/about\").goto().await?;\n\n    // URL assertions\n    expect_page(page).to_have_url(\"https://example.com/about\").await?;\n    expect_page(page).to_have_url_containing(\"/about\").await?;\n    expect_page(page).to_have_url_matching(r\"example\\.com/about\").await?;\n\n    // Title assertions\n    expect_page(page).to_have_title(\"About Us\").await?;\n    expect_page(page).to_have_title_matching(r\"About.*?\").await?;\n\n    // Negation\n    expect_page(page).not().to_have_url(\"https://wrong.com/\").await?;\n\n    Ok(())\n}\n\n```\n\n## Perform Scalable Accessibility Audits with Rust\n\n```rust\nuse viewpoint_core::{Browser, AriaRole};\n\nlet browser = Browser::launch().headless(true).launch().await?;\n\n// Define pages to audit\nlet pages_to_audit = vec![\n    \"https://example.com/\",\n    \"https://example.com/about\",\n    \"https://example.com/contact\",\n];\n\nfor url in pages_to_audit {\n    // Fresh context per page for isolation, reuse browser for performance\n    let mut context = browser.new_context().await?;\n    let page = context.new_page().await?;\n    page.goto(url).goto().await?;\n    \n    // Validate semantic HTML landmarks\n    let main_count = page.get_by_role(AriaRole::Main).build().count().await?;\n    assert!(main_count >= 1, \"{}: Missing <main> landmark\", url);\n    \n    let nav_count = page.get_by_role(AriaRole::Navigation).build().count().await?;\n    assert!(nav_count >= 1, \"{}: Missing <nav> landmark\", url);\n    \n    // Validate heading hierarchy\n    let h1_count = page.locator(\"h1\").count().await?;\n    assert!(h1_count >= 1, \"{}: Missing <h1>\", url);\n    \n    // Validate images have alt text\n    let images = page.locator(\"img\");\n    for i in 0..images.count().await? {\n        let alt = images.nth(i as i32).get_attribute(\"alt\").await?;\n        assert!(alt.is_some(), \"{}: Image {} missing alt\", url, i);\n    }\n    \n    // Validate buttons have accessible names\n    let buttons = page.get_by_role(AriaRole::Button).build();\n    for i in 0..buttons.count().await? {\n        let btn = buttons.nth(i as i32);\n        let text = btn.text_content().await?;\n        let label = btn.get_attribute(\"aria-label\").await?;\n        assert!(\n            text.map(|t| !t.trim().is_empty()).unwrap_or(false) || label.is_some(),\n            \"{}: Button {} missing accessible name\", url, i\n        );\n    }\n    \n    // Validate form inputs have labels\n    let inputs = page.locator(\"input:not([type='hidden'])\");\n    for i in 0..inputs.count().await? {\n        let input = inputs.nth(i as i32);\n        let has_label = input.get_attribute(\"id\").await?.is_some() \n            || input.get_attribute(\"aria-label\").await?.is_some()\n            || input.get_attribute(\"aria-labelledby\").await?.is_some();\n        assert!(has_label, \"{}: Input {} missing label\", url, i);\n    }\n    \n    // Capture ARIA snapshot for review\n    let snapshot = page.aria_snapshot().await?;\n    println!(\"{}: {}\", url, snapshot.to_yaml());\n    \n    context.close().await?;\n}\n\n```\n\n## Persist Browser Storage State in Rust\n\n```rust\nuse viewpoint_core::Browser;\n\nasync fn storage_state_examples() -> Result<(), Box<dyn std::error::Error>> {\n    // First: Login and save state\n    let browser = Browser::launch().headless(true).launch().await?;\n    let context = browser.new_context().await?;\n    let page = context.new_page().await?;\n\n    page.goto(\"https://example.com/login\").goto().await?;\n    page.get_by_label(\"Email\").fill(\"user@example.com\").await?;\n    page.get_by_label(\"Password\").fill(\"password123\").await?;\n    page.get_by_role(viewpoint_core::AriaRole::Button)\n        .with_name(\"Sign In\")\n        .build()\n        .click()\n        .await?;\n\n    // Save storage state after login\n    context.storage_state()\n        .path(\"auth.json\")\n        .save()\n        .await?;\n\n    // Later: Create a new context with saved state (already logged in)\n    let authenticated_context = browser.new_context_builder()\n        .storage_state_path(\"auth.json\")\n        .build()\n        .await?;\n\n    let page = authenticated_context.new_page().await?;\n    page.goto(\"https://example.com/dashboard\").goto().await?;\n    // User is already logged in!\n\n    Ok(())\n}\n\n```\n\n## Frame Navigation API\n\n```APIDOC\n## Frame Navigation API\n\n### Description\nEnables navigation actions within a specific frame, such as loading new pages or replacing its content.\n\n### Methods\n\n#### `frame.goto(url)`\n\n- **Description**: Navigates the frame to the specified `url`.\n- **Parameters**:\n  - `url` (string) - Required - The URL to navigate the frame to.\n- **Returns**:\n  - `Promise<Response | null>` - A Promise that resolves to the Response object upon successful navigation, or null if navigation fails.\n\n#### `frame.set_content(html)`\n\n- **Description**: Sets the frame's content to the specified `html`.\n- **Parameters**:\n  - `html` (string) - Required - The HTML content to set for the frame.\n- **Returns**:\n  - `Promise<void>` - A Promise that resolves when the content has been set.\n\n### Examples\n\n#### Navigating a frame to a URL\n```javascript\nawait frame.goto(\"https://example.com\");\n```\n\n#### Setting frame content\n```javascript\nawait frame.set_content(\"<h1>New Content</h1>\");\n```\n```\n\n## Navigate Pages with Configurable Wait States and Timeouts in Rust\n\n```rust\nuse viewpoint_core::{Browser, DocumentLoadState};\nuse std::time::Duration;\n\nasync fn navigation_examples() -> Result<(), Box<dyn std::error::Error>> {\n    let browser = Browser::launch().headless(true).launch().await?;\n    let context = browser.new_context().await?;\n    let page = context.new_page().await?;\n\n    // Basic navigation (waits for 'load' event by default)\n    page.goto(\"https://example.com\").goto().await?;\n\n    // Wait for DOM content loaded (faster)\n    page.goto(\"https://example.com\")\n        .wait_until(DocumentLoadState::DomContentLoaded)\n        .goto()\n        .await?;\n\n    // Wait for network idle (slower but complete)\n    page.goto(\"https://example.com\")\n        .wait_until(DocumentLoadState::NetworkIdle)\n        .goto()\n        .await?;\n\n    // Custom timeout and referer\n    page.goto(\"https://example.com\")\n        .timeout(Duration::from_secs(60))\n        .referer(\"https://google.com\")\n        .goto()\n        .await?;\n\n    // Get navigation response info\n    let response = page.goto(\"https://example.com\").goto().await?;\n    if let Some(resp) = response {\n        println!(\"URL: {}, Status: {:?}\", resp.url(), resp.status());\n    }\n\n    Ok(())\n}\n```\n\nContext7 cache for checkpoint_manager: cached at 2026-01-31T02:31:33.620325+00:00Z; consider refreshing if docs changed.",
    "library": "checkpoint_manager",
    "topic": "overview",
    "source": "cache"
  },
  "source": "cache",
  "saved_at": "2026-01-30T18:31:33.715977"
}