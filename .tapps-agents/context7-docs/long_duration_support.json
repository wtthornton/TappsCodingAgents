{
  "library": "long_duration_support",
  "topic": null,
  "documentation": {
    "content": "## Extensibility\n\n```APIDOC\n## Extensibility\n\n### Description\nThe Durable Streams Protocol is designed to be extensible. Any extensions implemented must be pure supersets of the base protocol to ensure backward compatibility with existing clients.\n\n### Principles\n- Extensions **SHOULD** be pure supersets.\n- Compatibility with the base protocol must be maintained.\n```\n\n## Multi-Type Streams Example (JSON)\n\n```json\n[\n  {\n    \"type\": \"user\",\n    \"key\": \"user:123\",\n    \"value\": { \"name\": \"Alice\" },\n    \"headers\": { \"operation\": \"insert\" }\n  },\n  {\n    \"type\": \"message\",\n    \"key\": \"msg:456\",\n    \"value\": { \"userId\": \"user:123\", \"text\": \"Hello!\" },\n    \"headers\": { \"operation\": \"insert\" }\n  },\n  {\n    \"type\": \"reaction\",\n    \"key\": \"reaction:789\",\n    \"value\": { \"messageId\": \"msg:456\", \"emoji\": \"\ud83d\udc4d\" },\n    \"headers\": { \"operation\": \"insert\" }\n  }\n]\n```\n\n## Live Consumption with IAsyncEnumerable and Checkpointing\n\n```csharp\nawait using var client = new DurableStreamClient(new DurableStreamClientOptions\n{\n    BaseUrl = \"https://streams.example.com\"\n});\n\nvar stream = client.GetStream(\"/sensors/temperature\");\n\nusing var cts = new CancellationTokenSource();\nConsole.CancelKeyPress += (_, e) =>\n{\n    e.Cancel = true;\n    cts.Cancel();\n};\n\nawait using var response = await stream.StreamAsync(\n    new StreamOptions { Live = LiveMode.Sse });\n\ntry\n{\n    await foreach (var batch in response.ReadJsonBatchesAsync<TemperatureReading>(cts.Token))\n    {\n        foreach (var reading in batch.Items)\n        {\n            Console.WriteLine($\"Temp: {reading.Value}C at {reading.Timestamp}\");\n        }\n\n        await SaveCheckpointAsync(batch.Checkpoint);\n    }\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Shutting down gracefully...\");\n}\n```\n\n## Key/Value Store Example (JSON)\n\n```json\n{\n  \"type\": \"config\",\n  \"key\": \"theme\",\n  \"value\": \"dark\",\n  \"headers\": { \"operation\": \"insert\" }\n}\n```\n\n## Standard Supervision Tree with Gnat, Broadway, and DynamicSupervisor\n\n```elixir\ndefmodule MyApp.Application do\n  use Application\n\n  def start(_type, _args) do\n    children = [\n      # Connection supervisor with backoff\n      {Gnat.ConnectionSupervisor, connection_settings()},\n\n      # Broadway pipeline\n      MyApp.Broadway,\n\n      # Dynamic consumer supervisor\n      {DynamicSupervisor, name: MyApp.ConsumerSupervisor, strategy: :one_for_one}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n  end\nend\n```\n\n## Example Change Messages for State Materialization (JSON)\n\n```json\n[\n  {\n    \"type\": \"user\",\n    \"key\": \"1\",\n    \"value\": { \"name\": \"Alice\" },\n    \"headers\": { \"operation\": \"insert\" }\n  },\n  {\n    \"type\": \"user\",\n    \"key\": \"2\",\n    \"value\": { \"name\": \"Bob\" },\n    \"headers\": { \"operation\": \"insert\" }\n  },\n  {\n    \"type\": \"user\",\n    \"key\": \"1\",\n    \"value\": { \"name\": \"Alice Smith\" },\n    \"headers\": { \"operation\": \"update\" }\n  }\n]\n```\n\n## Define Optimistic Actions with Server Confirmation (TypeScript)\n\n```typescript\nconst db = createStreamDB({\n  streamOptions: { url: streamUrl, contentType: \"application/json\" },\n  state: schema,\n  actions: ({ db, stream }) => ({\n    addUser: {\n      // Optimistic update (runs immediately)\n      onMutate: (user) => {\n        db.collections.users.insert(user)\n      },\n      // Server mutation (runs async)\n      mutationFn: async (user) => {\n        const txid = crypto.randomUUID()\n\n        await stream.append(\n          schema.users.insert({\n            value: user,\n            headers: { txid },\n          })\n        )\n\n        // Wait for confirmation\n        await db.utils.awaitTxId(txid)\n      },\n    },\n\n    updateUser: {\n      onMutate: ({ id, updates }) => {\n        db.collections.users.update(id, (draft) => {\n          Object.assign(draft, updates)\n        })\n      },\n      mutationFn: async ({ id, updates }) => {\n        const txid = crypto.randomUUID()\n        const current = await db.collections.users.get(id)\n\n        await stream.append(\n          schema.users.update({\n            value: { ...current, ...updates },\n            oldValue: current,\n            headers: { txid },\n          })\n        )\n\n        await db.utils.awaitTxId(txid)\n      },\n    },\n  }),\n})\n\n// Call actions\nawait db.actions.addUser({ id: \"1\", name: \"Kyle\", email: \"kyle@example.com\" })\nawait db.actions.updateUser({ id: \"1\", updates: { name: \"Kyle Mathews\" } })\n```\n\n## Presence Tracking Example (JSON)\n\n```json\n{\n  \"type\": \"presence\",\n  \"key\": \"user:123\",\n  \"value\": { \"status\": \"online\", \"lastSeen\": 1705312200000 },\n  \"headers\": { \"operation\": \"update\" }\n}\n```\n\n## Generic Change Message Structure\n\n```json\n{\n  \"type\": \"<entity-type>\",\n  \"key\": \"<entity-key>\",\n  \"value\": <any-json-value>,\n  \"old_value\": <any-json-value>,  // optional\n  \"headers\": {\n    \"operation\": \"insert\" | \"update\" | \"delete\",\n    \"txid\": \"<transaction-id>\",  // optional\n    \"timestamp\": \"<rfc3339-timestamp>\"  // optional\n  }\n}\n```\n\n## Two-Level Supervision (brod pattern)\n\n```elixir\n# brod uses two-level supervision for producers/consumers\n#\n# TopSupervisor\n# \u251c\u2500\u2500 ProducersSupervisor\n# \u2502   \u251c\u2500\u2500 Producer(topic1, partition0)\n# \u2502   \u251c\u2500\u2500 Producer(topic1, partition1)\n# \u2502   \u2514\u2500\u2500 ...\n# \u2514\u2500\u2500 ConsumersSupervisor\n#     \u251c\u2500\u2500 Consumer(topic1, partition0)\n#     \u2514\u2500\u2500 ...\n\n```\n",
    "library": "long_duration_support",
    "topic": "overview",
    "source": "api"
  },
  "source": "api",
  "saved_at": "2026-01-30T18:31:47.124480"
}