{
  "library": "pylint",
  "topic": "architecture",
  "documentation": {
    "content": "## Safe Bare Except Usage\n\n```python\ntry:\n    # Code that might raise an exception\n    pass\nexcept Exception as e:\n    # Log the exception and traceback\n    import traceback\n    traceback.print_exc()\n    # Or log it using a logging framework\n    # logging.exception(\"An error occurred\")\n\ntry:\n    # Code that might raise an exception\n    pass\nexcept Exception as e:\n    # Perform cleanup actions\n    # ...\n    # Re-raise the exception\n    raise\n\n# Alternative for cleanup: try...finally\ntry:\n    # Code that might raise an exception\n    pass\nfinally:\n    # Cleanup actions that will always execute\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nexec-used (W0122): *Use of exec*\n  Raised when the 'exec' statement is used. It's dangerous to use this function\n  for a user input, and it's also slower than actual code in general. This\n  doesn't mean you should never use it, but you should consider alternatives\n  first and restrict the functions available.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nusing-constant-test (W0125): *Using a conditional statement with a constant value*\n  Emitted when a conditional statement (If or ternary if) uses a constant value\n  for its test. This might not be what the user intended to do.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nmissing-parentheses-for-call-in-test (W0126): *Using a conditional statement with potentially wrong function or method call due to missing parentheses*\n  Emitted when a conditional statement (If or ternary if) seems to wrongly call\n  a function due to missing parentheses\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\ncomparison-of-constants (R0133): *Comparison between constants: '%s %s %s' has a constant value*\n  When two literals are compared with each other the result is a constant. \n  Using the constant directly is both easier to read and more performant.\n  Initializing 'True' and 'False' this way is not required since Python 2.3.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nliteral-comparison (R0123): *In '%s', use '%s' when comparing constant literals not '%s' ('%s')*\n  Used when comparing an object to a literal, which is usually what you do not\n  want to do, since you can compare to a different literal than what was\n  expected altogether.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\ncomparison-with-itself (R0124): *Redundant comparison - %s*\n  Used when something is compared against itself.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\ninvalid-name (C0103): *%s name \"%s\" doesn't conform to %s*\n  Used when the name doesn't conform to naming rules associated to its type\n  (constant, variable, class...).\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nsingleton-comparison (C0121): *Comparison %s should be %s*\n  Used when an expression is compared to singleton values like True, False or\n  None.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\ndisallowed-name (C0104): *Disallowed name \"%s\"*\n  Used when the name matches bad-names or bad-names-rgxs- (unauthorized names).\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nempty-docstring (C0112): *Empty %s docstring*\n  Used when a module, function, class or method has an empty docstring (it\n  would be too easy ;).\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nmissing-class-docstring (C0115): *Missing class docstring*\n  Used when a class has no docstring. Even an empty class must have a\n  docstring.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nmissing-function-docstring (C0116): *Missing function or method docstring*\n  Used when a function or method has no docstring. Some special methods like\n  __init__ do not require a docstring.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nmissing-module-docstring (C0114): *Missing module docstring*\n  Used when a module has no docstring. Empty modules do not require a\n  docstring.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\ntypevar-name-incorrect-variance (C0105): *Type variable name does not reflect variance%s*\n  Emitted when a TypeVar name doesn't reflect its type variance. According to\n  PEP8, it is recommended to add suffixes '_co' and '_contra' to the variables\n  used to declare covariant or contravariant behaviour respectively. Invariant\n  (default) variables do not require a suffix. The message is also emitted when\n  invariant variables do have a suffix.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\ntypevar-double-variance (C0131): *TypeVar cannot be both covariant and contravariant*\n  Emitted when both the \"covariant\" and \"contravariant\" keyword arguments are\n  set to \"True\" in a TypeVar.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\ntypevar-name-mismatch (C0132): *TypeVar name \"%s\" does not match assigned variable name \"%s\"*\n  Emitted when a TypeVar is assigned to a variable that does not match its name\n  argument.\n```\n\n## Pylint Error Codes - Security and Best Practices\n\n```APIDOC\nunidiomatic-typecheck (C0123): *Use isinstance() rather than type() for a typecheck.*\n  The idiomatic way to perform an explicit typecheck in Python is to use\n  isinstance(x, Y) rather than type(x) == Y, type(x) is Y. Though there are\n  unusual situations where these give different results.\n```\n\n## Checker Enhancement: consider-using-in\n\n```python\nExtended ``consider-using-in`` check to work for attribute access.\n```\n\n## String Split Optimization\n\n```python\n# Instead of:\nfirst_part = \"a,b,c\".split(',')[0]\n\n# Use:\nfirst_part = \"a,b,c\".split(',', maxsplit=1)[0]\n\n# Instead of:\nlast_part = \"a,b,c\".rsplit(',', 1)[-1]\n\n# Use:\nlast_part = \"a,b,c\".rsplit(',', maxsplit=1)[-1]\n```\n\n## New Refactoring Message: consider-using-with\n\n```python\nNew refactoring message ``consider-using-with``. This message is emitted if resource-allocating functions or methods of the\nstandard library (like ``open()`` or ``threading.Lock.acquire()``) that can be used as a context manager are called without\na ``with`` block.\n\n  Closes #3413\n```\n\n## Pylint Check Descriptions\n\n```APIDOC\nPylint Checks:\n\n:consider-using-sys-exit (R1722):\n  *Description*: Consider using 'sys.exit' instead of 'exit()' or 'quit()'.\n  *Reasoning*: 'sys.exit' does not rely on the site module, ensuring availability as the 'sys' module is always present.\n\n:consider-using-with (R1732):\n  *Description*: Consider using 'with' for resource-allocating operations.\n  *Reasoning*: Emitted when a resource-allocating assignment or call can be replaced by a 'with' block. This ensures resource release even in case of exceptions.\n\n:super-with-arguments (R1725):\n  *Description*: Consider using Python 3 style super() without arguments.\n  *Reasoning*: Emitted when calling the super() builtin with the current class and instance. In Python 3, these arguments are default and can be omitted.\n\n:use-list-literal (R1734):\n  *Description*: Consider using [] instead of list().\n  *Reasoning*: Emitted when list() is used to create an empty list instead of the literal []. The literal is faster as it avoids an additional function call.\n\n:consider-using-dict-comprehension (R1717):\n  *Description*: Consider using a dictionary comprehension.\n  *Reasoning*: Emitted when a dictionary is created using dict() and a transient list. This can be simplified to a dict comprehension for better readability and performance.\n\n:consider-using-generator (R1728):\n  *Description*: Consider using a generator instead '%s(%s)'.\n  *Reasoning*: If a container can be large, using a generator will improve performance.\n\n:consider-using-set-comprehension (R1718):\n  *Description*: Consider using a set comprehension.\n  *Reasoning*: Simplifies the creation of sets from transient lists, improving readability and performance.\n\n:consider-using-get (R1715):\n  *Description*: Consider using dict.get for getting values from a dict.\n  *Reasoning*: Using dict.get is simpler and more idiomatic for retrieving values or defaults from dictionaries.\n\n:consider-using-join (R1713):\n  *Description*: Consider using str.join(sequence) for concatenating strings.\n  *Reasoning*: str.join(sequence) is faster, uses less memory, and increases readability compared to for-loop concatenation.\n\n:consider-using-ternary (R1706):\n  *Description*: Consider using ternary (%s).\n  *Reasoning*: Used when pre-Python 2.5 ternary syntax is detected.\n\n:consider-swap-variables (R1712):\n  *Description*: Consider using tuple unpacking for swapping variables.\n  *Reasoning*: Tuple unpacking allows direct variable swapping without a temporary variable, improving clarity.\n\n:trailing-comma-tuple (R1707):\n  *Description*: Disallow trailing comma tuple.\n  *Reasoning*: Trailing commas in tuples can lead to unexpected behavior; explicit parentheses are recommended.\n\n:stop-iteration-return (R1708):\n  *Description*: Do not raise StopIteration in generator, use return statement instead.\n  *Reasoning*: According to PEP479, raising StopIteration to end a generator loop can cause bugs; a simple return statement is preferred.\n\n:inconsistent-return-statements (R1710):\n  *Description*: Either all return statements in a function should return an expression, or none of them should.\n  *Reasoning*: PEP8 recommends consistent return statements, either returning values or explicitly returning None.\n\n:redefined-argument-from-local (R1704):\n  *Description*: Redefining argument with the local name %r.\n  *Reasoning*: Redefining an argument with a local name can indicate a potential error.\n\n:chained-comparison (R1716):\n  *Description*: Simplify chained comparison between the operands.\n  *Reasoning*: Boolean operations like \"a < b and b < c\" can be simplified to \"a < b < c\".\n\n:simplifiable-if-expression (R1719):\n  *Description*: The if expression can be replaced with %s.\n  *Reasoning*: If expressions can often be simplified to 'bool(test)' or just 'test'.\n\n:simplifiable-if-statement (R1703):\n  *Description*: The if statement can be replaced with %s.\n  *Reasoning*: If statements can sometimes be replaced with 'bool(test)'.\n\n:too-many-nested-blocks (R1702):\n  *Description*: Too many nested blocks (%s/%s).\n  *Reasoning*: Excessive nesting makes code harder to understand and maintain.\n\n```\n\n## Improvement: used-before-assignment in Loop Else Clauses\n\n```python\n* When evaluating statements in the ``else`` clause of a loop, ``used-before-assignment``\n  assumes that assignments in the except blocks took place if the\n  except handlers constituted the only ways for the loop to finish without\n  breaking early.\n```\n\n## Pylint Usage Flags\n\n```sh\npylint --errors-only your_module.py\npylint --disable=C,R your_module.py\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_pathlib_open:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_codecs_open:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_urlopen:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_named_temporary_file:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_spooled_temporary_file:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_temporary_directory:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_zipfile:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_pyzipfile:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_tarfile:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_lock_acquisition:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_multiprocessing:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_popen:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Consider using 'with' for resource-allocating operations\n\n```python\ntest_subscript_assignment:Consider using 'with' for resource-allocating operations:UNDEFINED\n```\n\n## Pylint Design Checker Configuration\n\n```toml\n[tool.pylint.design]\nexclude-too-few-public-methods = []\n\nignored-parents = []\n\nmax-args = 5\n\nmax-attributes = 7\n\nmax-bool-expr = 5\n\nmax-branches = 12\n\nmax-complexity = 10\n\nmax-locals = 15\n\nmax-parents = 7\n\nmax-positional-arguments = 5\n\nmax-public-methods = 20\n\nmax-returns = 6\n\nmax-statements = 50\n\nmin-public-methods = 2\n```",
    "library": "pylint",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-01-29T22:13:28.936737"
}