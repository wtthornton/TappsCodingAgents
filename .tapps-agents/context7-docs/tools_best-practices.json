{
  "library": "tools",
  "topic": "best-practices",
  "documentation": {
    "content": "## Define Custom Class Strategy for Error Merging\n\n```ruby\nclass FhtagnErrorStrategy\n  def call(attribute, base_errors, store_model_errors)\n    base_errors.add(attribute, \"cthulhu fhtagn\")\n  end\nend\n\nclass FhtagnArrayErrorStrategy\n  def call(attribute, base_errors, store_models)\n    base_errors.add(attribute, \"cthulhu fhtagn\")\n  end\nend\n```\n\n## Apply Custom Error Merging Strategy by Instance\n\n```ruby\nStoreModel.config.merge_errors = FhtagnErrorStrategy.new\n\nclass Product < ApplicationRecord\n  attribute :configuration, Configuration.to_type\n\n  validates :configuration, store_model: { merge_errors: FhtagnErrorStrategy.new }\nend\n```\n\n## Apply Custom Error Merging Strategy by Name\n\n```ruby\nStoreModel.config.merge_errors = :fhtagn_error_strategy\n\nclass Product < ApplicationRecord\n  attribute :configuration, Configuration.to_type\n\n  validates :configuration, store_model: { merge_errors: :fhtagn_error_strategy }\nend\n```\n\n## Define StoreModel Configuration with Validations\n\n```ruby\nclass Configuration\n  include StoreModel::Model\n\n  attribute :model, :string\n  attribute :color, :string\n\n  validates :color, presence: true\nend\n```\n\n## Define Custom Lambda Strategy for Error Merging\n\n```ruby\nlambda_strategy = lambda do |attribute, base_errors, _store_model_errors|\n  base_errors.add(attribute, \"cthulhu fhtagn\")\nend\n\nStoreModel.config.merge_errors = lambda_strategy\n\nStoreModel.config.merge_array_errors = lambda_strategy\n```\n\n## Configure Global StoreModel Error Merging\n\n```ruby\nStoreModel.config.merge_errors = true\n```\n\n## Define StoreModel Enums with Prefix/Suffix Options\n\n```ruby\nclass Review\n  include StoreModel::Model\n\n  enum status: [:active, :archived], _suffix: true\n  enum comments_status: [:active, :inactive], _prefix: :comments\nend\n```\n\n## Use StoreModel Enum Prefix/Suffix Predicate Methods\n\n```ruby\nreview = Review.new(status: :active, comment_status: :inactive)\n\nreview.active_status? # => true\nreview.archived_status? # => false\n\nreview.comments_active? # => false\nreview.comments_inactive? # => true\n```\n\n## Observe Merged StoreModel Validation Errors\n\n```ruby\nproduct = Product.new\nputs product.valid? # => false\nputs product.errors.messages # => { color: [\"can't be blank\"] }\n```\n\n## Controller Actions for StoreModel Nested Attributes\n\n```ruby\ndef create\n  @supplier = Supplier.from_value(supplier_params)\n  @supplier.save\nend\n\nprivate\n\ndef supplier_params\n  params.require(:supplier).permit(products_attributes: [:name])\nend\n```",
    "library": "storage_models",
    "topic": "best-practices",
    "source": "fuzzy_match"
  },
  "source": "fuzzy_match",
  "saved_at": "2026-02-03T09:49:38.104705"
}